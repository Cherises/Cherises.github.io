<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础面试 | Leo's Digital Genesis</title><meta name="author" content="Leonardo"><meta name="copyright" content="Leonardo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="✅Arrays.sort是使用什么排序算法实现的？ 典型回答 Arrays.sort是Java中提供的对数组进行排序的方法，根据参数类型不同，它提供了很多重载方法：  1 2 3 4   public static void sort(Object[] a) ; public static void sort(byte[] a) public static void sort(float[] a)">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础面试">
<meta property="og:url" content="https://cherises.github.io/post/34247/index.html">
<meta property="og:site_name" content="Leo&#39;s Digital Genesis">
<meta property="og:description" content="✅Arrays.sort是使用什么排序算法实现的？ 典型回答 Arrays.sort是Java中提供的对数组进行排序的方法，根据参数类型不同，它提供了很多重载方法：  1 2 3 4   public static void sort(Object[] a) ; public static void sort(byte[] a) public static void sort(float[] a)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/573.png">
<meta property="article:published_time" content="2025-11-01T11:19:33.000Z">
<meta property="article:modified_time" content="2025-11-01T14:16:40.302Z">
<meta property="article:author" content="Leonardo">
<meta property="article:tag" content="Artificial Intelligence">
<meta property="article:tag" content="Quantum Computing">
<meta property="article:tag" content="Neural Networks">
<meta property="article:tag" content="Future Tech">
<meta property="article:tag" content="Digital Philosophy">
<meta property="article:tag" content="Cybersecurity">
<meta property="article:tag" content="Blockchain">
<meta property="article:tag" content="Metaverse">
<meta property="article:tag" content="Algorithmic Ethics">
<meta property="article:tag" content="Space Technology">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/573.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础面试",
  "url": "https://cherises.github.io/post/34247/",
  "image": "https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/573.png",
  "datePublished": "2025-11-01T11:19:33.000Z",
  "dateModified": "2025-11-01T14:16:40.302Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo",
      "url": "https://github.com/Cherises/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://cherises.github.io/post/34247/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础面试',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/admonition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/b1.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/actor-1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Wujie/"><i class="fa-fw fas fa-globe"></i><span> WuJie</span></a></div><div class="menus_item"><a class="site-page" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Leo's Digital Genesis</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础面试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Wujie/"><i class="fa-fw fas fa-globe"></i><span> WuJie</span></a></div><div class="menus_item"><a class="site-page" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-11-01T11:19:33.000Z" title="Created 2025-11-01 11:19:33">2025-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-01T14:16:40.302Z" title="Updated 2025-11-01 14:16:40">2025-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/Java%E9%9D%A2%E8%AF%95/">Java面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/Java%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">37.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>132mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="✅Arrays-sort是使用什么排序算法实现的？"><a href="#✅Arrays-sort是使用什么排序算法实现的？" class="headerlink" title="✅Arrays.sort是使用什么排序算法实现的？"></a>✅Arrays.sort是使用什么排序算法实现的？</h1><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Arrays.sort是Java中提供的对数组进行排序的方法，根据参数类型不同，它提供了很多重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">byte</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">float</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> </span><br></pre></td></tr></table></figure>

<p>而针对不同的参数类型，采用的算法也不尽相同，首先，对于比较常见的基本数据类型（如int、double、char等）的数组，就是采用JDK 1.7中引入的**“双轴快速排序”（Dual-Pivot QuickSort）**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里的DualPivotQuicksort.sort就是双轴快速排序的具体实现。</p>
<blockquote>
<p>双轴快速排序是对传统快速排序的改进，它通过选择两个轴值来划分数组，并在每个划分区域中进行递归排序。这种算法通常比传统的快速排序更快，特别是在大量重复元素的情况下。双轴快速排序算法是在JDK7中引入的，并在后续版本中进行了优化和改进。</p>
</blockquote>
<p>而针对另外一种类型，对于对象数组的排序，它支持两种排序方式，即<strong>归并排序和TimSort</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.7以前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    Object[] aux = (Object[])a.clone();</span><br><span class="line">    mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.7以后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** To be removed in a future release. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">legacyMergeSort</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    Object[] aux = a.clone();</span><br><span class="line">    mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里面的MergeSort指的就是归并排序，这个算法是老版本中设计的，后续的版本中可能会被移除，新版本中主要采用TimSort算法。</p>
<blockquote>
<p>TimSort 是一种混合排序算法，结合了归并排序（Merge Sort）和插入排序（Insertion Sort）的特点。</p>
</blockquote>
<p><strong>关于各种算法的原理和实现方式，因为不是我们八股文的重点，关于算法部分大家自行学习吧，这里就不展开了，大家想了解的可以自己去看一下相关算法的实现。</strong></p>
<h1 id="✅BigDecimal-double-和BigDecimal-String-有什么区别？"><a href="#✅BigDecimal-double-和BigDecimal-String-有什么区别？" class="headerlink" title="✅BigDecimal(double)和BigDecimal(String)有什么区别？"></a>✅BigDecimal(double)和BigDecimal(String)有什么区别？</h1><h2 id="典型回答-1"><a href="#典型回答-1" class="headerlink" title="典型回答"></a>典型回答</h2><p>有区别，而且区别很大。</p>
<p>因为double是不精确的，所以使用一个不精确的数字来创建BigDecimal，得到的数字也是不精确的。如0.1这个数字，double只能表示他的近似值。</p>
<p>所以，<strong>当我们使用new BigDecimal(0.1)创建一个BigDecimal 的时候，其实创建出来的值并不是正好等于0.1的。</strong></p>
<p>而是0.1000000000000000055511151231257827021181583404541015625。这是因为double自身表示的只是一个近似值。</p>
<p>而对于BigDecimal(String) ，当我们使用new BigDecimal(“0.1”)创建一个BigDecimal 的时候，其实创建出来的值正好就是等于0.1的。</p>
<p>那么他的标度也就是1</p>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><p>在《阿里巴巴Java开发手册》中有一条建议，或者说是要求：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/leV5XcPUkWM7yyAs/1726909496044-239d8180-315f-478f-a102-46d67004df61-581943.jpeg" alt="16119907257353.jpg"></p>
<h3 id="BigDecimal如何精确计数？"><a href="#BigDecimal如何精确计数？" class="headerlink" title="BigDecimal如何精确计数？"></a>BigDecimal如何精确计数？</h3><p>如果大家看过BigDecimal的源码，其实可以发现，<strong>实际上一个BigDecimal是通过一个”无标度值”和一个”标度”来表示一个数的。</strong></p>
<blockquote>
<p><strong>无标度值（Unscaled Value）</strong>：这是一个整数，表示BigDecimal的实际数值。</p>
<p><strong>标度（Scale）</strong>：这是一个整数，表示小数点后的位数。</p>
<p>BigDecimal的实际数值计算公式为：unscaledValue × 10^(-scale)。</p>
</blockquote>
<p>假设有一个BigDecimal表示的数值是123.45，那么无标度值（Unscaled Value）是12345。标度（Scale）是2。因为123.45 &#x3D; 12345 × 10^(-2)。</p>
<p>涉及到的字段就是这几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">long</span> intCompact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于无标度值的压缩机制大家了解即可，不是本文的重点，大家只需要知道BigDecimal主要是通过一个无标度值和标度来表示的就行了。<br><strong>那么标度到底是什么呢？</strong><br>除了scale这个字段，在BigDecimal中还提供了scale()方法，用来返回这个BigDecimal的标度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the &lt;i&gt;scale&lt;/i&gt; of this &#123;<span class="doctag">@code</span> BigDecimal&#125;.  If zero</span></span><br><span class="line"><span class="comment"> * or positive, the scale is the number of digits to the right of</span></span><br><span class="line"><span class="comment"> * the decimal point.  If negative, the unscaled value of the</span></span><br><span class="line"><span class="comment"> * number is multiplied by ten to the power of the negation of the</span></span><br><span class="line"><span class="comment"> * scale.  For example, a scale of &#123;<span class="doctag">@code</span> -3&#125; means the unscaled</span></span><br><span class="line"><span class="comment"> * value is multiplied by 1000.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the scale of this &#123;<span class="doctag">@code</span> BigDecimal&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scale</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，scale到底表示的是什么，其实上面的注释已经说的很清楚了。</p>
<blockquote>
<p>当标度为正数时，它表示小数点后的位数。例如，在数字123.45中，他的无标度值为12345，标度是2。</p>
<p>当标度为零时，BigDecimal表示一个整数。</p>
<p>当标度为负数时，它表示小数点向左移动的位数，相当于将数字乘以 10 的绝对值的次方。例如，一个数值为1234500，那么他可以用value是12345，scale为-2来表示，因为1234500 * 10^(-2) &#x3D; 12345。（当需要处理非常大的整数时，可以使用负数的标度来指定小数点左侧的位数。这在需要保持整数的精度而又不想丢失尾部零位时很有用。）</p>
</blockquote>
<p><strong>而二进制无法表示的0.1，使用BigDecimal就可以表示了，及通过无标度值1和标度1来表示。</strong></p>
<p>我们都知道，想要创建一个对象，需要使用该类的构造方法，在BigDecimal中一共有以下4个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(<span class="type">int</span>)</span><br><span class="line">BigDecimal(<span class="type">double</span>) </span><br><span class="line">BigDecimal(<span class="type">long</span>) </span><br><span class="line">BigDecimal(String)</span><br></pre></td></tr></table></figure>
<p>以上四个方法，创建出来的BigDecimal的标度（scale）是不同的。</p>
<p>其中 BigDecimal(int)和BigDecimal(long) 比较简单，因为都是整数，所以他们的标度都是0。</p>
<p>而BigDecimal(double) 和BigDecimal(String)的标度就有很多学问了。</p>
<h3 id="BigDecimal-double-有什么问题"><a href="#BigDecimal-double-有什么问题" class="headerlink" title="BigDecimal(double)有什么问题"></a>BigDecimal(double)有什么问题</h3><p>BigDecimal中提供了一个通过double创建BigDecimal的方法——BigDecimal(double) ，但是，同时也给我们留了一个坑！</p>
<p>因为我们知道，double表示的小数是不精确的，如0.1这个数字，double只能表示他的近似值。</p>
<p>所以，<strong>当我们使用new BigDecimal(0.1)创建一个BigDecimal 的时候，其实创建出来的值并不是正好等于0.1的。</strong></p>
<p>而是0.1000000000000000055511151231257827021181583404541015625。这是因为double自身表示的只是一个近似值。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/leV5XcPUkWM7yyAs/1726909496014-d2884b97-5ebb-4b61-bddd-58a8b6270fc0-617972.jpeg" alt="16119945021181.jpg"></p>
<p><strong>所以，如果我们在代码中，使用BigDecimal(double) 来创建一个BigDecimal的话，那么是损失了精度的，这是极其严重的。</strong></p>
<h3 id="使用BigDecimal-String-创建"><a href="#使用BigDecimal-String-创建" class="headerlink" title="使用BigDecimal(String)创建"></a>使用BigDecimal(String)创建</h3><p>那么，该如何创建一个精确的BigDecimal来表示小数呢，答案是使用String创建。</p>
<p>而对于BigDecimal(String) ，当我们使用new BigDecimal(“0.1”)创建一个BigDecimal 的时候，其实创建出来的值正好就是等于0.1的。</p>
<p>那么他的标度也就是1。</p>
<p>但是需要注意的是，new BigDecimal(“0.10000”)和new BigDecimal(“0.1”)这两个数的标度分别是5和1，如果使用BigDecimal的equals方法比较，得到的结果是false。</p>
<p>那么，想要创建一个能精确的表示0.1的BigDecimal，请使用以下两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">recommend1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">recommend2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>

<p>这里，留一个思考题，BigDecimal.valueOf()是调用Double.toString方法实现的，那么，既然double都是不精确的，BigDecimal.valueOf(0.1)怎么保证精确呢？</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为计算机采用二进制处理数据，但是很多小数，如0.1的二进制是一个无限循环小数，而这种数字在计算机中是无法精确表示的。</p>
<p>所以，人们采用了一种通过近似值的方式在计算机中表示，于是就有了单精度浮点数和双精度浮点数等。</p>
<p>所以，作为单精度浮点数的float和双精度浮点数的double，在表示小数的时候只是近似值，并不是真实值。</p>
<p>所以，当使用BigDecimal(Double)创建一个的时候，得到的BigDecimal是损失了精度的。</p>
<p>而使用一个损失了精度的数字进行计算，得到的结果也是不精确的。</p>
<p>想要避免这个问题，可以通过BigDecimal(String)的方式创建BigDecimal，这样的情况下，0.1就会被精确的表示出来。</p>
<p>其表现形式是一个无标度数值1，和一个标度1的组合。</p>
<h1 id="✅BigDecimal和Long表示金额哪个更合适，怎么选择？"><a href="#✅BigDecimal和Long表示金额哪个更合适，怎么选择？" class="headerlink" title="✅BigDecimal和Long表示金额哪个更合适，怎么选择？"></a>✅BigDecimal和Long表示金额哪个更合适，怎么选择？</h1><h2 id="典型回答-2"><a href="#典型回答-2" class="headerlink" title="典型回答"></a>典型回答</h2><p>大家都知道，不能用Float和Double来表示金额，会存在丢失精度的问题。</p>
<p>那么要表示金额，业内有两种做法：</p>
<p>1、单位为分，数据库存bigint，代码中用long</p>
<p>2、单位为元，数据库用decimal，代码中用BigDecimal（我们一般数据库存储的是decimal(18,6)）</p>
<p>这两种，其实我们都用过，而且现在也还都在用，因为他们都有各自的优缺点以及适用场景。</p>
<p>首先说<strong>BigDecimal</strong>，<code>BigDecimal</code> 是 Java 中用于精确计算的类，特别适合于需要高精度数值计算的场景，如金融、计量和工程等领域。其特点如下：</p>
<ul>
<li><strong>精确度高</strong>：<code>BigDecimal</code> 可以表示非常大或非常精确的小数，而不会出现浮点数那样的舍入误差。</li>
<li><strong>灵活的数学运算</strong>：它提供各种方法进行精确的算术操作，包括加减乘除和四舍五入等。</li>
<li><strong>控制舍入行为</strong>：在进行数学运算时，你可以指定舍入模式，这对于金融计算非常重要。</li>
</ul>
<p><strong>所以，BigDecimal的适用场景是需要高精度计算的金融应用，如货币计算、利率计算等。比如我们的结算系统、支付系统、账单系统等，都是用BigDecimal的。</strong></p>
<p>其次，再说Long，<code>long</code> 是 Java 的一种基本数据类型，用于表示没有小数部分的整数。其特点如下：</p>
<ul>
<li><strong>性能高</strong>：作为基本数据类型，<code>long</code> 在处理速度上比 <code>BigDecimal</code> 快很多。</li>
<li><strong>容量限制</strong>：<code>long</code> 可以表示的最大值为 (2^{63}-1)，最小值为 (-2^{63})。这在大多数应用程序中已经足够，但在表示非常大的数或需要小数的计算中则不适用。</li>
<li><strong>不适合精确的小数运算</strong>：<code>long</code> 无法处理小数，如果需要代表金额中的小数部分（如厘），则需要自行管理这一部分。</li>
</ul>
<p><strong>所以，Long的适用场景是适合于不涉及小数计算的大整数运算，如某些计数应用或者金额以整数形式表示。比如我们的额度系统、积分系统等。</strong></p>
<hr>
<p>很多人会有疑惑，什么情况下会出现需要比分还小的单位呢？其实就是在很多需要运算的场景，比如说金融的费率、利率、服务费的费率等等，这些都是很小的，一般都是万分之几或者千分之几。而一旦有一个单位为元的金额和一个”率”相乘的时候，就会出现小于分的单位。</p>
<p>那有人说，遇到分我就直接四舍五入不就行了么，反正结算也是按照分结算的。这样做会有问题，我举个例子。</p>
<p>我一笔账单，有两笔订单，金额都是1元，存储的时候按照分存储，即100分，然后我的服务费费率是0.004。</p>
<p>如果是以分为单位，long存储和表示的话，那么两笔订单分开算费率的话：100*0.004 &#x3D; 0.4 ，四舍五入 0， 两笔加在一起，收入的费率就是0分。</p>
<p>但是如说是以元为单位，bigdecimal存储和表示的话，那么两笔订单分开算费率的话：1*0.004 &#x3D; 0.004 ， 两笔加在一起0.008，当我要结算的时候，再做四舍五入就是0.01元，即1分钱。</p>
<p>所以，<strong>因为long在计算和存储的过程中都会丢失掉小数部分，那就会导致每一次都被迫需要四舍五入。而decimal完全可以保留过程中的数据，再最终需要的时候做一次整体的四舍五入，这样结果就会更加精确！</strong></p>
<p>所以，如果你的应用需要处理小数点后的精确计算（如金融计算中常见的多位小数），则应选择 <code>BigDecimal</code>。</p>
<p>如果你的应用对性能要求极高，并且没有乘除类运算，不需要很小的精度时，那么使用 <code>long</code> 可能更合适。</p>
<p>总结来说，对于绝大多数涉及货币计算的应用，推荐使用 <code>BigDecimal</code>，因为它提供了必要的精度和灵活性，尽管牺牲了一些性能。如果确定不需要处理小数，并且对执行速度有极端要求，使用 <code>long</code> 可能更适合。</p>
<h1 id="✅char能存储中文吗？"><a href="#✅char能存储中文吗？" class="headerlink" title="✅char能存储中文吗？"></a>✅char能存储中文吗？</h1><h2 id="典型回答-3"><a href="#典型回答-3" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java中，char类型是用来表示一个16位（2个字节）的Unicode字符，它可以存储任何Unicode字符集中的字符，当然也包括中文字符。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch = &#x27;龗&#x27;;</span><br><span class="line">System.out.println(ch); // 输出：龗</span><br></pre></td></tr></table></figure>

<p>但是，有人说，Java中的char是没办法表示生僻字的，这么说其实有点绝对了。</p>
<p>因为Unicode字符集包含了几乎所有的字符，包括常见字符、生僻字、罕见字以及其他语言的字符。所以，用char类型其实是可以存储生僻字的。</p>
<p>但是，在处理生僻字时，需要确保Java源代码文件本身以及编译器和运行时环境都支持Unicode字符集。另外，如果在字符串中使用生僻字，也需要注意字符编码和字符串长度的问题。</p>
<p>还有一点需要注意，Unicode字符集的目标是覆盖世界上所有的字符。然而，由于生僻字的数量庞大且不断增长，Unicode字符集可能无法及时收录所有生僻字。这主要取决于Unicode标准的版本以及生僻字的使用频率和普及程度。</p>
<p>虽然Unicode字符集也在一直不断的迭代更新，但是对于一些非常罕见的生僻字，它们可能因为版本问题，或者时间问题，暂时不在Unicode字符集中。在这种情况下，可能就会无法表示。</p>
<h1 id="✅ClassNotFoundException和NoClassDefFoundError的区别是什么？"><a href="#✅ClassNotFoundException和NoClassDefFoundError的区别是什么？" class="headerlink" title="✅ClassNotFoundException和NoClassDefFoundError的区别是什么？"></a>✅ClassNotFoundException和NoClassDefFoundError的区别是什么？</h1><h2 id="典型回答-4"><a href="#典型回答-4" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>ClassNotFoundException</strong>是一个受检异常（checked exception）。他通常在运行时，在类加载阶段尝试加载类的过程中，找不到类的定义时触发。通常是由Class.forName()或类加载器loadClass或者findSystemClass时，在类路径中没有找到指定名称的类时，会抛出该异常。表示所需的类在类路径中不存在。这通常是由于类名拼写错误或缺少依赖导致的。</p>
<p>如以下方式加载JDBC驱动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们的classpath中没有对应的jar包时，就会抛出这个ClassNotFoundException。</p>
<p><strong>NoClassDefFoundError</strong>是一个错误（error），它表示运行时尝试加载一个类的定义时，虽然找到了类文件，但在加载、解析或链接类的过程中发生了问题。这通常是由于依赖问题或类定义文件（.class文件）损坏导致的。也就是说这个类在编译时存在，运行时丢失了，就会导致这个异常。</p>
<p>如以下情况，我们定义A类和B类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在编译后会生成A.class和B.class，当我们删除A.class之后，单独运行B.class的时候，就会发生NoClassDefFoundError</p>
<blockquote>
<p>扩展知识<br>NoSuchMethodError<br>NoSuchMethodError表示方法找不到，他和NoClassDefFoundError类似，都是编译期找得到，运行期找不到了。</p>
</blockquote>
<p>这种error发生在生产环境中是，通常来说大概率是发生了jar包冲突。</p>
<h1 id="✅final、finally、finalize有什么区别"><a href="#✅final、finally、finalize有什么区别" class="headerlink" title="✅final、finally、finalize有什么区别"></a>✅final、finally、finalize有什么区别</h1><h2 id="典型回答-5"><a href="#典型回答-5" class="headerlink" title="典型回答"></a>典型回答</h2><p>final、finally、finalize有什么区别？这个问题就像周杰、周杰伦和周星驰之间有啥关系的问题一样。其实没啥关系，放在一起比较无非是名字有点像罢了。</p>
<p>final、finally和finalize是Java中的三个不同的概念。</p>
<ul>
<li><strong>final</strong>：用于声明变量、方法或类，使之不可变、不可重写或不可继承。</li>
<li><strong>finally</strong>：是异常处理的一部分，用于确保代码块（通常用于资源清理）总是执行。</li>
<li><strong>finalize</strong>：是Object类的一个方法，用于在对象被垃圾回收前执行清理操作，但通常不推荐使用。</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final是一个关键字，可以用来修饰变量、方法和类。分别代表着不同的含义。</p>
<p><strong>final变量</strong>：即我们所说的常量，一旦被赋值后，就不能被修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> x <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> x <span class="operator">=</span> <span class="number">200</span>; <span class="operator">/</span><span class="operator">/</span> 编译错误，不能修改<span class="keyword">final</span>变量的值</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> String AUTHOR_NAME <span class="operator">=</span> &quot;Hollis&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>final方法</strong>：不能被子类重写。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> void <span class="keyword">show</span>() &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final类</strong>：不能被继承。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> class MyFinalClass &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally是一个用于异常处理，它和try、catch块一起使用。无论是否捕获或处理异常，finally块中的代码总是执行（程序正常执行的情况）。通常用于关闭资源，如输入&#x2F;输出流、数据库连接等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 可能产生异常的代码</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 异常处理代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 清理代码，总是执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>finalize是Object类的一个方法，用于垃圾收集过程中的资源回收。在对象被垃圾收集器回收之前，finalize方法会被调用，用于执行清理操作（例如释放资源）。但是，不推荐依赖finalize方法进行资源清理，因为它的调用时机不确定且不可靠。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 在对象被回收时执行清理工作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="✅finally中代码一定会执行吗？"><a href="#✅finally中代码一定会执行吗？" class="headerlink" title="✅finally中代码一定会执行吗？"></a>✅finally中代码一定会执行吗？</h1><h2 id="典型回答-6"><a href="#典型回答-6" class="headerlink" title="典型回答"></a>典型回答</h2><p>通常情况下，finally的代码一定会被执行，但是这是有一个前提的，：</p>
<p>1、对应 try 语句块被执行， </p>
<p>2、程序正常运行。</p>
<p>如果没有符合这两个条件的话，finally中的代码就无法被执行，如发生以下情况，都会导致finally不会执行：</p>
<p>1、System.exit()方法被执行</p>
<p>2、Runtime.getRuntime().halt()方法被执行</p>
<p>3、try或者catch中有死循环</p>
<p>4、操作系统强制杀掉了JVM进程，如执行了kill -9</p>
<p>5、其他原因导致的虚拟机崩溃了</p>
<p>6、虚拟机所运行的环境挂了，如计算机电源断了</p>
<p>7、如果一个finally是由守护线程执行的，那么是不保证一定能执行的，如果这时候JVM要退出，JVM会检查其他非守护线程，如果都执行完了，那么就直接退出了。这时候finally可能就没办法执行完。</p>
<h1 id="✅Java的动态代理如何实现？"><a href="#✅Java的动态代理如何实现？" class="headerlink" title="✅Java的动态代理如何实现？"></a>✅Java的动态代理如何实现？</h1><h2 id="典型回答-7"><a href="#典型回答-7" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>在Java中，实现动态代理有两种方式：</strong></p>
<ol>
<li><strong>JDK动态代理</strong>：Java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。</li>
<li><strong>Cglib动态代理</strong>：Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</li>
</ol>
<p><strong>JDK动态代理和Cglib动态代理的区别：</strong></p>
<hr>
<p>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。</p>
<p>Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p>
<p>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p><strong>所以，使用JDK动态代理的对象必须实现一个或多个接口；而使用cglib代理的对象则无需实现接口，达到代理类无侵入。</strong></p>
<h1 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h1><h2 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h2><p>最大的区别就是静态代理是编译期确定的，但是动态代理却是运行期确定的。</p>
<p>同时，使用静态代理模式需要程序员手写很多代码，这个过程是比较浪费时间和精力的。一旦需要代理的类中方法比较多，或者需要同时代理多个对象的时候，这无疑会增加很大的复杂度。</p>
<p>反射是动态代理的实现方式之一。</p>
<h2 id="动态代理的用途"><a href="#动态代理的用途" class="headerlink" title="动态代理的用途"></a>动态代理的用途</h2><p>Java的动态代理，在日常开发中可能并不经常使用，但是并不代表他不重要。<strong>Java的动态代理的最主要的用途就是应用在各种框架中。因为使用动态代理可以很方便的运行期生成代理类，通过代理类可以做很多事情，比如AOP，比如过滤器、拦截器等。</strong></p>
<p>在我们平时使用的框架中，像servlet的filter、包括spring提供的aop以及struts2的拦截器都使用了动态代理功能。我们日常看到的mybatis分页插件，以及日志拦截、事务拦截、权限拦截这些几乎全部由动态代理的身影。</p>
<h2 id="Spring-AOP的实现方式"><a href="#Spring-AOP的实现方式" class="headerlink" title="Spring AOP的实现方式"></a>Spring AOP的实现方式</h2><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。</p>
<p>JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</p>
<p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<h2 id="JDK-动态代理的代码段"><a href="#JDK-动态代理的代码段" class="headerlink" title="JDK 动态代理的代码段"></a>JDK 动态代理的代码段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------add----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        PerformanceMonior.begin(target.getClass().getName()+<span class="string">&quot;.&quot;</span>+method.getName());</span><br><span class="line">        <span class="comment">//System.out.println(&quot;-----------------begin &quot;+method.getName()+&quot;-----------------&quot;);</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;-----------------end &quot;+method.getName()+&quot;-----------------&quot;);</span></span><br><span class="line">        PerformanceMonior.end();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(service);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) handler.getProxy();</span><br><span class="line">    proxy.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cglib动态代理的代码段"><a href="#Cglib动态代理的代码段" class="headerlink" title="Cglib动态代理的代码段"></a>Cglib动态代理的代码段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------add----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>(); </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(Class clazz)</span>&#123; </span><br><span class="line">        <span class="comment">//设置需要创建子类的类 </span></span><br><span class="line">        enhancer.setSuperclass(clazz); </span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>); </span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例 </span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//实现MethodInterceptor接口方法 </span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span><br><span class="line"><span class="params">        MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;前置代理&quot;</span>); </span><br><span class="line">        <span class="comment">//通过代理类调用父类中的方法 </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); </span><br><span class="line">        System.out.println(<span class="string">&quot;后置代理&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoCGLib</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(); </span><br><span class="line">        <span class="comment">//通过生成子类的方式创建代理类 </span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">proxyImp</span> <span class="operator">=</span> (UserServiceImpl)proxy.getProxy(UserServiceImpl.class); </span><br><span class="line">        proxyImp.add(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="✅Java和C-主要区别有哪些？各有哪些优缺点？"><a href="#✅Java和C-主要区别有哪些？各有哪些优缺点？" class="headerlink" title="✅Java和C++主要区别有哪些？各有哪些优缺点？"></a>✅Java和C++主要区别有哪些？各有哪些优缺点？</h1><h2 id="典型回答-8"><a href="#典型回答-8" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java和C++都是面向对象的语言，他们一个是编译型语言，一个是解释型语言。</p>
<p><strong>C++是编译型语言</strong>（首先将源代码编译生成机器码，再由机器运行机器码），执行速度快、效率高；依赖编译器、跨平台性差些。</p>
<p><strong>Java是解释型语言</strong>（源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。），执行速度慢、效率低；依赖解释器、跨平台性好。</p>
<blockquote>
<p>PS：也有人说Java是半编译、半解释型语言。Java 编译器(javac)先将java源程序编译成Java字节码(.class)，JVM负责解释执行字节码文件。</p>
</blockquote>
<p>二者更多的主要区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Java</strong></th>
<th><strong>C++</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>跨平台</strong></td>
<td>平台无关</td>
<td>平台有关</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>自动</td>
<td>手动</td>
</tr>
<tr>
<td><strong>参数传递方式</strong></td>
<td>值传递</td>
<td>引用、指针、值传递</td>
</tr>
<tr>
<td><strong>多继承</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>系统资源的控制能力</strong></td>
<td>弱</td>
<td>强</td>
</tr>
<tr>
<td><strong>适合领域</strong></td>
<td>企业级Web应用开发</td>
<td>系统编程、游戏开发等</td>
</tr>
</tbody></table>
<ul>
<li><p>C++是<strong>平台相关</strong>的，Java是<strong>平台无关</strong>的。</p>
</li>
<li><p>Java是<strong>自动内存管理和垃圾回收</strong>的，C++需要手动内存管理，支持析构函数，Java没有析构函数的概念。</p>
</li>
<li><p>C++支持指针，引用，传值调用 。<strong>Java只有值传递。</strong></p>
</li>
<li><p>C++支持多重继承，包括虚拟继承 。<strong>Java只允许单继承</strong>，需要多继承的情况要使用接口。</p>
</li>
<li><p>C++对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样。Java在所有平台上对所有的基本类型都有标准的范围限制和字节长度。</p>
</li>
<li><p>C++除了一些比较少见的情况之外和C语言兼容 。 Java没有对任何之前的语言向前兼容。但在语法上受 C&#x2F;C++ 的影响很大</p>
</li>
<li><p>C++允许直接调用本地的系统库 。 Java要通过JNI调用。</p>
</li>
</ul>
<p><strong>Java的优点是跨平台能力强，支持自动内存管理减少内存泄露风险。有大量的库和框架支持（特别是企业级应用开发），并且还有较强的社区支持和资源。</strong></p>
<hr>
<p>Java的缺点是性能不如C++，对系统资源的控制能力较弱。</p>
<hr>
<p><strong>C++的优点是性能高，控制能力强。可以直接操作内存和硬件的能力。适用于系统编程、游戏开发、实时系统。同时也有丰富的库和工具，特别是在图形和游戏领域。</strong></p>
<hr>
<p>C++的缺点是内存管理复杂，容易出错。跨平台开发困难。代码会比较复杂，学习曲线比较陡。</p>
<hr>
<h1 id="✅Java是值传递还是引用传递？"><a href="#✅Java是值传递还是引用传递？" class="headerlink" title="✅Java是值传递还是引用传递？"></a>✅Java是值传递还是引用传递？</h1><h2 id="典型回答-9"><a href="#典型回答-9" class="headerlink" title="典型回答"></a>典型回答</h2><p>编程语言中需要进行方法间的参数传递，这个传递的策略叫做<strong>求值策略</strong>。</p>
<p>在程序设计中，求值策略有很多种，比较常见的就是<strong>值传递和引用传递</strong>。</p>
<p><strong>值传递和引用传递最大的区别是传递的过程中有没有<strong><strong>复制</strong></strong>出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。</strong></p>
<p><strong>Java对象的传递，是通过复制的方式把引用关系传递了，因为有<strong><strong>复制</strong></strong>的过程，所以是值传递</strong>，只不过对于Java对象的传递，传递的内容是对象的引用。</p>
<h2 id="扩展知识-1"><a href="#扩展知识-1" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="Java的求值策略"><a href="#Java的求值策略" class="headerlink" title="Java的求值策略"></a>Java的求值策略</h3><p>前面我们介绍过了传值调用、传引用调用以及传值调用的特例传共享对象调用，那么，Java中是采用的哪种求值策略呢？</p>
<p>很多人说Java中的基本数据类型是值传递的，这个基本没有什么可以讨论的，普遍都是这样认为的。</p>
<p>但是，有很多人却误认为Java中的对象传递是引用传递。之所以会有这个误区，主要是因为Java中的变量和对象之间是有引用关系的。Java语言中是通过对象的引用来操纵对象的。所以，很多人会认为对象的传递是引用的传递。</p>
<p>而且很多人还可以举出以下的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Test pt = new Test();</span><br><span class="line"></span><br><span class="line">  User hollis = new User();</span><br><span class="line">  hollis.setName(&quot;Hollis&quot;);</span><br><span class="line">  hollis.setGender(&quot;Male&quot;);</span><br><span class="line">  pt.pass(hollis);</span><br><span class="line">  System.out.println(&quot;print in main , user is &quot; + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pass(User user) &#123;</span><br><span class="line">  user.setName(&quot;hollischuang&quot;);</span><br><span class="line">  System.out.println(&quot;print in pass , user is &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=&#x27;hollischuang&#x27;, gender=&#x27;Male&#x27;&#125;</span><br><span class="line">print in main , user is User&#123;name=&#x27;hollischuang&#x27;, gender=&#x27;Male&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对象类型在被传递到pass方法后，在方法内改变了其内容，最终调用方main方法中的对象也变了。</p>
<p>所以，很多人说，这和引用传递的现象是一样的，就是在方法内改变参数的值，会影响到调用方。</p>
<p>但是，其实这是走进了一个误区。</p>
<h3 id="Java中的对象传递"><a href="#Java中的对象传递" class="headerlink" title="Java中的对象传递"></a>Java中的对象传递</h3><p>很多人通过代码示例的现象说明Java对象是引用传递，那么我们就从现象入手，先来反驳下这个观点。</p>
<p>我们前面说过，无论是值传递，还是引用传递，只不过是求值策略的一种，那求值策略还有很多，比如前面提到的共享对象传递的现象和引用传递也是一样的。那凭什么就说Java中的参数传递就一定是引用传递而不是共享对象传递呢？</p>
<p>那么，Java中的对象传递，到底是哪种形式呢？其实，还真的就是共享对象传递。</p>
<p>其实在 《The Java™ Tutorials》中，是有关于这部分内容的说明的。首先是关于基本类型描述如下：</p>
<blockquote>
<p><strong>Primitive arguments, such as an int or a double, are passed into methods by value. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost.</strong></p>
</blockquote>
<hr>
<p><strong>即，原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。</strong></p>
<hr>
<p>关于对象传递的描述如下：</p>
<blockquote>
<p><strong>Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.</strong></p>
</blockquote>
<hr>
<p><strong>也就是说，引用数据类型参数(如对象)也按值传递给方法。这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适当的访问级别，则可以在方法中更改这些字段的值。</strong></p>
<p>这一点官方文档已经很明确的指出了，Java就是值传递，只不过是把对象的引用当做值传递给方法。你细品，这不就是共享对象传递么？</p>
<p>**其实Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调函数的形式参数。**只不过”传共享对象调用”这个词并不常用，所以Java社区的人通常说”Java是传值调用”，这么说也没错，因为传共享对象调用其实是传值调用的一个特例。</p>
<h3 id="值传递和共享对象传递的现象冲突吗？"><a href="#值传递和共享对象传递的现象冲突吗？" class="headerlink" title="值传递和共享对象传递的现象冲突吗？"></a>值传递和共享对象传递的现象冲突吗？</h3><p>看到这里很多人可能会有一个疑问，既然共享对象传递是值传递的一个特例，那么为什么他们的现象是完全不同的呢？</p>
<p>难道值传递过程中，如果在被调方法中改变了值，也有可能会对调用者有影响吗？那到底什么时候会影响什么时候不会影响呢？</p>
<p>其实是不冲突的，之所以会有这种疑惑，是因为大家对于到底是什么是”改变值”有误解。</p>
<p>我们先回到上面的例子中来，看一下调用过程中实际上发生了什么？</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/o1s6UQIKUR_yhQ0i/1690711567770-03fe147a-9948-4fe2-ad99-299e8a610f70-829745.png" alt="1690711567770-03fe147a-9948-4fe2-ad99-299e8a610f70.png"></p>
<p>在参数传递的过程中，实际参数的地址<code>0X1213456</code>被拷贝给了形参。这个过程其实就是值传递，只不过传递的值得内容是对象的引用。</p>
<p>那为什么我们改了user中的属性的值，却对原来的user产生了影响呢？</p>
<p>其实，这个过程就好像是：你复制了一把你家里的钥匙给到你的朋友，他拿到钥匙以后，并没有在这把钥匙上做任何改动，而是通过钥匙打开了你家里的房门，进到屋里，把你家的电视给砸了。</p>
<p>这个过程，对你手里的钥匙来说，是没有影响的，但是你的钥匙对应的房子里面的内容却是被人改动了。</p>
<p>也就是说，<strong>Java对象的传递，是通过复制的方式把引用关系传递了，如果我们没有改引用关系，而是找到引用的地址，把里面的内容改了，是会对调用方有影响的，因为大家指向的是同一个共享对象。</strong></p>
<p>那么，如果我们改动一下pass方法的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void pass(User user) &#123;</span><br><span class="line">  user = new User();</span><br><span class="line">  user.setName(&quot;hollischuang&quot;);</span><br><span class="line">  user.setGender(&quot;Male&quot;);</span><br><span class="line">  System.out.println(&quot;print in pass , user is &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的代码中，我们在pass方法中，重新new了一个user对象，并改变了他的值，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=&#x27;hollischuang&#x27;, gender=&#x27;Male&#x27;&#125;</span><br><span class="line">print in main , user is User&#123;name=&#x27;Hollis&#x27;, gender=&#x27;Male&#x27;&#125;</span><br></pre></td></tr></table></figure>



<p>再看一下整个过程中发生了什么：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/o1s6UQIKUR_yhQ0i/1690711567783-5ce8c5bb-52aa-4774-836f-ac51db0cb68a-355086.png" alt="1690711567783-5ce8c5bb-52aa-4774-836f-ac51db0cb68a.png"></p>
<p>这个过程，就好像你复制了一把钥匙给到你的朋友，你的朋友拿到你给他的钥匙之后，找个锁匠把他修改了一下，他手里的那把钥匙变成了开他家锁的钥匙。这时候，他打开自己家，就算是把房子点了，对你手里的钥匙，和你家的房子来说都是没有任何影响的。</p>
<hr>
<p><strong>所以，Java中的对象传递，如果是修改引用，是不会对原来的对象有任何影响的，但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。</strong></p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们知道，编程语言中需要进行方法间的参数传递，这个传递的策略叫做求值策略。</p>
<p>在程序设计中，求值策略有很多种，比较常见的就是值传递和引用传递。还有一种值传递的特例——共享对象传递。</p>
<p>值传递和引用传递最大的区别是传递的过程中有没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。</p>
<p>在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用。</p>
<p><strong>我们可以总结说，Java中的求值策略是共享对象传递，这是完全正确的。</strong></p>
<p>但是，为了让大家都能理解你说的，<strong>我们说Java中只有值传递，只不过传递的内容是对象的引用。这也是没毛病的。</strong></p>
<p>但是，绝对不能认为Java中有引用传递。</p>
<p>OK，以上就是本文的全部内容，不知道本文是否帮助你解开了你心中一直以来的疑惑。欢迎留言说一下你的想法。</p>
<h1 id="✅Java序列化的原理是啥"><a href="#✅Java序列化的原理是啥" class="headerlink" title="✅Java序列化的原理是啥"></a>✅Java序列化的原理是啥</h1><h2 id="典型回答-10"><a href="#典型回答-10" class="headerlink" title="典型回答"></a>典型回答</h2><p>序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。  几乎所有的商用编程语言都有序列化的能力，不管是数据存储到硬盘，还是通过网络的微服务传输，都需要序列化能力。</p>
<p>在Java的序列化机制中，如果是String，枚举或者实现了Serializable接口的类，均可以通过Java的序列化机制，将类序列化为符合编码的数据流，然后通过InputStream和OutputStream将内存中的类持久化到硬盘或者网络中；同时，也可以通过反序列化机制将磁盘中的字节码再转换成内存中的类。</p>
<p>**如果一个类想被序列化，需要实现Serializable接口。**否则将抛出NotSerializableException异常。Serializable接口没有方法或字段，仅用于标识可序列化的语义。</p>
<p>自定义类通过实现Serializable接口做标识，进而在IO中实现序列化和反序列化，具体的执行路径如下：</p>
<p><code>#writeObject -&gt; #writeObject0(判断类是否是自定义类) -&gt; #writeOrdinaryObject(区分Serializable和Externalizable) -&gt; writeSerialData(序列化fields) -&gt; invokeWriteObject(反射调用类自己的序列化策略)</code></p>
<p>其中，在invokeWriteObject的阶段，系统就会处理自定义类的序列化方案。</p>
<p>这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p>
<h1 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h1><h2 id="Serializable-和-Externalizable-接口有何不同？"><a href="#Serializable-和-Externalizable-接口有何不同？" class="headerlink" title="Serializable 和 Externalizable 接口有何不同？"></a>Serializable 和 Externalizable 接口有何不同？</h2><p>类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p>
<p>当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。</p>
<p>如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该实现java.io.Serializable接口。<br>Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。如果没有在这两个方法中定义序列化实现细节，那么序列化之后，对象内容为空。实现Externalizable接口的类必须要提供一个public的无参的构造器。</p>
<p>所以，实现Externalizable，并实现writeExternal()和readExternal()方法可以指定序列化哪些属性。</p>
<h2 id="在Java中，有哪些好的序列化框架，有什么好处"><a href="#在Java中，有哪些好的序列化框架，有什么好处" class="headerlink" title="在Java中，有哪些好的序列化框架，有什么好处"></a>在Java中，有哪些好的序列化框架，有什么好处</h2><p>Java中常用的序列化框架：</p>
<p>java、kryo、hessian、protostuff、gson、fastjson等。</p>
<p>Kryo：速度快，序列化后体积小；跨语言支持较复杂</p>
<p>Hessian：默认支持跨语言；效率不高</p>
<p>Protostuff：速度快，基于protobuf；需静态编译</p>
<p>Protostuff-Runtime：无需静态编译，但序列化前需预先传入schema；不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</p>
<p>Java：使用方便，可序列化所有类；速度慢，占空间  </p>
<h1 id="✅Java中Timer实现定时调度的原理是什么？"><a href="#✅Java中Timer实现定时调度的原理是什么？" class="headerlink" title="✅Java中Timer实现定时调度的原理是什么？"></a>✅Java中Timer实现定时调度的原理是什么？</h1><h2 id="典型回答-11"><a href="#典型回答-11" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java中的Timer类是一个定时调度器，用于在指定的时间点执行任务。JDK 中Timer类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The timer task queue.  This data structure is shared with the timer</span></span><br><span class="line"><span class="comment">     * thread.  The timer produces tasks, via its various schedule calls,</span></span><br><span class="line"><span class="comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span></span><br><span class="line"><span class="comment">     * and removing them from the queue when they&#x27;re obsolete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The timer thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上就是Timer中最重要的两个成员变量：</p>
<ol>
<li>TaskQueue：一个任务队列，用于存储已计划的定时任务。任务队列按照任务的执行时间进行排序，确保最早执行的任务排在队列前面。在队列中的任务可能是一次性的，也可能是周期性的。</li>
<li>TimerThread：Timer 内部的后台线程，它负责扫描 TaskQueue 中的任务，检查任务的执行时间，然后在执行时间到达时执行任务的 run() 方法。TimerThread 是一个守护线程，因此当所有非守护线程完成时，它会随之终止。</li>
</ol>
<p>任务的定时调度的核心代码就在TimerThread中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newTasksMayBeScheduled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储 TimerTask 的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TaskQueue queue;</span><br><span class="line"></span><br><span class="line">    TimerThread(TaskQueue queue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainLoop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">                queue.clear(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要的计时器循环。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mainLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                <span class="type">boolean</span> taskFired;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="comment">// 等待队列变为非空</span></span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 队列为空，将永远保持为空；线程终止</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 队列非空；查看第一个事件并执行相应操作</span></span><br><span class="line">                    <span class="type">long</span> currentTime, executionTime;</span><br><span class="line">                    task = queue.getMin();</span><br><span class="line">                    <span class="keyword">synchronized</span> (task.lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="keyword">continue</span>;  <span class="comment">// 无需执行任何操作，再次轮询队列</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        executionTime = task.nextExecutionTime;</span><br><span class="line">                        <span class="keyword">if</span> (taskFired = (executionTime &lt;= currentTime)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// 非重复，移除</span></span><br><span class="line">                                queue.removeMin();</span><br><span class="line">                                task.state = TimerTask.EXECUTED;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 重复任务，重新安排</span></span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period &lt; <span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                                : executionTime + task.period);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// 任务尚未触发；等待</span></span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// 任务触发；运行它，不持有锁</span></span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到，TimerThread的实际是在运行mainLoop方法，这个方法一进来就是一个while(true)的循环，他在循环中不断地从TaskQueue中取出第一个任务，然后判断他是否到达执行时间了，如果到了，就触发任务执行。否则就继续等一会再次执行。</p>
<p>不断地重复这个动作，从队列中取出第一个任务进行判断，执行。。。</p>
<p>这样只要有新的任务加入队列，就在队列中按照时间排序，然后唤醒timerThread重新检查队列进行执行就可以了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sched</span><span class="params">(TimerTask task, <span class="type">long</span> time, <span class="type">long</span> period)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal execution time.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></span><br><span class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Timer already cancelled.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Task already scheduled or cancelled&quot;</span>);</span><br><span class="line">            task.nextExecutionTime = time;</span><br><span class="line">            task.period = period;</span><br><span class="line">            task.state = TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//新任务入队列</span></span><br><span class="line">        queue.add(task);</span><br><span class="line">        <span class="comment">//唤醒任务</span></span><br><span class="line">        <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="扩展知识-2"><a href="#扩展知识-2" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>Timer 类用于实现定时任务，最大的好处就是他的实现非常简单，特别的轻量级，因为它是Java内置的，所以只需要简单调用就行了。</p>
<p>但是他并不是特别的解决定时任务的好的方案，因为他存在以下问题：</p>
<p>1、Timer内部是单线程执行任务的，如果某个任务执行时间较长，会影响后续任务的执行。</p>
<p>2、如果任务抛出未捕获异常，将导致整个 Timer 线程终止，影响其他任务的执行。</p>
<p>3、Timer 无法提供高精度的定时任务。因为系统调度和任务执行时间的不确定性，可能导致任务执行的时间不准确。</p>
<p>4、虽然可以使用 cancel 方法取消任务，但这仅仅是将任务标记为取消状态，仍然会在任务队列中占用位置，无法释放资源。这可能导致内存泄漏。</p>
<p>5、当有大量任务时，Timer 的性能可能受到影响，因为它在每次扫描任务队列时都要进行时间比较。</p>
<p>6、Timer执行任务完全基于JVM内存，一旦应用重启，那么队列中的任务就都没有了</p>
<h1 id="✅Java中创建对象有哪些种方式"><a href="#✅Java中创建对象有哪些种方式" class="headerlink" title="✅Java中创建对象有哪些种方式"></a>✅Java中创建对象有哪些种方式</h1><h2 id="典型回答-12"><a href="#典型回答-12" class="headerlink" title="典型回答"></a>典型回答</h2><h3 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h3><p>这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造函数（无参的和有参的）。 </p>
<p><code>User user = new User();</code></p>
<h3 id="使用反射机制"><a href="#使用反射机制" class="headerlink" title="使用反射机制"></a>使用反射机制</h3><p>运用反射手段，调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</p>
<p>1 使用Class类的newInstance方法</p>
<p>可以使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)Class.forName(&quot;xxx.xxx.User&quot;).newInstance(); </span><br><span class="line">User user = User.class.newInstance();</span><br></pre></td></tr></table></figure>



<p>2 使用Constructor类的newInstance方法</p>
<p>和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor  constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br></pre></td></tr></table></figure>



<p>这两种newInstance方法就是大家所说的反射。事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
<h3 id="使用clone方法"><a href="#使用clone方法" class="headerlink" title="使用clone方法"></a>使用clone方法</h3><p>无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。 </p>
<p>要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。如果只实现了Cloneable接口，并没有重写clone方法的话，会默认使用Object类中的clone方法，这是一个native的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneTest</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CloneTest</span> <span class="variable">cloneTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneTest</span>(<span class="string">&quot;wangql&quot;</span>,<span class="number">18</span>);</span><br><span class="line">            <span class="type">CloneTest</span> <span class="variable">copyClone</span> <span class="operator">=</span> (CloneTest) cloneTest.clone();</span><br><span class="line">            System.out.println(<span class="string">&quot;newclone:&quot;</span>+cloneTest.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;copyClone:&quot;</span>+copyClone.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h3><p>当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。其实反序列化也是基于反射实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//Initializes The Object</span></span><br><span class="line">    <span class="type">User1</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">23</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write Obj to File</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IOUtils.closeQuietly(oos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Read Obj from File</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        <span class="type">User1</span> <span class="variable">newUser</span> <span class="operator">=</span> (User1) ois.readObject();</span><br><span class="line">        System.out.println(newUser);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IOUtils.closeQuietly(ois);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.forceDelete(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用方法句柄"><a href="#使用方法句柄" class="headerlink" title="使用方法句柄"></a>使用方法句柄</h3><p>通过使用方法句柄，可以间接地调用构造函数来创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 定义构造函数的方法句柄类型为void类型，无参数</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">constructorType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造函数的方法句柄</span></span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">constructorHandle</span> <span class="operator">=</span> lookup.findConstructor(User.class, constructorType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用方法句柄调用构造函数创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">obj</span> <span class="operator">=</span> (User) constructorHandle.invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用了MethodHandles.lookup().findConstructor()方法获取构造函数的方法句柄，然后通过invoke()方法调用构造函数来创建对象。</p>
<h3 id="使用Unsafe分配内存"><a href="#使用Unsafe分配内存" class="headerlink" title="使用Unsafe分配内存"></a>使用Unsafe分配内存</h3><p>在Java中，可以使用sun.misc.Unsafe类来进行直接的内存操作，包括内存分配和对象实例化。然而，需要注意的是，sun.misc.Unsafe类是Java的内部API，它并不属于Java标准库的一部分，也不建议直接在生产环境中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> field.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取User类的字段偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    <span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用allocateInstance方法创建对象，不会调用构造函数</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) unsafe.allocateInstance(User.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用putObject方法设置字段的值</span></span><br><span class="line">    unsafe.putObject(user, nameOffset, <span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    unsafe.putInt(user, ageOffset, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这种方式有以下几个缺点：</p>
<ol>
<li>不可移植性：Unsafe类的行为在不同的Java版本和不同的JVM实现中可能会有差异，因此代码在不同的环境下可能会出现不可移植的问题。</li>
<li>安全性问题：Unsafe类的功能是非常强大和危险的，可以绕过Java的安全机制，可能会导致内存泄漏、非法访问、数据损坏等安全问题。</li>
<li>不符合面向对象的原则：Java是一门面向对象的语言，鼓励使用构造函数和工厂方法来创建对象，以确保对象的正确初始化和维护对象的不变性。</li>
</ol>
<h1 id="✅Java中的static都能用来修饰什么？"><a href="#✅Java中的static都能用来修饰什么？" class="headerlink" title="✅Java中的static都能用来修饰什么？"></a>✅Java中的static都能用来修饰什么？</h1><h2 id="典型回答-13"><a href="#典型回答-13" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java编程语言中，<code>static</code>关键字是非常重要的修饰符，可以用于多种不同的地方。可用来修饰变量、方法、代码块以及类。</p>
<ol>
<li>** 静态变量**： <ul>
<li>定义：静态变量属于类本身，而不是类的任何特定实例（new出来的对象）。</li>
<li>特点： <ul>
<li>所有实例共享同一静态变量。</li>
<li>在类加载到内存时就被初始化，而不是在创建对象的时候。</li>
<li>常用于管理类的全局状态或作为常量仓库（例如<code>public static final</code>修饰的常量）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    // 静态变量</span><br><span class="line">    public static int count = 0;</span><br><span class="line">    public static final String ERROR_CODE = &quot;SYSTEM_ERROR&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>静态方法</strong>： <ul>
<li>定义：静态方法同样属于类，而非类的实例。</li>
<li>特点： <ul>
<li>可以在不创建类的实例的情况下调用。</li>
<li>不能访问类的实例变量或实例方法，它们只能访问其他的静态成员。</li>
<li>常用于工具类的方法，例如<code>Math.sqrt()</code>或<code>Collections.sort()</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathUtils &#123;</span><br><span class="line">    // 静态方法</span><br><span class="line">    public static double square(double number) &#123;</span><br><span class="line">        return number * number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double result = MathUtils.square(3.0);</span><br><span class="line">        System.out.println(result); // 输出9.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>** 静态代码块**： <ul>
<li>定义：用于初始化类的静态变量。</li>
<li>特点： <ul>
<li>当类被Java虚拟机加载并初始化时执行。</li>
<li>通常用于执行静态变量的复杂初始化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseConfig &#123;</span><br><span class="line">    public static int timeout;</span><br><span class="line">    public static String url;</span><br><span class="line"></span><br><span class="line">    // 静态代码块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Initializing database settings&quot;);</span><br><span class="line">        timeout = 30; // 以秒为单位</span><br><span class="line">        url = &quot;jdbc:mysql://localhost:3306/myDatabase&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Database URL: &quot; + DatabaseConfig.url); // 输出初始化的URL</span><br><span class="line">        System.out.println(&quot;Timeout: &quot; + DatabaseConfig.timeout); // 输出初始化的超时时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="4">
<li><strong>静态内部类</strong>： <ul>
<li>定义：在一个类的内部定义的静态类。</li>
<li>特点： <ul>
<li>可以不依赖于外部类的实例而独立存在。</li>
<li>可以访问外部类的所有静态成员，但不能直接访问外部类的实例成员。</li>
<li>常用于当内部类的行为不应依赖于外部类的实例时。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticNestedClass &#123;</span><br><span class="line">        private int value;</span><br><span class="line"></span><br><span class="line">        public StaticNestedClass(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void display() &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(5);</span><br><span class="line">        nestedObject.display(); // 输出值5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用<code>static</code>修饰符的好处包括减少内存使用（共享静态变量而不是为每个实例创建副本）、提供一个全局访问点（例如静态方法和变量）以及无需实例化类即可使用其中的方法和变量。</p>
<h1 id="✅Java中的枚举有什么特点和好处"><a href="#✅Java中的枚举有什么特点和好处" class="headerlink" title="✅Java中的枚举有什么特点和好处"></a>✅Java中的枚举有什么特点和好处</h1><p>枚举类型是指由一组固定的常量组成合法的类型。Java中由关键字enum来定义一个枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java中枚举的好处如下：</p>
<h3 id="1、枚举的valueOf可以自动对入参进行非法参数的校验"><a href="#1、枚举的valueOf可以自动对入参进行非法参数的校验" class="headerlink" title="1、枚举的valueOf可以自动对入参进行非法参数的校验"></a>1、枚举的<code>valueOf</code>可以自动对入参进行非法参数的校验</h3><hr>
<p>Java 枚举提供了 <code>valueOf</code> 方法，它可以根据字符串值返回相应的枚举常量。如果传入的字符串不匹配任何枚举常量，<code>valueOf</code> 会抛出 <code>IllegalArgumentException</code> 异常，从而自动进行非法参数的校验。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class EnumExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Season ss = Season.valueOf(&quot;SPRING&quot;); // 合法参数</span><br><span class="line">            System.out.println(ss); // 输出 SPRING</span><br><span class="line"></span><br><span class="line">            Season invalidSeason = Season.valueOf(&quot;HOLLIS&quot;); // 非法参数，会抛出异常</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(&quot;Invalid Season: &quot; + e.getMessage()); // 输出 Invalid Season: HOLLIS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、可以调用枚举中的方法，相对于普通的常量来说操作性更强"><a href="#2、可以调用枚举中的方法，相对于普通的常量来说操作性更强" class="headerlink" title="2、可以调用枚举中的方法，相对于普通的常量来说操作性更强"></a>2、可以调用枚举中的方法，相对于普通的常量来说操作性更强</h3><p>枚举可以定义方法，这使得每个枚举常量都可以具备独特的行为。与普通常量相比，枚举更具操作性和灵活性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation &#123;</span><br><span class="line">    ADD &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUBTRACT &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MULTIPLY &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EnumExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double x = 10;</span><br><span class="line">        double y = 5;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Addition: &quot; + Operation.ADD.apply(x, y)); // 输出 Addition: 15.0</span><br><span class="line">        System.out.println(&quot;Subtraction: &quot; + Operation.SUBTRACT.apply(x, y)); // 输出 Subtraction: 5.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、枚举实现接口的话，可以很容易的实现策略模式"><a href="#3、枚举实现接口的话，可以很容易的实现策略模式" class="headerlink" title="3、枚举实现接口的话，可以很容易的实现策略模式"></a>3、枚举实现接口的话，可以很容易的实现策略模式</h3><h3 id="4、枚举可以自带属性，扩展性更强"><a href="#4、枚举可以自带属性，扩展性更强" class="headerlink" title="4、枚举可以自带属性，扩展性更强"></a>4、枚举可以自带属性，扩展性更强</h3><p>枚举可以包含字段、构造函数和方法，使得每个枚举常量可以具有不同的属性和行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public enum Color &#123;</span><br><span class="line">    RED(&quot;#FF0000&quot;),</span><br><span class="line">    GREEN(&quot;#00FF00&quot;),</span><br><span class="line">    BLUE(&quot;#0000FF&quot;);</span><br><span class="line"></span><br><span class="line">    private final String hexCode;</span><br><span class="line"></span><br><span class="line">    Color(String hexCode) &#123;</span><br><span class="line">        this.hexCode = hexCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHexCode() &#123;</span><br><span class="line">        return hexCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name() + &quot; (&quot; + hexCode + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EnumExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color color : Color.values()) &#123;</span><br><span class="line">            System.out.println(color); // 输出 RED (#FF0000), GREEN (#00FF00), BLUE (#0000FF)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5、天生就是个单例，线程安全且不怕被破坏"><a href="#5、天生就是个单例，线程安全且不怕被破坏" class="headerlink" title="5、天生就是个单例，线程安全且不怕被破坏"></a>5、天生就是个单例，线程安全且不怕被破坏</h3><h2 id="扩展知识-3"><a href="#扩展知识-3" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="枚举如何实现的？"><a href="#枚举如何实现的？" class="headerlink" title="枚举如何实现的？"></a>枚举如何实现的？</h2><p>如果我们使用反编译，对一个枚举进行反编译的话，就能大致了解他的实现方式，如上面的Season枚举，反编译后内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">T</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> <span class="title class_">T</span>[i = at.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">valueOf</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T AUTUMN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T WINTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        AUTUMN = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;AUTUMN&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        WINTER = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;WINTER&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> <span class="title class_">T</span>[] &#123;</span><br><span class="line">            SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过反编译后代码我们可以看到，<strong>public final class T extends Enum，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。</strong></p>
<h2 id="枚举如何比较"><a href="#枚举如何比较" class="headerlink" title="枚举如何比较"></a>枚举如何比较</h2><p>枚举的equals方法底层用的还是&#x3D;&#x3D;，所以两者都可以</p>
<h1 id="✅Java中异常分哪两类，有什么区别？"><a href="#✅Java中异常分哪两类，有什么区别？" class="headerlink" title="✅Java中异常分哪两类，有什么区别？"></a>✅Java中异常分哪两类，有什么区别？</h1><h2 id="典型回答-14"><a href="#典型回答-14" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java中的异常，主要可以分为两大类，即受检异常（checked exception）和 非受检异常（unchecked exception）</p>
<p>对于<strong>受检异常</strong>来说，如果一个方法在声明的过程中证明了其要有受检异常抛出：</p>
<p><code>public void test() throws Exception&#123;&#125;</code></p>
<p>那么，当我们在程序中调用他的时候，一定要对该异常进行处理（捕获或者向上抛出），否则是无法编译通过的。这是一种强制规范。</p>
<p>这种异常在IO操作中比较多。比如FileNotFoundException ，当我们使用IO流处理一个文件的时候，有一种特殊情况，就是文件不存在，所以，在文件处理的接口定义时他会显示抛出FileNotFoundException，起目的就是告诉这个方法的调用者，我这个方法不保证一定可以成功，是有可能找不到对应的文件的，你要明确的对这种情况做特殊处理哦。</p>
<p>所以说，当我们希望我们的方法调用者，明确的处理一些特殊情况的时候，就应该使用受检异常。</p>
<p>对于<strong>非受检异常</strong>来说，一般是运行时异常，继承自RuntimeException。在编写代码的时候，不需要显式的捕获，但是如果不捕获，在运行期如果发生异常就会中断程序的执行。</p>
<p>这种异常一般可以理解为是代码原因导致的。比如发生空指针、数组越界等。所以，只要代码写的没问题，这些异常都是可以避免的。也就不需要我们显示的进行处理。</p>
<p>试想一下，如果你要对所有可能发生空指针的地方做异常处理的话，那相当于你的所有代码都需要做这件事。</p>
<h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><h2 id="什么是Throwable"><a href="#什么是Throwable" class="headerlink" title="什么是Throwable"></a><strong>什么是</strong>Throwable</h2><p>Throwable是java中最顶级的异常类，继承Object，实现了序列化接口，有两个重要的子类：Exception和 Error，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<h2 id="Error和Exception的区别和联系"><a href="#Error和Exception的区别和联系" class="headerlink" title="Error和Exception的区别和联系"></a>Error和Exception的区别和联系</h2><p>error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。如OutOfMemoryError、StackOverflowError</p>
<h1 id="✅Java中有了基本类型为什么还需要包装类？"><a href="#✅Java中有了基本类型为什么还需要包装类？" class="headerlink" title="✅Java中有了基本类型为什么还需要包装类？"></a>✅Java中有了基本类型为什么还需要包装类？</h1><h2 id="典型回答-15"><a href="#典型回答-15" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java中有8种基本数据类型，这些基本类型又都有对应的包装类。  </p>
<table>
<thead>
<tr>
<th>分类</th>
<th>基本数据类型</th>
<th>包装类</th>
<th>长度</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>布尔型</td>
<td>boolean</td>
<td>Boolean</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>整型</td>
<td>byte</td>
<td>Byte</td>
<td>1字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>Short</td>
<td>2字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>Integer</td>
<td>4字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>Long</td>
<td>8字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>Character</td>
<td>2字节</td>
<td>Unicode字符集中的任何字符</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
<td>Float</td>
<td>4字节</td>
<td>约 -3.4E38 到 3.4E38</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>Double</td>
<td>8字节</td>
<td>约 -1.7E308 到 1.7E308</td>
</tr>
</tbody></table>
<p><strong>因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型</strong>。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。  </p>
<h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ol>
<li>默认值不同，基本类型的默认值为0, false或\u0000等，包装类默认为null</li>
<li>初始化方式不同，一个需要new，一个不需要</li>
<li>存储方式不同，基本类型保存在栈上，包装类对象保存在堆上（成员变量的话，在不考虑JIT优化的栈上分配时，都是随着对象一起保存在堆上的）</li>
</ol>
<h2 id="接口定义中应该用什么？"><a href="#接口定义中应该用什么？" class="headerlink" title="接口定义中应该用什么？"></a>接口定义中应该用什么？</h2><h2 id="如何理解自动拆装箱"><a href="#如何理解自动拆装箱" class="headerlink" title="如何理解自动拆装箱"></a>如何理解自动拆装箱</h2><h3 id="拆箱与装箱"><a href="#拆箱与装箱" class="headerlink" title="拆箱与装箱"></a>拆箱与装箱</h3><p>“&gt;包装类是对基本类型的包装，所以，把基本数据类型转换成包装类的过程就是**”&gt;装箱**”&gt;；反之，把包装类转换成基本数据类型的过程就是**”&gt;拆箱**”&gt;。</p>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>“&gt;在Java SE5中，为了减少开发人员的工作，Java提供了自动拆箱与自动装箱功能。</p>
<p>“&gt;</p>
<p>“&gt;自动装箱: 就是将基本数据类型自动转换成对应的包装类。</p>
<p>“&gt;</p>
<p>“&gt;自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">10</span>;  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> b= i;     <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<h3 id="自动拆装箱原理"><a href="#自动拆装箱原理" class="headerlink" title="自动拆装箱原理"></a>自动拆装箱原理</h3><p>自动装箱都是通过包装类的<code>valueOf()</code>方法来实现的.自动拆箱都是通过包装类对象的<code>xxxValue()</code>来实现的。</p>
<p>如：int的自动装箱都是通过<code>Integer.valueOf()</code>方法来实现的，Integer的自动拆箱都是通过<code>Integer.intValue()</code>来实现的。</p>
<h2 id="哪些地方会自动拆装箱"><a href="#哪些地方会自动拆装箱" class="headerlink" title="哪些地方会自动拆装箱"></a>哪些地方会自动拆装箱</h2><p>我们了解过原理之后，再来看一下，什么情况下，Java会帮我们进行自动拆装箱。前面提到的变量的初始化和赋值的场景就不介绍了，那是最简单的也最容易理解的。</p>
<p>我们主要来看一下，那些可能被忽略的场景。</p>
<h3 id="场景一、将基本数据类型放入集合类"><a href="#场景一、将基本数据类型放入集合类" class="headerlink" title="场景一、将基本数据类型放入集合类"></a>场景一、将基本数据类型放入集合类</h3><p>我们知道，Java中的集合类只能接收对象类型，那么以下代码为什么会不报错呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">50</span>; i ++)&#123;</span><br><span class="line">    li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将上面代码进行反编译，可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">50</span>; i ++)&#123;</span><br><span class="line">    li.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上，我们可以得出结论，当我们把基本数据类型放入集合类中的时候，会进行自动装箱。</p>
<h3 id="场景二、包装类型和基本类型的大小比较"><a href="#场景二、包装类型和基本类型的大小比较" class="headerlink" title="场景二、包装类型和基本类型的大小比较"></a>场景二、包装类型和基本类型的大小比较</h3><p>有没有人想过，当我们对Integer对象与基本类型进行大小比较的时候，实际上比较的是什么内容呢？看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line">Boolean bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>对以上代码进行反编译，得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a.intValue()==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line">Boolean bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool.booleanValue?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>可以看到，包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。</p>
<h3 id="场景三、包装类型的运算"><a href="#场景三、包装类型的运算" class="headerlink" title="场景三、包装类型的运算"></a>场景三、包装类型的运算</h3><p>有没有人想过，当我们对Integer对象进行四则运算的时候，是如何进行的呢？看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">System.out.println(i.intValue() + j.intValue());</span><br></pre></td></tr></table></figure>



<p>我们发现，两个包装类型之间的运算，会被自动拆箱成基本类型进行。</p>
<h3 id="场景四、三目运算符的使用"><a href="#场景四、三目运算符的使用" class="headerlink" title="场景四、三目运算符的使用"></a>场景四、三目运算符的使用</h3><p>这是很多人不知道的一个场景，作者也是一次线上的血淋淋的Bug发生后才了解到的一种案例。看一个简单的三目运算符的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//设置成true，保证条件表达式的表达式二一定可以执行</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">simpleBoolean</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//定义一个基本数据类型的boolean变量</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">nullBoolean</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义一个包装类对象类型的Boolean变量，值为null</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> flag ? nullBoolean : simpleBoolean; <span class="comment">//使用三目运算符并给x变量赋值</span></span><br></pre></td></tr></table></figure>



<p>很多人不知道，其实在<code>int k = flag ? i : j;</code>这一行，会发生自动拆箱。反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">simpleBoolean</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">nullBoolean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> flag ? nullBoolean.booleanValue() : simpleBoolean;</span><br></pre></td></tr></table></figure>



<p>这其实是三目运算符的语法规范。当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。</p>
<p>可以看到，反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象（nullBoolean.booleanValue()）的调用，导致了NPE。</p>
<h3 id="场景五、函数参数与返回值"><a href="#场景五、函数参数与返回值" class="headerlink" title="场景五、函数参数与返回值"></a>场景五、函数参数与返回值</h3><p>这个比较容易理解，直接上代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum1</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getNum2</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h2><p>Java SE的自动拆装箱还提供了一个和缓存有关的功能，我们先来看以下代码，猜测一下输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... strings)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">        System.out.println(<span class="string">&quot;integer1 == integer2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;integer1 != integer2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer4</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">        System.out.println(<span class="string">&quot;integer3 == integer4&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;integer3 != integer4&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们普遍认为上面的两个判断的结果都是false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个if判断都是false的。在Java中，&#x3D;&#x3D;比较的是对象引用，而equals比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>上面这段代码真正的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer1 == integer2</span><br><span class="line">integer3 != integer4</span><br></pre></td></tr></table></figure>



<p>原因就和Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<p>我们只需要知道，当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。</p>
<p>其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过<code>-XX:AutoBoxCacheMax=size</code>修改。</p>
<p>实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过<code>java.lang.Integer.IntegerCache.high</code>设置最大值。</p>
<p>这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？因为这个范围的数字是最被广泛使用的。 在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p>
<p>在Boxing Conversion部分的Java语言规范(JLS)规定如下：</p>
<p>如果一个变量p的值是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">128</span>至<span class="number">127</span>之间的整数(§<span class="number">3.10</span><span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> 和 <span class="literal">false</span>的布尔值 (§<span class="number">3.10</span><span class="number">.3</span>)</span><br><span class="line"></span><br><span class="line">‘\u0000’至 ‘\u007f’之间的字符(§<span class="number">3.10</span><span class="number">.4</span>)</span><br></pre></td></tr></table></figure>



<p>范围内的时，将p包装成a和b两个对象时，可以直接使用a&#x3D;&#x3D;b判断a和b的值是否相等。</p>
<h1 id="✅Java注解的作用是啥"><a href="#✅Java注解的作用是啥" class="headerlink" title="✅Java注解的作用是啥"></a>✅Java注解的作用是啥</h1><h2 id="典型回答-16"><a href="#典型回答-16" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。</p>
<p>Java的注解，可以说是一种标识，标识一个类或者一个字段，常常是和反射，AOP结合起来使用。中间件一般会定义注解，如果某些类或字段符合条件，就执行某些能力。</p>
<h2 id="扩展知识-4"><a href="#扩展知识-4" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="什么是元注解"><a href="#什么是元注解" class="headerlink" title="什么是元注解"></a>什么是元注解</h2><p>说简单点，就是 定义其他注解的注解 。</p>
<p>比如Override这个注解，就不是一个元注解。而是通过元注解定义出来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的@Target，@Retention就是元注解。</p>
<p>元注解有四个:@Target（表示该注解可以用于什么地方）、@Retention（表示在什么级别保存该注解信息）、@Documented（将此注解包含在javadoc中）、@Inherited（允许子类继承父类中的注解）。</p>
<p>一般@Target是被用的最多的。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>指定被修饰的注解的生命周期，即注解在源代码、编译时还是运行时保留。它有三个可选的枚举值：SOURCE、CLASS和RUNTIME。默认为CLASS。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyRuntimeAnnotation &#123;</span><br><span class="line">    // some elements and values</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>指定被修饰的注解可以应用于的元素类型，如类、方法、字段等。这样可以限制注解的使用范围，避免错误使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">public @interface MyTargetAnnotation &#123;</span><br><span class="line">    // some elements and values</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>用于指示注解是否会出现在生成的Java文档中。如果一个注解被@Documented元注解修饰，则该注解的信息会出现在API文档中，方便开发者查阅。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Documented;</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">public @interface MyDocumentedAnnotation &#123;</span><br><span class="line">    // some elements and values</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>指示被该注解修饰的注解是否可以被继承。默认情况下，注解不会被继承，即子类不会继承父类的注解。但如果将一个注解用@Inherited修饰，那么它就可以被子类继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line">@Inherited</span><br><span class="line">public @interface MyInheritedAnnotation &#123;</span><br><span class="line">    // some elements and values</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="✅JDK-9中对字符串的拼接做了什么优化？"><a href="#✅JDK-9中对字符串的拼接做了什么优化？" class="headerlink" title="✅JDK 9中对字符串的拼接做了什么优化？"></a>✅JDK 9中对字符串的拼接做了什么优化？</h1><h2 id="典型回答-17"><a href="#典型回答-17" class="headerlink" title="典型回答"></a>典型回答</h2><p>在JDK 9之前，字符串拼接通常使用<code>+</code>进行（也有其他的，我们不做展开了），<code>+</code>的实现其实是基于<code>StringBuilder</code>的。具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/xkm7k3/pg23qhb7rgnuamd1#rBBk1">✅String、StringBuilder和StringBuffer的区别？</a></p>
<p>这个过程其实是比较低效的，因为整个过程包含了创建<code>StringBuilder</code>对象，通过调用<code>append</code>方法拼接字符串，最后通过<code>toString</code>方法转换成最终的字符串等多个操作。所以才有个规范说不要在 for 循环中用+来拼接字符串的。</p>
<p>但是，这个其实在 JDK 9中已经被修改了。JDK 9引入了<code>StringConcatFactory</code>。这玩意被推出的的主要目标是提供一种灵活且高效的方式来拼接字符串，代替之前的 <code>StringBuilder</code> 或 <code>StringBuffer</code> 的静态编译方法。</p>
<p><code>StringConcatFactory</code>是基于<code>invokedynamic</code>指令实现的。</p>
<blockquote>
<p>是 Java 7 中引入的一种动态类型指令，允许 JVM 在运行时动态解析和调用方法。</p>
</blockquote>
<p>也就说，利用<code>invokedynamic</code>的特性，将字符串拼接的操作<strong>延迟到运行时</strong>，而不是在编译时固定使用<code>StringBuilder</code>。（前面的链接中我们做过反编译，可见+转成 StringBuilder是编译的时候就确定了的。）</p>
<p>这就使得，JVM可以在运行时根据实际的场景选择最优的拼接策略，可能是使用<code>StringBuilder</code>、<code>StringBuffer</code>、或者其他更高效的方法。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/zxiaofan/JDK/blob/master/JDK1.9/src/java.base/java/lang/invoke/StringConcatFactory.java#L126">JDK 9</a>中（后续版本会有所变化，1.9 看的比较清楚），支持的拼接策略有以下几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private enum Strategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用 StringBuilder 进行字符串拼接，但不预估所需的存储空间。</span><br><span class="line">     */</span><br><span class="line">    BC_SB,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用 StringBuilder 进行字符串拼接，同时尝试估计所需的存储空间，以优化性能。</span><br><span class="line">     */</span><br><span class="line">    BC_SB_SIZED,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用 StringBuilder 进行字符串拼接，且能够精确计算出所需的存储空间，以实现最高的效率。</span><br><span class="line">     */</span><br><span class="line">    BC_SB_SIZED_EXACT,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 基于 MethodHandle 技术，使用 StringBuilder 进行拼接，并尝试预估所需的存储空间。</span><br><span class="line">     */</span><br><span class="line">    MH_SB_SIZED,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 基于 MethodHandle 技术，使用 StringBuilder 进行拼接，并精确计算所需的存储空间。</span><br><span class="line">     */</span><br><span class="line">    MH_SB_SIZED_EXACT,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过 MethodHandle 技术，直接从输入参数构建一个字节数组，并准确计算出所需的存储空间，以实现高效的字符串拼接。</span><br><span class="line">     */</span><br><span class="line">    MH_INLINE_SIZED_EXACT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>StringBuilder你不陌生，<code>MethodHandle</code> 是啥？他 Java 7 开始引入的特性，它提供了一种灵活且高效的方法来直接操作方法、构造函数和字段的调用。</p>
<p>它与反射相似，但提供了更高的性能和更低的使用限制。<code>MethodHandle</code> 是一种非常底层的机制，允许开发者在运行时动态查找和调用方法，无论方法的访问权限如何。</p>
<p>使用 <code>MethodHandles.lookup()</code> 获取一个 <code>Lookup</code> 实例，然后使用这个实例来查找特定的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.invoke.MethodHandle;</span><br><span class="line">import java.lang.invoke.MethodHandles;</span><br><span class="line">import java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line">public class MethodHandleExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodType methodType = MethodType.methodType(String.class, int.class, int.class);</span><br><span class="line">        MethodHandle mh = lookup.findVirtual(String.class, &quot;substring&quot;, methodType);</span><br><span class="line">        </span><br><span class="line">        String str = &quot;Hello, World!&quot;;</span><br><span class="line">        String result = (String) mh.invokeExact(str, 7, 12);</span><br><span class="line">        System.out.println(result);  // Outputs &quot;World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>invoke</code>, <code>invokeExact</code>, 或者其他形式的 <code>invoke</code> 方法来调用 <code>MethodHandle</code>。</p>
<h1 id="✅JDK新版本中都有哪些新特性？"><a href="#✅JDK新版本中都有哪些新特性？" class="headerlink" title="✅JDK新版本中都有哪些新特性？"></a>✅JDK新版本中都有哪些新特性？</h1><h2 id="典型回答-18"><a href="#典型回答-18" class="headerlink" title="典型回答"></a>典型回答</h2><p>JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等</p>
<p>JDK 9中推出了模块化</p>
<p>JDK 10中推出了本地变量类型推断</p>
<p>JDK 12中增加了switch表达式</p>
<p>JDK 13中增加了text block</p>
<p>JDK 14中增加了Records</p>
<p>JDK 14中增加了instance模式匹配</p>
<p>JDK 15中增加了封闭类</p>
<p>JDK 17中扩展了switch模式匹配</p>
<p>JDK 21中增加了协程</p>
<p>（以上没有把所有版本都列出是因为某些版本的特性并不重要，或者开发者不太需要关注）</p>
<h2 id="扩展知识-5"><a href="#扩展知识-5" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="本地变量类型推断"><a href="#本地变量类型推断" class="headerlink" title="本地变量类型推断"></a>本地变量类型推断</h2><p>在Java 10之前版本中，我们想定义定义局部变量时。我们需要在赋值的左侧提供显式类型，并在赋值的右边提供实现类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject value = new MyObject();</span><br></pre></td></tr></table></figure>



<p>在Java 10中，提供了本地变量类型推断的功能，可以通过var声明变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value = new MyObject();</span><br></pre></td></tr></table></figure>



<p>本地变量类型推断将引入“var”关键字，而不需要显式的规范变量的类型。</p>
<p>其实，所谓的本地变量类型推断，也是Java 10提供给开发者的语法糖。</p>
<p>虽然我们在代码中使用var进行了定义，但是对于虚拟机来说他是不认识这个var的，在java文件编译成class文件的过程中，会进行解糖，使用变量真正的类型来替代var</p>
<h2 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h2><p>在JDK 12中引入了Switch表达式作为预览特性。并在Java 13中修改了这个特性，引入了yield语句，用于返回值。</p>
<p>而在之后的Java 14中，这一功能正式作为标准功能提供出来。</p>
<p>在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">switch (x) &#123;</span><br><span class="line">    case &quot;1&quot;:</span><br><span class="line">        i=1;</span><br><span class="line">        break;</span><br><span class="line">    case &quot;2&quot;:</span><br><span class="line">        i=2;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        i = x.length();</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在JDK13中使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = switch (x) &#123;</span><br><span class="line">    case &quot;1&quot; -&gt; 1;</span><br><span class="line">    case &quot;2&quot; -&gt; 2;</span><br><span class="line">    default -&gt; &#123;</span><br><span class="line">        int len = args[1].length();</span><br><span class="line">        yield len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = switch (x) &#123;</span><br><span class="line">    case &quot;1&quot;: yield 1;</span><br><span class="line">    case &quot;2&quot;: yield 2;</span><br><span class="line">    default: &#123;</span><br><span class="line">        int len = args[1].length();</span><br><span class="line">        yield len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。</p>
<p>和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。</p>
<h2 id="Text-Blocks"><a href="#Text-Blocks" class="headerlink" title="Text Blocks"></a>Text Blocks</h2><p>Java 13中提供了一个Text Blocks的预览特性，并且在Java 14中提供了第二个版本的预览。</p>
<p>text block，文本块，是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。</p>
<p>我们以前从外部copy一段文本串到Java中，会被自动转义，如有一段以下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;p&gt;Hello, world&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>将其复制到Java的字符串中，会展示成以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;html&gt;\n&quot; +</span><br><span class="line">&quot;    &lt;body&gt;\n&quot; +</span><br><span class="line">&quot;        &lt;p&gt;Hello, world&lt;/p&gt;\n&quot; +</span><br><span class="line">&quot;    &lt;/body&gt;\n&quot; +</span><br><span class="line">&quot;&lt;/html&gt;\n&quot;;</span><br></pre></td></tr></table></figure>



<p>即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中，就可以使用以下语法了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;p&gt;Hello, world&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>



<p>使用<code>&quot;&quot;&quot;</code>作为文本块的开始符合结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。</p>
<p>如常见的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String query = &quot;&quot;&quot;</span><br><span class="line">    SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`</span><br><span class="line">    WHERE `CITY` = &#x27;INDIANAPOLIS&#x27;</span><br><span class="line">    ORDER BY `EMP_ID`, `LAST_NAME`;</span><br><span class="line">&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>



<p>看起来就比较直观，清爽了。</p>
<h2 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h2><p>Java 14 中便包含了一个新特性：EP 359: Records，</p>
<p>Records的目标是扩展Java语言语法，Records为声明类提供了一种紧凑的语法，用于创建一种类中是“字段，只是字段，除了字段什么都没有”的类。</p>
<p>通过对类做这样的声明，编译器可以通过自动创建所有方法并让所有字段参与hashCode()等方法。这是JDK 14中的一个预览特性。</p>
<p>使用record关键字可以定义一个记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">record Person (String firstName, String lastName) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>record 解决了使用类作为数据包装器的一个常见问题。纯数据类从几行代码显著地简化为一行代码。（详见：<a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/4548">Java 14 发布了，不使用”class”也能定义类了？还顺手要干掉Lombok！</a>）</p>
<h2 id="封闭类"><a href="#封闭类" class="headerlink" title="封闭类"></a>封闭类</h2><p>在Java 15之前，Java认为”代码重用”始终是一个终极目标，所以，一个类和接口都可以被任意的类实现或继承。</p>
<p>但是，在很多场景中，这样做是容易造成错误的，而且也不符合物理世界的真实规律。</p>
<p>例如，假设一个业务领域只适用于汽车和卡车，而不适用于摩托车。</p>
<p>在Java中创建Vehicle抽象类时，应该只允许Car和Truck类扩展它。</p>
<p>通过这种方式，我们希望确保在域内不会出现误用Vehicle抽象类的情况。</p>
<p>为了解决类似的问题，在Java 15中引入了一个新的特性——密闭。</p>
<p>想要定义一个密闭接口，可以将sealed修饰符应用到接口的声明中。然后，permit子句指定允许实现密闭接口的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public sealed interface Service permits Car, Truck &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码定义了一个密闭接口Service，它规定只能被Car和Truck两个类实现。</p>
<p>与接口类似，我们可以通过使用相同的sealed修饰符来定义密闭类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract sealed class Vehicle permits Car, Truck &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过密闭特性，我们定义出来的Vehicle类只能被Car和Truck继承。</p>
<h2 id="instanceof-模式匹配"><a href="#instanceof-模式匹配" class="headerlink" title="instanceof 模式匹配"></a>instanceof 模式匹配</h2><p>instanceof是Java中的一个关键字，我们在对类型做强制转换之前，会使用instanceof做一次判断，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (animal instanceof Cat) &#123;</span><br><span class="line">    Cat cat = (Cat) animal;</span><br><span class="line">    cat.miaow();</span><br><span class="line">&#125; else if (animal instanceof Dog) &#123;</span><br><span class="line">    Dog dog = (Dog) animal;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java 14带来了改进版的instanceof操作符，这意味着我们可以用更简洁的方式写出之前的代码例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (animal instanceof Cat cat) &#123;</span><br><span class="line">    cat.miaow();</span><br><span class="line">&#125; else if(animal instanceof Dog dog) &#123;</span><br><span class="line">    dog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们都不难发现这种写法大大简化了代码，省略了显式强制类型转换的过程，可读性也大大提高了。</p>
<h2 id="switch-模式匹配"><a href="#switch-模式匹配" class="headerlink" title="switch 模式匹配"></a>switch 模式匹配</h2><p>基于instanceof模式匹配这个特性，我们可以使用如下方式来对对象o进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static String formatter(Object o) &#123;</span><br><span class="line">    String formatted = &quot;unknown&quot;;</span><br><span class="line">    if (o instanceof Integer i) &#123;</span><br><span class="line">        formatted = String.format(&quot;int %d&quot;, i);</span><br><span class="line">    &#125; else if (o instanceof Long l) &#123;</span><br><span class="line">        formatted = String.format(&quot;long %d&quot;, l);</span><br><span class="line">    &#125; else if (o instanceof Double d) &#123;</span><br><span class="line">        formatted = String.format(&quot;double %f&quot;, d);</span><br><span class="line">    &#125; else if (o instanceof String s) &#123;</span><br><span class="line">        formatted = String.format(&quot;String %s&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">    return formatted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，这里使用了很多if-else，其实，Java中给我们提供了一个多路比较的工具，那就是switch，而且从Java 14开始支持switch表达式，但switch的功能一直都是非常有限的。</p>
<p>在Java 17中，Java的工程师们扩展了switch语句和表达式，使其可以适用于任何类型，并允许case标签中不仅带有变量，还能带有模式匹配。我们就可以更清楚、更可靠地重写上述代码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static String formatterPatternSwitch(Object o) &#123;</span><br><span class="line">    return switch (o) &#123;</span><br><span class="line">        case Integer i -&gt; String.format(&quot;int %d&quot;, i);</span><br><span class="line">        case Long l    -&gt; String.format(&quot;long %d&quot;, l);</span><br><span class="line">        case Double d  -&gt; String.format(&quot;double %f&quot;, d);</span><br><span class="line">        case String s  -&gt; String.format(&quot;String %s&quot;, s);</span><br><span class="line">        default        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，以上的switch处理的是一个Object类型，而且case中也不再是精确的值匹配，而是模式匹配了。</p>
<h1 id="✅Lambda表达式是如何实现的？"><a href="#✅Lambda表达式是如何实现的？" class="headerlink" title="✅Lambda表达式是如何实现的？"></a>✅Lambda表达式是如何实现的？</h1><p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</strong></p>
<p>先来看一个简单的lambda表达式。遍历一个list：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String... args) &#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);</span><br><span class="line"></span><br><span class="line">    strList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static /* varargs */ void main(String ... args) &#123;</span><br><span class="line">    ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;);</span><br><span class="line">    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static /* synthetic */ void lambda$main$0(String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第5个参数implMethod指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String... args) &#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);</span><br><span class="line"></span><br><span class="line">    List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Hollis&quot;)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    HollisList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static /* varargs */ void main(String ... args) &#123;</span><br><span class="line">    ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;);</span><br><span class="line">    List&lt;Object&gt; HollisList = strList.stream().filter((Predicate&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());</span><br><span class="line">    HollisList.forEach((Consumer&lt;Object&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static /* synthetic */ void lambda$main$1(Object s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static /* synthetic */ boolean lambda$main$0(String string) &#123;</span><br><span class="line">    return string.contains(&quot;Hollis&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>两个lambda表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>
<p><strong>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</strong></p>
<h1 id="✅RPC接口返回中，使用基本类型还是包装类？"><a href="#✅RPC接口返回中，使用基本类型还是包装类？" class="headerlink" title="✅RPC接口返回中，使用基本类型还是包装类？"></a>✅RPC接口返回中，使用基本类型还是包装类？</h1><h2 id="典型回答-19"><a href="#典型回答-19" class="headerlink" title="典型回答"></a>典型回答</h2><p>使用包装类，不要使用基本类型，比如某个字段表示费率的<code>Float rate</code>,在接口中返回时，如果出现接口异常的情况，那么可能会返回默认值，float的话返回的是0.0，而Float返回的是null。</p>
<p>在接口中，为了避免发生歧义，建议使用对象，因为他默认值是null，当看到null的时候，我们明确的知道他是出错了，但是看到0.0的时候，你不知道是因为出错返回的0.0，还是就是不出错真的返回了0.0，虽然可以用其他的字段如错误码或者getSuccess判断，但是还是尽量减少歧义的可能</p>
<h2 id="知识扩展-2"><a href="#知识扩展-2" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="在接口定义的时候，如何定义一个字段表示是否成功？"><a href="#在接口定义的时候，如何定义一个字段表示是否成功？" class="headerlink" title="在接口定义的时候，如何定义一个字段表示是否成功？"></a>在接口定义的时候，如何定义一个字段表示是否成功？</h2><p>以下四种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> success</span><br><span class="line">Boolean success</span><br><span class="line"><span class="type">boolean</span> isSuccess</span><br><span class="line">Boolean isSuccess</span><br></pre></td></tr></table></figure>

<p>建议使用第2种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean success</span><br></pre></td></tr></table></figure>



<p>首先，作为接口的返回对象的参数，这个字段不应该有不确定的值，而Boolean类型的默认值是null，而boolean的默认值是false，所以，当拿到一个false的时候，你就不知道是真的false了，还是因为出了问题而默认返回的false。</p>
<p>其他，关于参数名称，要使用success还是isSuccess，这一点在阿里巴巴Java开发手册中有明确规定和解释：</p>
<p>【强制】 POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p>
<p>反例： 定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()， RPC</p>
<p>框架在反向解析的时候， “ 以为” 对应的属性名称是 success，导致属性获取不到，进而抛出</p>
<p>异常。</p>
<h1 id="✅serialVersionUID-有何用途-如果没定义会有什么问题？"><a href="#✅serialVersionUID-有何用途-如果没定义会有什么问题？" class="headerlink" title="✅serialVersionUID 有何用途? 如果没定义会有什么问题？"></a>✅serialVersionUID 有何用途? 如果没定义会有什么问题？</h1><p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p>
<p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。</p>
<p>把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p>
<p>但是，<strong>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，即serialVersionUID要求一致。</strong></p>
<p>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。这样做是为了保证安全，因为文件存储中的内容可能被篡改。</p>
<p>当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件没有发生变化，就算再编译多次，serialVersionUID也不会变化的。但是，如果发生了变化，那么这个文件对应的serialVersionUID也就会发生变化。</p>
<p>基于以上原理，如果我们一个类实现了Serializable接口，但是没有定义serialVersionUID，然后序列化。在序列化之后，由于某些原因，我们对该类做了变更，重新启动应用后，我们相对之前序列化过的对象进行反序列化的话就会报错。</p>
<h2 id="扩展知识-6"><a href="#扩展知识-6" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="改了会怎么样"><a href="#改了会怎么样" class="headerlink" title="改了会怎么样"></a>改了会怎么样</h2><p>我们举个例子吧，看看如果serialVersionUID被修改了会发生什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Initializes The Object</span><br><span class="line">        User1 user = new User1();</span><br><span class="line">        user.setName(&quot;hollis&quot;);</span><br><span class="line">        //Write Obj to File</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User1 implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们先执行以上代码，把一个User1对象写入到文件中。然后我们修改一下User1类，把serialVersionUID的值改为2L。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User1 implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2L;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行以下代码，把文件中的对象反序列化出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Read Obj from File</span><br><span class="line">        File file = new File(&quot;tempFile&quot;);</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ois = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">            User1 newUser = (User1) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            try &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 2</span><br></pre></td></tr></table></figure>



<p>可以发现，以上代码抛出了一个java.io.InvalidClassException，并且指出serialVersionUID不一致。</p>
<p>这是因为，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidClassException。</p>
<h2 id="为什么要明确定一个serialVersionUID"><a href="#为什么要明确定一个serialVersionUID" class="headerlink" title="为什么要明确定一个serialVersionUID"></a>为什么要明确定一个serialVersionUID</h2><p>如果我们没有在类中明确的定义一个serialVersionUID的话，看看会发生什么。</p>
<p>尝试修改上面的demo代码，先使用以下类定义一个对象，该类中不定义serialVersionUID，将其写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User1 implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们修改User1类，向其中增加一个属性。在尝试将其从文件中读取出来，并进行反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User1 implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果： java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc serialVersionUID &#x3D; -2986778152837257883, local class serialVersionUID &#x3D; 7961728318907695402</p>
<p>同样，抛出了InvalidClassException，并且指出两个serialVersionUID不同，分别是-2986778152837257883和7961728318907695402。</p>
<p>从这里可以看出，系统自己添加了一个serialVersionUID。</p>
<p>所以，一旦类实现了Serializable，就建议明确的定义一个serialVersionUID。不然在修改类的时候，就会发生异常。</p>
<p>serialVersionUID有两种显示的生成方式：<br>一是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：<br>private static final long serialVersionUID &#x3D; xxxxL;</p>
<h1 id="✅SimpleDateFormat是线程安全的吗？使用时应该注意什么？"><a href="#✅SimpleDateFormat是线程安全的吗？使用时应该注意什么？" class="headerlink" title="✅SimpleDateFormat是线程安全的吗？使用时应该注意什么？"></a>✅SimpleDateFormat是线程安全的吗？使用时应该注意什么？</h1><h2 id="典型回答-20"><a href="#典型回答-20" class="headerlink" title="典型回答"></a>典型回答</h2><p>在日常开发中，我们经常会用到时间，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。</p>
<p>最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。</p>
<p>在阿里巴巴Java开发手册中，有如下明确规定：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/tfknKZeqW3ZLd0Oj/1673071467790-da4c1bfd-4aee-4441-832a-efb0009d11c9-841360.png" alt="1673071467790-da4c1bfd-4aee-4441-832a-efb0009d11c9.png"></p>
<p>也就是说SimpleDateFormat是非线程安全的，所以在多线程场景中，不能使用SimpleDateFormat作为共享变量。</p>
<p>因为SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。</p>
<p>如果我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p>
<p>假设线程1刚刚执行完<code>calendar.setTime</code>把时间设置成2018-11-11，还没等执行完，线程2又执行了<code>calendar.setTime</code>把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的<code>calendar.getTime</code>得到的时间就是线程2改过之后的。</p>
<p>想要保证线程安全，要么就是不要把SDF设置成成员变量，只设置成局部变量就行了，要不然就是加锁避免并发，或者使用JDK 1.8中的<strong>DateTimeFormatter</strong></p>
<h2 id="扩展知识-7"><a href="#扩展知识-7" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="SimpleDateFormat用法"><a href="#SimpleDateFormat用法" class="headerlink" title="SimpleDateFormat用法"></a>SimpleDateFormat用法</h2><p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。</p>
<p>在Java中，可以使用SimpleDateFormat的format方法，将一个Date类型转化成String类型，并且可以指定输出格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Date转String</span><br><span class="line">Date data = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String dataStr = sdf.format(data);</span><br><span class="line">System.out.println(dataStr);</span><br></pre></td></tr></table></figure>



<p>以上代码，转换的结果是：2018-11-25 13:00:00，日期和时间格式由”日期和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就行了。</p>
<p>在Java中，可以使用SimpleDateFormat的parse方法，将一个String类型转化成Date类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// String转Data</span><br><span class="line">System.out.println(sdf.parse(dataStr));</span><br></pre></td></tr></table></figure>



<h3 id="日期和时间模式表达方法"><a href="#日期和时间模式表达方法" class="headerlink" title="日期和时间模式表达方法"></a>日期和时间模式表达方法</h3><p>在使用SimpleDateFormat的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表如下：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/tfknKZeqW3ZLd0Oj/1726909533291-366ee04c-b063-45a3-bae2-3909b2d10205-276074.jpeg" alt="15431240092595.jpg"></p>
<p>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表示方法。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/tfknKZeqW3ZLd0Oj/1726909533271-2d3539e8-7992-4dfc-a396-bbee23d06a9b-547809.jpeg" alt="15431240361504.jpg"></p>
<h3 id="输出不同时区的时间"><a href="#输出不同时区的时间" class="headerlink" title="输出不同时区的时间"></a>输出不同时区的时间</h3><p>时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p>
<p>世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p>
<p>现今全球共分为24个时区。由于使用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。</p>
<p>由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一样，所以，在Java中想要获取时间的时候，要重点关注一下时区问题。</p>
<p>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用<code>new Date()</code>就可以获取中国的当前时间的原因。</p>
<p>那么，如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));</span><br><span class="line">System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br></pre></td></tr></table></figure>



<p>以上代码，转换的结果是： 2018-11-24 21:00:00 。既中国的时间是11月25日的13点，而美国洛杉矶时间比中国北京时间慢了16个小时（这还和冬夏令时有关系，就不详细展开了）。</p>
<blockquote>
<p>如果你感兴趣，你还可以尝试打印一下美国纽约时间（America&#x2F;New_York）。纽约时间是2018-11-25 00:00:00。纽约时间比中国北京时间早了13个小时。</p>
</blockquote>
<p>当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍SimpleDateFormat，其他方法暂不介绍了。</p>
<h2 id="SimpleDateFormat线程安全性"><a href="#SimpleDateFormat线程安全性" class="headerlink" title="SimpleDateFormat线程安全性"></a>SimpleDateFormat线程安全性</h2><p>由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        simpleDateFormat.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));</span><br><span class="line">        System.out.println(simpleDateFormat.format(Calendar.getInstance().getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这种定义方式，存在很大的安全隐患。</strong></p>
<h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>我们来看一段代码，以下代码使用线程池来执行时间输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   /** * @author Hollis */ </span><br><span class="line">   public class Main &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个全局的SimpleDateFormat</span><br><span class="line">     */</span><br><span class="line">    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用ThreadFactoryBuilder定义一个线程池</span><br><span class="line">     */</span><br><span class="line">    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">    private static ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span><br><span class="line">     */</span><br><span class="line">    private static CountDownLatch countDownLatch = new CountDownLatch(100);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个线程安全的HashSet</span><br><span class="line">        Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;());</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            //获取当前时间</span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            int finalI = i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                    //时间增加</span><br><span class="line">                    calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                    //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">                    String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">                    //把字符串放入Set中</span><br><span class="line">                    dates.add(dateString);</span><br><span class="line">                    //countDown</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //阻塞，直到countDown数量为0</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        //输出去重后的时间个数</span><br><span class="line">        System.out.println(dates.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码，其实比较简单，很容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个<strong>线程安全的</strong>、<strong>带有去重功能</strong>的Set中，然后输出Set中元素个数。</p>
<blockquote>
<p>上面的例子我特意写的稍微复杂了一些，不过我几乎都加了注释。这里面涉及到了线程池的创建、CountDownLatch、lambda表达式、线程安全的HashSet等知识。感兴趣的朋友可以逐一了解一下。</p>
</blockquote>
<p>正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。</p>
<p>原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。</p>
<p>在阿里巴巴Java开发手册的第一章第六节——并发处理中关于这一点也有明确说明：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/tfknKZeqW3ZLd0Oj/1726909533278-91ca6ad0-5fda-4925-b9a4-f28e0a196b1c-974448.png" alt="guiyue2.png"></p>
<p>那么，接下来我们就来看下到底是为什么，以及该如何解决。</p>
<h3 id="线程不安全原因"><a href="#线程不安全原因" class="headerlink" title="线程不安全原因"></a>线程不安全原因</h3><p>通过以上代码，我们发现了在并发场景中使用SimpleDateFormat会有线程安全问题。其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：</p>
<blockquote>
<p>Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</blockquote>
<p>那么接下来分析下为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？</p>
<p>我们跟一下SimpleDateFormat类中format方法的实现其实就能发现端倪。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/tfknKZeqW3ZLd0Oj/1726909533278-3096a9ba-46bb-4268-81ab-073b5642734f-092041.jpeg" alt="15431313894397.jpg"></p>
<p>SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。</p>
<p>由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p>
<p>假设线程1刚刚执行完<code>calendar.setTime</code>把时间设置成2018-11-11，还没等执行完，线程2又执行了<code>calendar.setTime</code>把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的<code>calendar.getTime</code>得到的时间就是线程2改过之后的。</p>
<p>除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。</p>
<p>所以，不要把SimpleDateFormat作为一个共享变量使用。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>前面介绍过了SimpleDateFormat存在的问题以及问题存在的原因，那么有什么办法解决这种问题呢？</p>
<p>解决方法有很多，这里介绍三个比较常用的方法。</p>
<p><strong>使用局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    //获取当前时间</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    int finalI = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        // SimpleDateFormat声明成局部变量</span><br><span class="line">    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        //时间增加</span><br><span class="line">        calendar.add(Calendar.DATE, finalI);</span><br><span class="line">        //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">        String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">        //把字符串放入Set中</span><br><span class="line">        dates.add(dateString);</span><br><span class="line">        //countDown</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。</p>
<p><strong>加同步锁</strong></p>
<p>除了改成局部变量以外，还有一种方法大家可能比较熟悉的，就是对于共享变量进行加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    //获取当前时间</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    int finalI = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        synchronized (simpleDateFormat) &#123;</span><br><span class="line">            //时间增加</span><br><span class="line">            calendar.add(Calendar.DATE, finalI);</span><br><span class="line">            //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">            String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">            //把字符串放入Set中</span><br><span class="line">            dates.add(dateString);</span><br><span class="line">            //countDown</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。</p>
<p>其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以只对<code>simpleDateFormat.format</code>这一行加锁，这样效率更高一些。</p>
<p><strong>使用ThreadLocal</strong></p>
<p>第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用ThreadLocal定义一个全局的SimpleDateFormat</span><br><span class="line"> */</span><br><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">        return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用法</span><br><span class="line">String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure>



<p>用 ThreadLocal 来实现其实是有点类似于缓存的思路，每个线程都有一个独享的对象，避免了频繁创建对象，也避免了多线程的竞争。</p>
<p>当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。</p>
<p><strong>使用DateTimeFormatter</strong></p>
<p>如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//解析日期</span><br><span class="line">String dateStr= &quot;2016年10月25日&quot;;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);</span><br><span class="line">LocalDate date= LocalDate.parse(dateStr, formatter);</span><br><span class="line"></span><br><span class="line">//日期转换为字符串</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);</span><br><span class="line">String nowStr = now .format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure>




<h1 id="✅Stream的并行流一定比串行流更快吗？"><a href="#✅Stream的并行流一定比串行流更快吗？" class="headerlink" title="✅Stream的并行流一定比串行流更快吗？"></a>✅Stream的并行流一定比串行流更快吗？</h1><h2 id="典型回答-21"><a href="#典型回答-21" class="headerlink" title="典型回答"></a>典型回答</h2><p>不一定！</p>
<p>Stream底层使用了ForkJoin进行并发处理，但是，并不代表着用了并发处理就一定比串行处理更快。有以下几个因素影响着并行流的性能：</p>
<p><strong>线程管理的开销</strong>：并行流使用了多线程，而用了多线程就会带来线程管理和任务分配的开销。</p>
<p><strong>任务分割</strong>：并行流的性能提升依赖于任务能够有效地分割和分配。如果任务分割不均衡，一些线程可能空闲或等待，从而影响性能。</p>
<p><strong>线程争用</strong>：并行流使用公共的ForkJoinPool，如果系统中有其他并行任务，这些任务会争用线程资源，可能导致性能下降。</p>
<p><strong>数据依赖性</strong>：并行流适用于没有数据依赖性的操作。如果操作之间存在依赖关系，并行流可能无法有效地提升性能，甚至可能导致错误。</p>
<p><strong>环境配置</strong>：机器的硬件配置（例如CPU核心数）和当前系统负载也会影响并行流的性能。如果CPU核心数较少或负载较高，并行流的性能可能不如串行流。</p>
<p>在github（<a target="_blank" rel="noopener" href="https://github.com/nickliuchao/stream/tree/master">https://github.com/nickliuchao/stream/tree/master</a> ）上看到过有人做过测试，他测试的几个case是：</p>
<ul>
<li>多核CPU服务器配置环境下，对比长度100的int数组的性能；</li>
<li>多核CPU服务器配置环境下，对比长度1.00E+8的int数组的性能；</li>
<li>多核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组的性能；</li>
<li>单核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组的性能。</li>
</ul>
<p>主要区别就是CPU核数、任务的数量以及Stream中的元素的类型。得到的结果如下：</p>
<ul>
<li>多核CPU服务器配置环境下，对比长度100的int数组 <ul>
<li>常规的迭代&gt;Stream并行迭代&gt;Stream串行迭代</li>
</ul>
</li>
<li>多核CPU服务器配置环境下，对比长度1.00E+8的int数组 <ul>
<li>Stream并行迭代&gt;常规的迭代&gt;Stream串行迭代</li>
</ul>
</li>
<li>多核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组 <ul>
<li>Stream并行迭代&gt;常规的迭代&gt;Stream串行迭代</li>
</ul>
</li>
<li>单核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组 <ul>
<li>常规的迭代&gt;Stream串行迭代&gt;Stream并行迭代</li>
</ul>
</li>
</ul>
<p>所以，我们可以得到结论：</p>
<p><strong>在单核CPU的情况下，Stream的串行迭代的效率是要高于Stream的并行迭代的效率的。</strong></p>
<p><strong>而在多核CPU的情况下，Stream的并行迭代速度要比Stream的串行迭代效率要高。但是，如果元素数量比较少的话，直接用常规迭代反而性能更好。</strong></p>
<h1 id="✅String、StringBuilder和StringBuffer的区别？"><a href="#✅String、StringBuilder和StringBuffer的区别？" class="headerlink" title="✅String、StringBuilder和StringBuffer的区别？"></a>✅String、StringBuilder和StringBuffer的区别？</h1><h2 id="典型回答-22"><a href="#典型回答-22" class="headerlink" title="典型回答"></a>典型回答</h2><p>String是不可变的，StringBuilder和StringBuffer是可变的。而StringBuffer是线程安全的，而StringBuilder是非线程安全的。</p>
<h2 id="扩展知识-8"><a href="#扩展知识-8" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><h2 id="为什么设计成不可变的"><a href="#为什么设计成不可变的" class="headerlink" title="为什么设计成不可变的"></a>为什么设计成不可变的</h2><h2 id="String的”-”是如何实现的"><a href="#String的”-”是如何实现的" class="headerlink" title="String的”+”是如何实现的"></a>String的”+”是如何实现的</h2><p>“&gt;使用+”&gt;拼接字符串，其实只是Java提供的一个语法糖， 那么，我们就来解一解这个语法糖，看看他的内部原理到底是如何实现的。</p>
<p>“&gt;还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = &quot;Hollis&quot;;</span><br><span class="line">String introduce = &quot;Chuang&quot;;</span><br><span class="line">String hollis = wechat + &quot;,&quot; + introduce;</span><br></pre></td></tr></table></figure>



<p>“&gt;反编译后的内容如下，反编译工具为jad。</p>
<p>“&gt;</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = &quot;Hollis&quot;;</span><br><span class="line">String introduce = &quot;Chuang&quot;;</span><br><span class="line">String hollis = (new StringBuilder()).append(wechat).append(&quot;,&quot;).append(introduce).toString();</span><br></pre></td></tr></table></figure>

<p>“&gt;</p>
<p>“&gt;通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。</p>
<p>“&gt;</p>
<p>那么也就是说，Java中的+对字符串的拼接，其实现原理是使用StringBuilder.append。</p>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><p>接下来我们看看<code>StringBuffer</code>和<code>StringBuilder</code>的实现原理。</p>
<p>和<code>String</code>类类似，<code>StringBuilder</code>类也封装了一个字符数组，定义如下：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char[] value;</span><br></pre></td></tr></table></figure>





<p>与<code>String</code>不同的是，它并不是<code>final</code>的，所以他是可以修改的。另外，与<code>String</code>不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count;</span><br></pre></td></tr></table></figure>



<p>其append源码如下：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该类继承了<code>AbstractStringBuilder</code>类，看下其<code>append</code>方法：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p>
<p><code>StringBuffer</code>和<code>StringBuilder</code>类似，最大的区别就是<code>StringBuffer</code>是线程安全的，看一下<code>StringBuffer</code>的<code>append</code>方法。</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法使用<code>synchronized</code>进行声明，说明是一个线程安全的方法。而<code>StringBuilder</code>则不是线程安全的。</p>
<h2 id="不要在for循环中使用-拼接字符串"><a href="#不要在for循环中使用-拼接字符串" class="headerlink" title="不要在for循环中使用+拼接字符串"></a>不要在for循环中使用+拼接字符串</h2><p>前面我们分析过，其实使用<code>+</code>拼接字符串的实现原理也是使用的<code>StringBuilder</code>，那为什么不建议大家在for循环中使用呢？</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们把以下代码反编译下：</span><br><span class="line"></span><br><span class="line">long t1 = System.currentTimeMillis();</span><br><span class="line">String str = &quot;hollis&quot;;</span><br><span class="line">for (int i = 0; i &lt; 50000; i++) &#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str += s;</span><br><span class="line">&#125;</span><br><span class="line">long t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;+ cost:&quot; + (t2 - t1));</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下（JDK 9之前 ）：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long t1 = System.currentTimeMillis();</span><br><span class="line">String str = &quot;hollis&quot;;</span><br><span class="line">for(int i = 0; i &lt; 50000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str = (new StringBuilder()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println((new StringBuilder()).append(&quot;+ cost:&quot;).append(t2 - t1).toString());</span><br></pre></td></tr></table></figure>



<p>我们可以看到，反编译后的代码，在<code>for</code>循环中，每次都是<code>new</code>了一个<code>StringBuilder</code>，然后再把<code>String</code>转成<code>StringBuilder</code>，再进行<code>append</code>。</p>
<p>而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。</p>
<p>所以，阿里巴巴Java开发手册建议：循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。而不要使用<code>+</code>。</p>
<p>在JDK 9中，引入了StringConcatFactory对<code>+</code>进行了优化：</p>
<h1 id="✅String-a-“ab”-String-b-“a”-“b”-a-b-吗？"><a href="#✅String-a-“ab”-String-b-“a”-“b”-a-b-吗？" class="headerlink" title="✅String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？"></a>✅String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？</h1><h2 id="典型回答-23"><a href="#典型回答-23" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java中，对于字符串使用&#x3D;&#x3D;比较的是字符串对象的引用地址是否相同。</p>
<p>因为”ab”和”a”、”b”都是由字面量（””包裹的内容）组成的字符串，在编译之后，会把用”+”拼接的字面量直接合在一起。因此他们的最终都是”ab”，而字面值最终在字符串池只有一份，所以a &#x3D;&#x3D; b的结果为true，因为它们指向的是同一个字符串对象。</p>
<h2 id="扩展知识-9"><a href="#扩展知识-9" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p>
<p>以上是关于计算机科学中关于字面量的解释，并不是很容易理解。说简单点，字面量就是指由字母、数字等构成的字符串或者数值。</p>
<p>字面量只可以右值出现，所谓右值是指等号右边的值，如：int a&#x3D;123这里的a为左值，123为右值。在这个例子中123就是字面量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">String s = <span class="string">&quot;hollis&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>上面的代码事例中，123和hollis都是字面量。</p>
<p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p>
<p>在JVM中，有一块区域是运行时常量池，主要用来存储编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。</p>
<p>了解Class文件结构或者做过Java代码的反编译的朋友可能都知道，在java代码被javac编译之后，文件结构中是包含一部分Constant pool的。比如以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">static</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String s = <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>经过编译后，常量池内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">2</span> = String             #<span class="number">21</span>            <span class="comment">// Hollis</span></span><br><span class="line">  #<span class="number">3</span> = Class              #<span class="number">22</span>            <span class="comment">// StringDemo</span></span><br><span class="line">  #<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  ...</span><br><span class="line">  #<span class="number">16</span> = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #<span class="number">21</span> = Utf8               Hollis</span><br><span class="line">  #<span class="number">22</span> = Utf8               StringDemo</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>



<p>上面的Class文件中的常量池中，比较重要的几个内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">16</span> = Utf8               s</span><br><span class="line">#<span class="number">21</span> = Utf8               Hollis</span><br><span class="line">#<span class="number">22</span> = Utf8               StringDemo</span><br></pre></td></tr></table></figure>



<p>上面几个常量中，<code>s</code>就是前面提到的符号引用，而<code>Hollis</code>就是前面提到的<strong>字面量</strong>。</p>
<p>而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p>
<h1 id="✅String-str-new-String-“hollis”-创建了几个对象？"><a href="#✅String-str-new-String-“hollis”-创建了几个对象？" class="headerlink" title="✅String str&#x3D;new String(“hollis”)创建了几个对象？"></a>✅String str&#x3D;new String(“hollis”)创建了几个对象？</h1><h2 id="典型回答-24"><a href="#典型回答-24" class="headerlink" title="典型回答"></a>典型回答</h2><p>创建的对象数应该是1个或者2个。</p>
<p>首先要清楚什么是对象？</p>
<p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的，在HotSpot虚拟机中，存储的形式就是oop-klass model，即Java对象模型。我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。</p>
<p>这才叫对象。其他的，一概都不叫对象。</p>
<p>那么不管怎么样，一次new的过程，都会在堆上创建一个对象，那么就是起码有一个对象了。至于另外一个对象，到底有没有要看具体情况了。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/rqDJGs6EW2zy4wtR/1704006181996-80ad196a-2546-4756-9bf6-92d44c5d51d0-262923.png" alt="1704006181996-80ad196a-2546-4756-9bf6-92d44c5d51d0.png"></p>
<p>另外这一个对象就是常量池中的字符串常量，这个字符串其实是类编译阶段就进到Class常量池的，然后在运行期，字符串常量在第一次被调用(准确的说是ldc指令)的时候，进行解析并在字符串池中创建对应的String实例的。</p>
<p>在运行时常量池中，也并不是会立刻被解析成对象，而是会先以JVM_CONSTANT_UnresolveString_info的形式驻留在常量池。在后面，该引用第一次被LDC指令执行到的时候，就尝试在堆上创建字符串对象，并将对象的引用驻留在字符串常量池中。</p>
<p>通过看上面的过程，你也能发现，这个过程的触发条件是我们没办法决定的，问题的题干中也没提到。有可能执行这段代码的时候是第一次LDC指令执行，也许在前面就执行过了。</p>
<hr>
<p><strong>所以，如果是第一次执行，那么就是会同时创建两个对象。一个字符串常量引用指向的对象，一个我们new出来的对象。</strong></p>
<hr>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/rqDJGs6EW2zy4wtR/1704006329527-80677410-5c40-456b-87bf-8a8f9d9816c2-298246.png" alt="1704006329527-80677410-5c40-456b-87bf-8a8f9d9816c2.png"></p>
<hr>
<p><strong>如果不是第一次执行，那么就只会创建我们自己new出来的对象。</strong></p>
<hr>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/rqDJGs6EW2zy4wtR/1704006345858-83577855-2fe4-41cc-896e-45f4e8bd6d8b-728274.png" alt="1704006345858-83577855-2fe4-41cc-896e-45f4e8bd6d8b.png"></p>
<p>至于有人说什么在字符串池内还有在栈上还有一个引用对象，你听听这说法，引用就是引用。别往对象上面扯。</p>
<h2 id="扩展知识-10"><a href="#扩展知识-10" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="字面量和运行时常量池"><a href="#字面量和运行时常量池" class="headerlink" title="字面量和运行时常量池"></a>字面量和运行时常量池</h2><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p>
<p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储<strong>编译期</strong>生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。</p>
<p>了解Class文件结构或者做过Java代码的反编译的朋友可能都知道，在java代码被<code>javac</code>编译之后，文件结构中是包含一部分<code>Constant pool</code>的。比如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = &quot;Hollis&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>经过编译后，常量池内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #2 = String             #21            // Hollis</span><br><span class="line">  #3 = Class              #22            // StringDemo</span><br><span class="line">  #4 = Class              #23            // java/lang/Object</span><br><span class="line">  ...</span><br><span class="line">  #16 = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #21 = Utf8               Hollis</span><br><span class="line">  #22 = Utf8               StringDemo</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>



<p>上面的Class文件中的常量池中，比较重要的几个内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               Hollis</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure>



<p>上面几个常量中，<code>s</code>就是前面提到的<strong>符号引用</strong>，而<code>Hollis</code>就是前面提到的<strong>字面量</strong>。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。关于字面量，详情参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">Java SE Specifications</a></p>
<h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p><strong>编译期</strong>生成的各种<strong>字面量</strong>和<strong>符号引用</strong>是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期向运行时常量池中增加常量。那就是<code>String</code>的<code>intern</code>方法。</p>
<p>当一个<code>String</code>实例调用<code>intern()</code>方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p>
<p><strong>intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</strong></p>
<h3 id="intern的正确用法"><a href="#intern的正确用法" class="headerlink" title="intern的正确用法"></a>intern的正确用法</h3><p>不知道，你有没有发现，在<code>String s3 = new String(&quot;Hollis&quot;).intern();</code>中，其实<code>intern</code>是多余的？</p>
<p>因为就算不用<code>intern</code>，Hollis作为一个字面量也会被加载到Class文件的常量池，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才需要使用<code>intern</code>呢？</p>
<p>在解释这个之前，我们先来看下以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;Hollis&quot;;</span><br><span class="line">String s2 = &quot;Chuang&quot;;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = &quot;Hollis&quot; + &quot;Chuang&quot;;</span><br></pre></td></tr></table></figure>



<p>在经过反编译后，得到代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;Hollis&quot;;</span><br><span class="line">String s2 = &quot;Chuang&quot;;</span><br><span class="line">String s3 = (new StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = &quot;HollisChuang&quot;;</span><br></pre></td></tr></table></figure>



<p>可以发现，同样是字符串拼接，s3和s4在经过编译器编译后的实现方式并不一样。s3被转化成<code>StringBuilder</code>及<code>append</code>，而s4被直接拼接成新的字符串。</p>
<p>如果你感兴趣，你还能发现，<code>String s3 = s1 + s2;</code> 经过编译之后，常量池中是有两个字符串常量的分别是 <code>Hollis</code>、<code>Chuang</code>（其实<code>Hollis</code>和<code>Chuang</code>是<code>String s1 = &quot;Hollis&quot;;</code>和<code>String s2 = &quot;Chuang&quot;;</code>定义出来的），拼接结果<code>HollisChuang</code>并不在常量池中。</p>
<p>究其原因，是因为常量池要保存的是<strong>已确定</strong>的字面量值。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串池。</p>
<p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成<code>StringBuilder.append</code>，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p>
<p>那么，有了这个特性了，<code>intern</code>就有用武之地了。那就是很多时候，我们在程序中得到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中。</p>
<p>这时候，对于那种可能经常使用的字符串，使用<code>intern</code>进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</p>
<p>如一<a target="_blank" rel="noopener" href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析String#intern</a>文中举的一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static final int MAX = 1000 * 10000;</span><br><span class="line">static final String[] arr = new String[MAX];</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Integer[] DB_DATA = new Integer[10];</span><br><span class="line">    Random random = new Random(10 * 10000);</span><br><span class="line">    for (int i = 0; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] = random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    long t = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; MAX; i++) &#123;</span><br><span class="line">         arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println((System.currentTimeMillis() - t) + &quot;ms&quot;);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在以上代码中，我们明确的知道，会有很多重复的相同的字符串产生，但是这些字符串的值都是只有在运行期才能确定的。所以，只能我们通过<code>intern</code>显示的将其加入常量池，这样可以减少很多字符串的重复创建。</p>
<h1 id="✅String是如何实现不可变的？"><a href="#✅String是如何实现不可变的？" class="headerlink" title="✅String是如何实现不可变的？"></a>✅String是如何实现不可变的？</h1><h2 id="典型回答-25"><a href="#典型回答-25" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们都知道String是不可变的，但是它是怎么实现的呢？</p>
<p>先来看一段String的源码（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码，其实就包含了String不可变的主要实现了。</p>
<ol>
<li><strong>String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。</strong></li>
<li><strong>用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。</strong></li>
<li><strong>String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hollis666/xkm7k3/hcy7n8p0rhxro0xq">为什么JDK 9中把String的char[]改成了byte[]？</a></p>
<p>再然后，在他的一些方法中，如substring、concat等，在代码中如果有涉及到字符串的修改，也是通过new String()的方式新建了一个字符串。</p>
<p>所以，通过以上方式，使得一个字符串的内容，一旦被创建出来，就是不可以修改的了。</p>
<blockquote>
<p>不可变对象是在完全创建后其内部状态保持不变的对象。这意味着，一旦对象被赋值给变量，我们既不能更新引用，也不能通过任何方式改变内部状态。</p>
</blockquote>
<p>可是有人会有疑惑，String为什么不可变，我的代码中经常改变String的值啊，如下：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">s = s.concat(&quot;ef&quot;);</span><br></pre></td></tr></table></figure>



<p>这样，操作，不就将原本的”abcd”的字符串改变成”abcdef”了么？</p>
<p>但是，虽然字符串内容看上去从”abcd”变成了”abcdef”，但是实际上，我们得到的已经是一个新的字符串了。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/FzebmtNOHBQ7Bzpj/1693569145559-1464948e-b069-4234-8f03-40dba93f044b-237027.jpeg" alt="1693569145559-1464948e-b069-4234-8f03-40dba93f044b.jpeg"></p>
<p>如上图，在堆中重新创建了一个”abcdef”字符串，和”abcd”并不是同一个对象。</p>
<p>所以，一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。而且，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。</p>
<p>如果我们想要一个可修改的字符串，可以选择StringBuffer 或者 StringBuilder这两个代替String。</p>
<h1 id="✅String为什么设计成不可变的？"><a href="#✅String为什么设计成不可变的？" class="headerlink" title="✅String为什么设计成不可变的？"></a>✅String为什么设计成不可变的？</h1><p>为什么要把String设计成不可变的呢？有什么好处呢？</p>
<p>这个问题，困扰过很多人，甚至有人直接问过Java的创始人James Gosling。</p>
<p>在一次采访中James Gosling被问到什么时候应该使用不可变变量，他给出的回答是:</p>
<blockquote>
<p>I would use an immutable whenever I can.</p>
</blockquote>
<p>那么，他给出这个答案背后的原因是什么呢？是基于哪些思考的呢？</p>
<p>其实，主要是从缓存、安全性、线程安全和性能等角度出发的。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>字符串是使用最广泛的数据结构。大量的字符串的创建是非常耗费资源的，所以，Java提供了对字符串的缓存功能，可以大大的节省堆空间。</p>
<p>JVM中专门开辟了一部分空间来存储Java字符串，那就是字符串池。</p>
<p>通过字符串池，两个内容相同的字符串变量，可以从池中指向同一个字符串对象，从而节省了关键的内存资源。</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">String s2 = s;</span><br></pre></td></tr></table></figure>



<p>对于这个例子，s和s2都表示”abcd”，所以他们会指向字符串池中的同一个字符串对象：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/NzRd17BkrdlDihey/1672212318617-14a7ca77-145c-41eb-b2b0-936539bc1ad9-191095.jpeg" alt="1672212318617-14a7ca77-145c-41eb-b2b0-936539bc1ad9.jpeg"></p>
<p>但是，之所以可以这么做，主要是因为字符串的不变性。试想一下，如果字符串是可变的，我们一旦修改了s的内容，那必然导致s2的内容也被动的改变了，这显然不是我们想看到的。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>字符串在Java应用程序中广泛用于存储敏感信息，如用户名、密码、连接url、网络连接等。JVM类加载器在加载类的时也广泛地使用它。</p>
<p>因此，保护String类对于提升整个应用程序的安全性至关重要。</p>
<p>当我们在程序中传递一个字符串的时候，如果这个字符串的内容是不可变的，那么我们就可以相信这个字符串中的内容。</p>
<p>但是，如果是可变的，那么这个字符串内容就可能随时都被修改。那么这个字符串内容就完全不可信了。这样整个系统就没有安全性可言了。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>不可变会自动使字符串成为线程安全的，因为当从多个线程访问它们时，它们不会被更改。</p>
<p>因此，一般来说，不可变对象可以在同时运行的多个线程之间共享。它们也是线程安全的，因为如果线程更改了值，那么将在字符串池中创建一个新的字符串，而不是修改相同的值。因此，字符串对于多线程来说是安全的。</p>
<h3 id="hashcode缓存"><a href="#hashcode缓存" class="headerlink" title="hashcode缓存"></a>hashcode缓存</h3><p>由于字符串对象被广泛地用作数据结构，它们也被广泛地用于哈希实现，如HashMap、HashTable、HashSet等。在对这些散列实现进行操作时，经常调用hashCode()方法。</p>
<p>不可变性保证了字符串的值不会改变。因此，hashCode()方法在String类中被重写，以方便缓存，这样在第一次hashCode()调用期间计算和缓存散列，并从那时起返回相同的值。</p>
<p>在String类中，有以下代码：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int hash;//this is used to cache hash code.</span><br></pre></td></tr></table></figure>



<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>前面提到了的字符串池、hashcode缓存等，都是提升性能的体现。</p>
<p>因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对hashcode进行缓存，更加高效</p>
<p>由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。</p>
<h1 id="✅String有长度限制吗？是多少？"><a href="#✅String有长度限制吗？是多少？" class="headerlink" title="✅String有长度限制吗？是多少？"></a>✅String有长度限制吗？是多少？</h1><h2 id="典型回答-26"><a href="#典型回答-26" class="headerlink" title="典型回答"></a>典型回答</h2><p>有，编译期和运行期不一样。</p>
<p>编译期需要用CONSTANT_Utf8_info 结构用于表示字符串常量的值，而这个结构是有长度限制，他的限制是65535。</p>
<p>运行期，String的length参数是Int类型的，那么也就是说，String定义的时候，最大支持的长度就是int的最大范围值。根据Integer类的定义，<code>java.lang.Integer#MAX_VALUE</code>的最大值是2^31 - 1;</p>
<h2 id="扩展知识-11"><a href="#扩展知识-11" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="常量池限制"><a href="#常量池限制" class="headerlink" title="常量池限制"></a>常量池限制</h2><p>我们知道，javac是将Java文件编译成class文件的一个命令，那么在Class文件生成过程中，就需要遵守一定的格式。</p>
<p>根据《Java虚拟机规范》中第4.4章节常量池的定义，CONSTANT_String_info 用于表示 java.lang.String 类型的常量对象，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 string_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中，string_index 项的值必须是对常量池的有效索引， 常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示一组 Unicode 码点序列，这组 Unicode 码点序列最终会被初始化为一个 String 对象。</p>
<p>CONSTANT_Utf8_info 结构用于表示字符串常量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中，length则指明了 bytes[]数组的长度，其类型为u2，</p>
<p>通过翻阅《规范》，我们可以获悉。u2表示两个字节的无符号数，那么1个字节有8位，2个字节就有16位。</p>
<p>16位无符号数可表示的最大值位2^16 - 1 &#x3D; 65535。</p>
<p>也就是说，Class文件中常量池的格式规定了，其字符串常量的长度不能超过65535。</p>
<p>那么，我们尝试使用以下方式定义字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;11111...1111&quot;;//其中有65535个字符&quot;1&quot;</span><br></pre></td></tr></table></figure>



<p>尝试使用javac编译，同样会得到”错误: 常量字符串过长”，那么原因是什么呢？</p>
<p>其实，这个原因在javac的代码中是可以找到的，在Gen类中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void checkStringConstant(DiagnosticPosition var1, Object var2) &#123;</span><br><span class="line">    if (this.nerrs == 0 &amp;&amp; var2 != null &amp;&amp; var2 instanceof String &amp;&amp; ((String)var2).length() &gt;= 65535) &#123;</span><br><span class="line">        this.log.error(var1, &quot;limit.string&quot;, new Object[0]);</span><br><span class="line">        ++this.nerrs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码中可以看出，当参数类型为String，并且长度大于等于65535的时候，就会导致编译失败。</p>
<p>这个地方大家可以尝试着debug一下javac的编译过程（ <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uK4y1t7H1/?spm_id_from=333.999.0.0">视频中</a>有对java的编译过程进行debug的方法），也可以发现这个地方会报错。</p>
<p>如果我们尝试以65534个字符定义字符串，则会发现可以正常编译。</p>
<p>其实，关于这个值，在《Java虚拟机规范》也有过说明：</p>
<blockquote>
<p>if the Java Virtual Machine code for a method is exactly 65535 bytes long and ends with an instruction that is 1 byte long, then that instruction cannot be protected by an exception handler. A compiler writer can work around this bug by limiting the maximum size of the generated Java Virtual Machine code for any method, instance initialization method, or static initializer (the size of any code array) to 65534 bytes</p>
</blockquote>
<h2 id="运行期限制"><a href="#运行期限制" class="headerlink" title="运行期限制"></a>运行期限制</h2><p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s&#x3D; “”;这种字面值方式定义的时候才会有的限制。</p>
<p>那么。String在运行期有没有限制呢，答案是有的。</p>
<p>String类中有很多重载的构造函数，其中有几个是支持用户传入length来执行长度的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String(byte bytes[], int offset, int length)</span><br></pre></td></tr></table></figure>



<p>可以看到，这里面的参数length是使用int类型定义的，那么也就是说，String定义的时候，最大支持的长度就是int的最大范围值。</p>
<p>根据Integer类的定义，<code>java.lang.Integer#MAX_VALUE</code>的最大值是2^31 - 1;这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）</p>
<p>int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2^31-1 =2147483647 个 16-bit Unicodecharacter</span><br><span class="line"></span><br><span class="line">2147483647 * 16 = 34359738352 位</span><br><span class="line">34359738352 / 8 = 4294967294 (Byte)</span><br><span class="line">4294967294 / 1024 = 4194303.998046875 (KB)</span><br><span class="line">4194303.998046875 / 1024 = 4095.9999980926513671875 (MB)</span><br><span class="line">4095.9999980926513671875 / 1024 = 3.99999999813735485076904296875 (GB)</span><br></pre></td></tr></table></figure>



<p>有近 4G 的容量。</p>
<p>很多人会有疑惑，编译的时候最大长度都要求小于65535了，运行期怎么会出现大于65535的情况呢。这其实很常见，如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt;100000 ; i++) &#123;</span><br><span class="line">    s+=&quot;i&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>得到的字符串长度就有10万，另外我之前在实际应用中遇到过这个问题。</p>
<p>之前一次系统对接，需要传输高清图片，约定的传输方式是对方将图片转成BASE64编码，我们接收到之后再转成图片。</p>
<p>在将BASE64编码后的内容赋值给字符串的时候就抛了异常。</p>
<p>后来为了解决这个问题，不再传输图片的BASE64编码内容了，而是先把文件上传到OSS或者FTP中，然后直接传递文件地址。</p>
<h1 id="✅String中intern的原理是什么？"><a href="#✅String中intern的原理是什么？" class="headerlink" title="✅String中intern的原理是什么？"></a>✅String中intern的原理是什么？</h1><h2 id="典型回答-27"><a href="#典型回答-27" class="headerlink" title="典型回答"></a>典型回答</h2><p>字符串常量池中的常量有两种来源：</p>
<p>1、字面量会在编译期先进入到Class常量池，然后再在运行期进去到字符串池，</p>
<p>2、在运行期通过intern将字符串对象手动添加到字符串常量池中。</p>
<p>intern的作用是这样的：</p>
<p><strong>如果字符串池中已经存在一个等于该字符串的对象，intern()方法会返回这个已存在的对象的引用。</strong></p>
<hr>
<p><strong>如果字符串池中没有等于该字符串的对象，intern()方法会将该字符串添加到字符串池中，并返回对新添加的字符串对象的引用。</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;Hollis&quot;) + new String(&quot;Chuang&quot;);</span><br><span class="line">s.intern();</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p>所以，无论何时通过intern()方法获取字符串的引用，都会得到字符串池中的引用，这样可以确保相同的字符串在内存中只有一个实例。</p>
<p>很多人以为知道以上信息，就算是了解intern了，那么请回答一下这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 = new String(&quot;a&quot;); </span><br><span class="line">    s1.intern(); </span><br><span class="line">    String s2 = &quot;a&quot;;</span><br><span class="line">    System.out.println(s1 == s2); // false</span><br><span class="line">    </span><br><span class="line">    String s3 = new String(&quot;a&quot;) + new String(&quot;a&quot;);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = &quot;aa&quot;;</span><br><span class="line">    System.out.println(s3 == s4);//  true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大家可以在 JDK 1.7以上版本中尝试运行以上两段代码，就会发现，s1 &#x3D;&#x3D; s2的结果是 false，但是s3 &#x3D;&#x3D; s4的结果是 true。</p>
<p><strong>这是为什么呢？（后文所有case均基于JDK 1.8运行）</strong></p>
<h2 id="扩展知识-12"><a href="#扩展知识-12" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="字符串常量进入常量池的时机"><a href="#字符串常量进入常量池的时机" class="headerlink" title="字符串常量进入常量池的时机"></a>字符串常量进入常量池的时机</h2><h2 id="intern原理"><a href="#intern原理" class="headerlink" title="intern原理"></a>intern原理</h2><p>先看一下上面这篇（让你看就去看，你不看，然后就看不懂这篇，就怪我讲的不清楚！哼，咋那么犟呢！？），了解了字符串常量进入常量池的时机之后，我们再回过头分析一下前面的例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 = new String(&quot;a&quot;); // ①</span><br><span class="line">    s1.intern(); // ②</span><br><span class="line">    String s2 = &quot;a&quot;;// ③</span><br><span class="line">    System.out.println(s1 == s2); // ④   false</span><br><span class="line">    </span><br><span class="line">    String s3 = new String(&quot;a&quot;) + new String(&quot;a&quot;);// ⑤</span><br><span class="line">    s3.intern();// ⑥</span><br><span class="line">    String s4 = &quot;aa&quot;;// ⑦</span><br><span class="line">    System.out.println(s3 == s4);// ⑧    true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这个类被编译后，Class常量池中应该有”a”和”aa”这两个字符串，这两个字符串最终会进到字符串池。<strong>但是，字面量”a”在代码①这一行，就会被存入字符串池，而字面量”aa”则是在代码⑦这一行才会存入字符串池。</strong></p>
<p>以上代码的执行过程：</p>
<p>第①行，new 一个 String 对象，并让 s1指向他。</p>
<p>第②行，对 s1执行 intern，但是因为”a”这个字符串已经在字符串池中，所以会直接返回原来的引用，但是并没有赋值给任何一个变量。</p>
<p>第③行，s2指向常量池中的”a”；</p>
<p>所以，s1和 s2并不相等！</p>
<p>第⑤行，new 一个 String 对象，并让 s3 指向他。</p>
<p>第⑥行，对 s3 执行 intern，但是目前字符串池中还没有”aa”这个字符串，于是会把指向的String对象的引用放入字符串常量池</p>
<p>第⑦行，因为”aa”这个字符串已经在字符串池中，所以会直接返回原来的引用，并赋值给 s4；</p>
<p>所以，s3和 s4 相等！</p>
<p>而如果我们对代码稍作修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;aa&quot;;// ①</span><br><span class="line">String s3 = new String(&quot;a&quot;) + new String(&quot;a&quot;);// ②</span><br><span class="line">s3.intern();// ③</span><br><span class="line">String s4 = &quot;aa&quot;;</span><br><span class="line">System.out.println(s3 == s4);// ④</span><br></pre></td></tr></table></figure>



<p>以上代码得到的结果则是：false</p>
<p>第①行，创建一个字符串aa，并且因为它是字面量，所以把他放到字符串池。</p>
<p>第②行，new一个 String 对象，并让 s3 指向他。</p>
<p>第③行，对 s3 执行 intern，但是目前字符串池中已经有”aa”这个字符串，所以会直接返回s的引用，但是并没有对s3进行赋值</p>
<p>第④行，因为”aa”这个字符串已经在字符串池中，所以会直接返回原来的引用，即s的引用，并赋值给 s4；所以，s3和 s4 不相等。</p>
<h2 id="a和1有什么不同"><a href="#a和1有什么不同" class="headerlink" title="a和1有什么不同"></a>a和1有什么不同</h2><p>关于这个问题，我们还有一个变型，可以帮大家更好的理解intern，请大家分别在JDK 1.8和JDK 11及以上的版本中执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);// ①</span><br><span class="line">s3.intern();// ②</span><br><span class="line">String s4 = &quot;11&quot;;</span><br><span class="line">System.out.println(s3 == s4);// ③</span><br></pre></td></tr></table></figure>



<p>你会发现，在JDK 1.8中，以上代码得到的结果是true，而JDK 11及以上的版本中结果却是false。（有人反馈自己代码执行和我文中的不一样，可能的原因有很多，比如JDK版本不同、操作系统不同、本地编译过的其他代码也有影响等。故而如果现象不一致，可以使用一些在线的Java代码执行工具测试，如：<a target="_blank" rel="noopener" href="https://www.bejson.com/runcode/java/">https://www.bejson.com/runcode/java/</a> 。）</p>
<p>那么，再稍作修改呢？在目前的所有JDK版本中，执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;3&quot;) + new String(&quot;3&quot;);// ①</span><br><span class="line">s3.intern();// ②</span><br><span class="line">String s4 = &quot;33&quot;;</span><br><span class="line">System.out.println(s3 == s4);// ③</span><br></pre></td></tr></table></figure>



<p>得到的结果也是true，你知道为什么嘛？</p>
<h1 id="✅try中return-A，catch中return-B，finally中return-C，最终返回值是什么？"><a href="#✅try中return-A，catch中return-B，finally中return-C，最终返回值是什么？" class="headerlink" title="✅try中return A，catch中return B，finally中return C，最终返回值是什么？"></a>✅try中return A，catch中return B，finally中return C，最终返回值是什么？</h1><h2 id="典型回答-28"><a href="#典型回答-28" class="headerlink" title="典型回答"></a>典型回答</h2><p>最终的返回值将会是C！</p>
<p>因为finally块总是在try和catch块之后执行，无论是否有异常发生。如果finally块中有一个return语句，它将覆盖try块和catch块中的任何return语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无异常情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有异常情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以在这种情况下，无论try和catch块的执行情况如何，finally块中的return C;总是最后执行的语句，并且其返回值将是整个代码块的返回值。</p>
<p>这个问题还有一个兄弟问题，那就是如下代码得到的结果是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原理和上面的是一样的，最终输出内容为3。</p>
<h2 id="扩展知识-13"><a href="#扩展知识-13" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="finally和return的关系"><a href="#finally和return的关系" class="headerlink" title="finally和return的关系"></a>finally和return的关系</h2><p>很多时候，我们的一个方法会通过return返回一个值，那么如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         i++;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">66</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个代码得到的结果是2，try-catch-finally的执行顺序是try-&gt;finally或者try-catch-finally，然后在执行每一个代码块的过程中，如果遇到return那么就会把当前的结果暂存，然后再执行后面的代码块，然后再把之前暂存的结果返回回去。</p>
<p>所以以上代码，会先把i++即2的结果暂存，然后执行i&#x3D;100，接着再把2返回。</p>
<p>但是，在执行后续的代码块过程中，如果遇到了新的return，那么之前的暂存结果就会被覆盖。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         i++;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">66</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码方法得到的结果是100，是因为在finally中遇到了一个新的return，就会把之前的结果给覆盖掉。</p>
<p>如果代码出现异常也同理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">66</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在try中出现一个异常之后，会执行catch，在执行finally，最终得到100。如果没有finally：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">66</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么得到的结果将是66。</p>
<p><strong>所以，如果finally块中有return语句，则其返回值将是整个try-catch-finally结构的返回值。如果finally块中没有return语句，则try或catch块中的return语句（取决于哪个执行了）将确定最终的返回值。</strong></p>
<h1 id="✅while-true-和for-哪个性能好？"><a href="#✅while-true-和for-哪个性能好？" class="headerlink" title="✅while(true)和for(;;)哪个性能好？"></a>✅while(true)和for(;;)哪个性能好？</h1><h2 id="典型回答-29"><a href="#典型回答-29" class="headerlink" title="典型回答"></a>典型回答</h2><p>while(true)和for(;;)都是做无限循环的代码，他俩有啥区别呢？</p>
<p>关于这个问题，网上有很多讨论，说那么多没用，直接反编译，看看字节码有啥区别就行了。</p>
<p>准备两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HollisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is hollis testing....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HollisTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is hollis testing....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分别将他们编译成class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HollisTest.java</span><br></pre></td></tr></table></figure>



<p>然后再通过javap对class文件进行反编译，然后我们就会发现，两个文件内容，<strong>一模一样！！！</strong></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/hollis/workspace/chaojue/HLab/src/main/java/HollisTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2023</span>-<span class="number">6</span>-<span class="number">18</span>; size <span class="number">463</span> bytes</span><br><span class="line">  MD5 checksum 38eddb7d25748625d7c9aa377b6f66d3</span><br><span class="line">  Compiled from <span class="string">&quot;HollisTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HollisTest</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">16</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">17.</span>#<span class="number">18</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">19</span>            <span class="comment">// this is hollis testing....</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">22</span>            <span class="comment">// HollisTest</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               main</span><br><span class="line">  #<span class="number">12</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">14</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">15</span> = Utf8               HollisTest.java</span><br><span class="line">  #<span class="number">16</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">17</span> = Class              #<span class="number">24</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">25</span>:#<span class="number">26</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               <span class="built_in">this</span> is hollis testing....</span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">27</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">28</span>:#<span class="number">29</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               HollisTest</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">24</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">25</span> = Utf8               out</span><br><span class="line">  #<span class="number">26</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">27</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">28</span> = Utf8               println</span><br><span class="line">  #<span class="number">29</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HollisTest</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String this is hollis testing....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">goto</span>          <span class="number">0</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">        frame_type = <span class="number">0</span> <span class="comment">/* same */</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;HollisTest.java&quot;</span></span><br></pre></td></tr></table></figure>



<p>可以看到，都是通过goto来干的，所以，这两者其实是没啥区别的。用哪个都行</p>
<p>有人愿意用while(true)因为他更清晰的看出来这里是个无限循环。有人愿意用for(;;)，因为有些IDE对于while(true)会给出警告。至于你，爱用啥用啥。</p>
<h1 id="✅常见的字符编码有哪些？有什么区别？"><a href="#✅常见的字符编码有哪些？有什么区别？" class="headerlink" title="✅常见的字符编码有哪些？有什么区别？"></a>✅常见的字符编码有哪些？有什么区别？</h1><h2 id="典型回答-30"><a href="#典型回答-30" class="headerlink" title="典型回答"></a>典型回答</h2><p>就像电报只能发出”滴”和”答”声一样，计算机只认识0和1两种字符，但是，人类的文字是多种多样的，如何把人类的文字转换成计算机认识的01字符呢，这个过程同样需要通过<strong>字符编码</strong>。</p>
<blockquote>
<p>字符编码（Character encoding）是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。</p>
</blockquote>
<p>和摩尔斯电码功能类似，上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定，这被称为 ASCII 码，一直沿用至今。</p>
<p>由于ASCII只有128个字符，虽然对于英文字符都可以表示了，但是世界上还有很多其他的文字他是没办法表示的，所以需要一种更加全面的字符编码。</p>
<p>于是又出现了<strong>Unicode字符集</strong>（常见的Unicode Transformation Format有：UTF-7, UTF-7.5, <strong>UTF-8</strong>,UTF-16, 以及 UTF-32），除此之外还有一些常用的中文编码有<strong>GBK</strong>，<strong>GB2312</strong>，<strong>GB18030</strong>等。</p>
<h2 id="扩展知识-14"><a href="#扩展知识-14" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="Unicode和UTF-8有啥关系？"><a href="#Unicode和UTF-8有啥关系？" class="headerlink" title="Unicode和UTF-8有啥关系？"></a>Unicode和UTF-8有啥关系？</h2><p>Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。</p>
<p>Unicode备受认可，并广泛地应用于计算机软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。</p>
<p><strong>Unicode是一套通用的字符集，包含世界上的大部分文字</strong>，也就是说，Unicode是可以表示中文的。</p>
<p>但是，<strong>Unicode虽然统一了全世界字符的编码，但没有规定如何存储。</strong></p>
<p>因为如果Unicode统一规定，每个符号就要用三个或四个字节表示，因为字符太多，只能用这么多字节才能表示完全。一旦这么规定，那么每个英文字母前都必然有二到三个字节是0，因为所有英文字母在ASCII中都有，都可以用一个字节表示，剩余字节位置就要补充0。如果这样，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。</p>
<p>为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，**即UTF（Unicode Transformation Format）。**常见的UTF格式有：UTF-7, UTF-7.5, UTF-8,UTF-16, 以及 UTF-32。</p>
<p>UTF-8 使用一至四个字节为每个字符编码</p>
<p>UTF-16 使用二或四个字节为每个字符编码</p>
<p>UTF-32 使用四个字节为每个字符编码</p>
<p><strong>所以我们可以说，UTF-8、UTF-16等都是 Unicode 的一种实现方式。</strong></p>
<hr>
<h2 id="有了UTF-8，为什么要出现GBK"><a href="#有了UTF-8，为什么要出现GBK" class="headerlink" title="有了UTF-8，为什么要出现GBK"></a>有了UTF-8，为什么要出现GBK</h2><p>因为UTF-8是Unicode的一种实现，所以他包含了世界上的所有文字的编码，他采用的是1-4字节进行编码。</p>
<p>对于那些排在前面优先纳入的文字，可能就优先使用1字节、2字节存储了，对于后纳入的文字，就要使用3字节或者4字节存储了。</p>
<p><strong>正是因为UTF-8太全了，所以那些晚一些纳入的字符，在UTF-8中的存储所占的字节数可能就会多一些，那他的存储空间要求就会很大。</strong></p>
<p>对于常用的汉字，在UTF-8中采用3字节进行编码，但是如果有一种只包含中文和ASCII的编码的话，就不需要使用3个字节，可能2个字节就够了。</p>
<p>对于大部分网站来说，基本都是只服务一个国家或者地区的，比如一个中国的网站，一般会出现简体字和繁体字以及一些英文字符，很少会出现日语或者韩文的。</p>
<p>也是出于这样的考虑，中国国家标准总局于1981年制定并实施了 GB 2312-80 编码，即中华人民共和国国家标准简体中文字符集。后来厂商微软利用GB 2312-80未使用的编码空间，收录GB 13000.1-93全部字符制定了GBK编码。</p>
<p>有了标准中文字符集，如果是一个纯中文网站，就可以可以采用这种编码方式，这样可以大大节省一些存储空间的。</p>
<p>常用的中文编码有GBK，GB2312，GB18030等，最常用的是GBK。</p>
<ul>
<li>GB2312（1980年）：16位字符集，收录有6763个简体汉字，682个符号，共7445个字符；<ul>
<li>优点：适用于简体中文环境，属于中国国家标准，通行于大陆，新加坡等地也使用此编码；</li>
<li>缺点：不兼容繁体中文，其汉字集合过少。</li>
</ul>
</li>
<li>GBK（1995年）：16位字符集，收录有21003个汉字，883个符号，共21886个字符；<ul>
<li>优点：适用于简繁中文共存的环境，为简体Windows所使用，向下完全兼容gb2312，向上支持 ISO-10646 国际标准 ；所有字符都可以一对一映射到unicode2.0上；</li>
<li>缺点：不属于官方标准，和big5之间需要转换；很多搜索引擎都不能很好地支持GBK汉字。</li>
</ul>
</li>
<li>GB18030（2000年）：32位字符集；收录了27484个汉字，同时收录了藏文、蒙文、维吾尔文等主要的少数民族文字。<ul>
<li>优点：可以收录所有你能想到的文字和符号，属于中国最新的国家标准；</li>
<li>缺点：目前支持它的软件较少。</li>
</ul>
</li>
</ul>
<h2 id="为什么会出现乱码"><a href="#为什么会出现乱码" class="headerlink" title="为什么会出现乱码"></a>为什么会出现乱码</h2><p>文件里面的内容归根到底都是有0101组成的，至于0101的二进制码如何转成人们可以理解的字符串，则是需要通过规定好的字符编码标准进行转换才可以。</p>
<p>我们把一串中文字符通过UTF-8进行编码传输给别人，别人拿到这串文字之后，通过GBK进行解码，得到的内容就会是“锟届瀿锟斤拷雮傡锟斤拷直锟斤拷锟”，这就是乱码。</p>
<h1 id="✅泛型中K-T-V-E-？-Object等分别代表什么含义。"><a href="#✅泛型中K-T-V-E-？-Object等分别代表什么含义。" class="headerlink" title="✅泛型中K T V E ？ Object等分别代表什么含义。"></a>✅泛型中K T V E ？ Object等分别代表什么含义。</h1><p>E – Element (在集合中使用，因为集合中存放的是元素)</p>
<p>T – Type（Java 类）</p>
<p>K – Key（键）</p>
<p>V – Value（值）</p>
<p>N – Number（数值类型）</p>
<p>？ – 表示不确定的java类型（无限制通配符类型）</p>
<p>S、U、V – 这几个有时候也有，这些字母本身没有特定的含义，它们只是代表某种未指定的类型。一般认为和T差不多。</p>
<p>Object – 是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p>
<h2 id="扩展知识-15"><a href="#扩展知识-15" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1：使用T作为泛型类型参数，表示任何类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T myField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyGenericClass</span><span class="params">(T myField)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myField = myField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getMyField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：使用K、V作为泛型类型参数，表示键值对中的键和值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&lt;K, V&gt;&gt; entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyMap</span><span class="params">()</span> &#123;</span><br><span class="line">        entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Entry&lt;K, V&gt; entry = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value);</span><br><span class="line">        entries.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3：使用E作为泛型类型参数，表示集合中的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例4：使用Object作为泛型类型参数，表示可以接受任何类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object myField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyGenericClass</span><span class="params">(Object myField)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myField = myField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getMyField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Cherises/">Leonardo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://cherises.github.io/post/34247/">https://cherises.github.io/post/34247/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://github.com/Cherises/">Leonardo</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/573.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/actor-1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo</div><div class="author-info-description">Focus on thinking, imagination, reasoning, truth-seeking, and pragmatism</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Cherises/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Arrays-sort%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">✅Arrays.sort是使用什么排序算法实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94"><span class="toc-number">1.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85BigDecimal-double-%E5%92%8CBigDecimal-String-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">✅BigDecimal(double)和BigDecimal(String)有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-1"><span class="toc-number">2.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">扩展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E8%AE%A1%E6%95%B0%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">BigDecimal如何精确计数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal-double-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">BigDecimal(double)有什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BigDecimal-String-%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.3.</span> <span class="toc-text">使用BigDecimal(String)创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85BigDecimal%E5%92%8CLong%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%90%88%E9%80%82%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">✅BigDecimal和Long表示金额哪个更合适，怎么选择？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-2"><span class="toc-number">3.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85char%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%AD%E6%96%87%E5%90%97%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">✅char能存储中文吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-3"><span class="toc-number">4.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85ClassNotFoundException%E5%92%8CNoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">✅ClassNotFoundException和NoClassDefFoundError的区别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-4"><span class="toc-number">5.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85final%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">✅final、finally、finalize有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-5"><span class="toc-number">6.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">6.1.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">6.1.2.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize"><span class="toc-number">6.1.3.</span> <span class="toc-text">finalize</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85finally%E4%B8%AD%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">✅finally中代码一定会执行吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-6"><span class="toc-number">7.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">✅Java的动态代理如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-7"><span class="toc-number">8.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">9.</span> <span class="toc-text">拓展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">静态代理和动态代理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">9.2.</span> <span class="toc-text">动态代理的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.3.</span> <span class="toc-text">Spring AOP的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">9.4.</span> <span class="toc-text">JDK 动态代理的代码段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">9.5.</span> <span class="toc-text">Cglib动态代理的代码段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E5%92%8CC-%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">✅Java和C++主要区别有哪些？各有哪些优缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-8"><span class="toc-number">10.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">✅Java是值传递还是引用传递？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-9"><span class="toc-number">11.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-1"><span class="toc-number">11.2.</span> <span class="toc-text">扩展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5"><span class="toc-number">11.2.1.</span> <span class="toc-text">Java的求值策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92"><span class="toc-number">11.2.2.</span> <span class="toc-text">Java中的对象传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E7%9A%84%E7%8E%B0%E8%B1%A1%E5%86%B2%E7%AA%81%E5%90%97%EF%BC%9F"><span class="toc-number">11.2.3.</span> <span class="toc-text">值传递和共享对象传递的现象冲突吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E5%95%A5"><span class="toc-number">12.</span> <span class="toc-text">✅Java序列化的原理是啥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-10"><span class="toc-number">12.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95"><span class="toc-number">13.</span> <span class="toc-text">知识拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Serializable-%E5%92%8C-Externalizable-%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">Serializable 和 Externalizable 接口有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">13.2.</span> <span class="toc-text">在Java中，有哪些好的序列化框架，有什么好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%ADTimer%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">✅Java中Timer实现定时调度的原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-11"><span class="toc-number">14.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-2"><span class="toc-number">14.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">14.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">✅Java中创建对象有哪些种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-12"><span class="toc-number">15.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.1.1.</span> <span class="toc-text">使用new关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">15.1.2.</span> <span class="toc-text">使用反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8clone%E6%96%B9%E6%B3%95"><span class="toc-number">15.1.3.</span> <span class="toc-text">使用clone方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">15.1.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">15.1.5.</span> <span class="toc-text">使用反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-number">15.1.6.</span> <span class="toc-text">使用方法句柄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Unsafe%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">15.1.7.</span> <span class="toc-text">使用Unsafe分配内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%AD%E7%9A%84static%E9%83%BD%E8%83%BD%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">✅Java中的static都能用来修饰什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-13"><span class="toc-number">16.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E5%92%8C%E5%A5%BD%E5%A4%84"><span class="toc-number">17.</span> <span class="toc-text">✅Java中的枚举有什么特点和好处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9E%9A%E4%B8%BE%E7%9A%84valueOf%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AF%B9%E5%85%A5%E5%8F%82%E8%BF%9B%E8%A1%8C%E9%9D%9E%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E6%A0%A1%E9%AA%8C"><span class="toc-number">17.0.1.</span> <span class="toc-text">1、枚举的valueOf可以自动对入参进行非法参数的校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%9E%9A%E4%B8%BE%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84%E5%B8%B8%E9%87%8F%E6%9D%A5%E8%AF%B4%E6%93%8D%E4%BD%9C%E6%80%A7%E6%9B%B4%E5%BC%BA"><span class="toc-number">17.0.2.</span> <span class="toc-text">2、可以调用枚举中的方法，相对于普通的常量来说操作性更强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%AE%B9%E6%98%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.0.3.</span> <span class="toc-text">3、枚举实现接口的话，可以很容易的实现策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B8%A6%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%89%A9%E5%B1%95%E6%80%A7%E6%9B%B4%E5%BC%BA"><span class="toc-number">17.0.4.</span> <span class="toc-text">4、枚举可以自带属性，扩展性更强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%A4%A9%E7%94%9F%E5%B0%B1%E6%98%AF%E4%B8%AA%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%94%E4%B8%8D%E6%80%95%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="toc-number">17.0.5.</span> <span class="toc-text">5、天生就是个单例，线程安全且不怕被破坏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-3"><span class="toc-number">17.1.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">17.2.</span> <span class="toc-text">枚举如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83"><span class="toc-number">17.3.</span> <span class="toc-text">枚举如何比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%88%86%E5%93%AA%E4%B8%A4%E7%B1%BB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">✅Java中异常分哪两类，有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-14"><span class="toc-number">18.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95"><span class="toc-number">19.</span> <span class="toc-text">知识扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFThrowable"><span class="toc-number">19.1.</span> <span class="toc-text">什么是Throwable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">19.2.</span> <span class="toc-text">Error和Exception的区别和联系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E4%B8%AD%E6%9C%89%E4%BA%86%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">✅Java中有了基本类型为什么还需要包装类？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-15"><span class="toc-number">20.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-1"><span class="toc-number">20.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.3.</span> <span class="toc-text">基本类型和包装类型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%AD%E5%BA%94%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">20.4.</span> <span class="toc-text">接口定义中应该用什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">20.5.</span> <span class="toc-text">如何理解自动拆装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1"><span class="toc-number">20.5.1.</span> <span class="toc-text">拆箱与装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">20.5.2.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86"><span class="toc-number">20.5.3.</span> <span class="toc-text">自动拆装箱原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">20.6.</span> <span class="toc-text">哪些地方会自动拆装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%E3%80%81%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%94%BE%E5%85%A5%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">20.6.1.</span> <span class="toc-text">场景一、将基本数据类型放入集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-number">20.6.2.</span> <span class="toc-text">场景二、包装类型和基本类型的大小比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">20.6.3.</span> <span class="toc-text">场景三、包装类型的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9B%E3%80%81%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">20.6.4.</span> <span class="toc-text">场景四、三目运算符的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">20.6.5.</span> <span class="toc-text">场景五、函数参数与返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%B8%8E%E7%BC%93%E5%AD%98"><span class="toc-number">20.7.</span> <span class="toc-text">自动拆装箱与缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E5%95%A5"><span class="toc-number">21.</span> <span class="toc-text">✅Java注解的作用是啥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-16"><span class="toc-number">21.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-4"><span class="toc-number">21.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.3.</span> <span class="toc-text">什么是元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Retention"><span class="toc-number">21.3.1.</span> <span class="toc-text">@Retention</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target"><span class="toc-number">21.3.2.</span> <span class="toc-text">@Target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Documented"><span class="toc-number">21.3.3.</span> <span class="toc-text">@Documented</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inherited"><span class="toc-number">21.3.4.</span> <span class="toc-text">@Inherited</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85JDK-9%E4%B8%AD%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">✅JDK 9中对字符串的拼接做了什么优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-17"><span class="toc-number">22.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85JDK%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">✅JDK新版本中都有哪些新特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-18"><span class="toc-number">23.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-5"><span class="toc-number">23.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">23.3.</span> <span class="toc-text">本地变量类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.4.</span> <span class="toc-text">Switch 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text-Blocks"><span class="toc-number">23.5.</span> <span class="toc-text">Text Blocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Records"><span class="toc-number">23.6.</span> <span class="toc-text">Records</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-number">23.7.</span> <span class="toc-text">封闭类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">23.8.</span> <span class="toc-text">instanceof 模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">23.9.</span> <span class="toc-text">switch 模式匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">✅Lambda表达式是如何实现的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85RPC%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">✅RPC接口返回中，使用基本类型还是包装类？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-19"><span class="toc-number">25.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-2"><span class="toc-number">25.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F%EF%BC%9F"><span class="toc-number">25.3.</span> <span class="toc-text">在接口定义的时候，如何定义一个字段表示是否成功？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85serialVersionUID-%E6%9C%89%E4%BD%95%E7%94%A8%E9%80%94-%E5%A6%82%E6%9E%9C%E6%B2%A1%E5%AE%9A%E4%B9%89%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">✅serialVersionUID 有何用途? 如果没定义会有什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-6"><span class="toc-number">26.1.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E4%BA%86%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">26.2.</span> <span class="toc-text">改了会怎么样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%8E%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AAserialVersionUID"><span class="toc-number">26.3.</span> <span class="toc-text">为什么要明确定一个serialVersionUID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85SimpleDateFormat%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">✅SimpleDateFormat是线程安全的吗？使用时应该注意什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-20"><span class="toc-number">27.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-7"><span class="toc-number">27.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleDateFormat%E7%94%A8%E6%B3%95"><span class="toc-number">27.3.</span> <span class="toc-text">SimpleDateFormat用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E6%96%B9%E6%B3%95"><span class="toc-number">27.3.1.</span> <span class="toc-text">日期和时间模式表达方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%8D%E5%90%8C%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">27.3.2.</span> <span class="toc-text">输出不同时区的时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">27.4.</span> <span class="toc-text">SimpleDateFormat线程安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0"><span class="toc-number">27.4.1.</span> <span class="toc-text">问题重现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0"><span class="toc-number">27.4.2.</span> <span class="toc-text">线程不安全原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">27.4.3.</span> <span class="toc-text">如何解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85Stream%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%B8%80%E5%AE%9A%E6%AF%94%E4%B8%B2%E8%A1%8C%E6%B5%81%E6%9B%B4%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">✅Stream的并行流一定比串行流更快吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-21"><span class="toc-number">28.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">✅String、StringBuilder和StringBuffer的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-22"><span class="toc-number">29.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-8"><span class="toc-number">29.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">29.3.</span> <span class="toc-text">String的不可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">29.4.</span> <span class="toc-text">为什么设计成不可变的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E2%80%9D-%E2%80%9D%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">29.5.</span> <span class="toc-text">String的”+”是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">29.6.</span> <span class="toc-text">StringBuffer和StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8-%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">29.7.</span> <span class="toc-text">不要在for循环中使用+拼接字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String-a-%E2%80%9Cab%E2%80%9D-String-b-%E2%80%9Ca%E2%80%9D-%E2%80%9Cb%E2%80%9D-a-b-%E5%90%97%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">✅String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-23"><span class="toc-number">30.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-9"><span class="toc-number">30.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">30.3.</span> <span class="toc-text">字面量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String-str-new-String-%E2%80%9Chollis%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">✅String str&#x3D;new String(“hollis”)创建了几个对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-24"><span class="toc-number">31.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-10"><span class="toc-number">31.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">31.3.</span> <span class="toc-text">字面量和运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern"><span class="toc-number">31.4.</span> <span class="toc-text">intern</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#intern%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="toc-number">31.4.1.</span> <span class="toc-text">intern的正确用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">✅String是如何实现不可变的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-25"><span class="toc-number">32.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">✅String为什么设计成不可变的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">33.0.1.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">33.0.2.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">33.0.3.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E7%BC%93%E5%AD%98"><span class="toc-number">33.0.4.</span> <span class="toc-text">hashcode缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">33.0.5.</span> <span class="toc-text">性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String%E6%9C%89%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">✅String有长度限制吗？是多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-26"><span class="toc-number">34.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-11"><span class="toc-number">34.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%99%90%E5%88%B6"><span class="toc-number">34.3.</span> <span class="toc-text">常量池限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%99%90%E5%88%B6"><span class="toc-number">34.4.</span> <span class="toc-text">运行期限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85String%E4%B8%ADintern%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">✅String中intern的原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-27"><span class="toc-number">35.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-12"><span class="toc-number">35.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E8%BF%9B%E5%85%A5%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">35.3.</span> <span class="toc-text">字符串常量进入常量池的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern%E5%8E%9F%E7%90%86"><span class="toc-number">35.4.</span> <span class="toc-text">intern原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a%E5%92%8C1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">35.5.</span> <span class="toc-text">a和1有什么不同</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85try%E4%B8%ADreturn-A%EF%BC%8Ccatch%E4%B8%ADreturn-B%EF%BC%8Cfinally%E4%B8%ADreturn-C%EF%BC%8C%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">✅try中return A，catch中return B，finally中return C，最终返回值是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-28"><span class="toc-number">36.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-13"><span class="toc-number">36.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally%E5%92%8Creturn%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">36.3.</span> <span class="toc-text">finally和return的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85while-true-%E5%92%8Cfor-%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">✅while(true)和for(;;)哪个性能好？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-29"><span class="toc-number">37.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">✅常见的字符编码有哪些？有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-30"><span class="toc-number">38.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-14"><span class="toc-number">38.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unicode%E5%92%8CUTF-8%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">38.3.</span> <span class="toc-text">Unicode和UTF-8有啥关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BA%86UTF-8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%87%BA%E7%8E%B0GBK"><span class="toc-number">38.4.</span> <span class="toc-text">有了UTF-8，为什么要出现GBK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81"><span class="toc-number">38.5.</span> <span class="toc-text">为什么会出现乱码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E6%B3%9B%E5%9E%8B%E4%B8%ADK-T-V-E-%EF%BC%9F-Object%E7%AD%89%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%E3%80%82"><span class="toc-number">39.</span> <span class="toc-text">✅泛型中K T V E ？ Object等分别代表什么含义。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-15"><span class="toc-number">39.1.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">39.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/37181/" title="获取新闻列表并调用大模型总结"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/195.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="获取新闻列表并调用大模型总结"/></a><div class="content"><a class="title" href="/post/37181/" title="获取新闻列表并调用大模型总结">获取新闻列表并调用大模型总结</a><time datetime="2025-11-16T17:20:17.000Z" title="Created 2025-11-16 17:20:17">2025-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/42087/" title="2025年11月16日网易新闻总结"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/596.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025年11月16日网易新闻总结"/></a><div class="content"><a class="title" href="/post/42087/" title="2025年11月16日网易新闻总结">2025年11月16日网易新闻总结</a><time datetime="2025-11-16T12:00:35.000Z" title="Created 2025-11-16 12:00:35">2025-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/61362/" title="2025年11月14日"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/51.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025年11月14日"/></a><div class="content"><a class="title" href="/post/61362/" title="2025年11月14日">2025年11月14日</a><time datetime="2025-11-14T17:51:59.000Z" title="Created 2025-11-14 17:51:59">2025-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2522/" title="第一个微调训练模型"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/168.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一个微调训练模型"/></a><div class="content"><a class="title" href="/post/2522/" title="第一个微调训练模型">第一个微调训练模型</a><time datetime="2025-11-12T20:15:08.000Z" title="Created 2025-11-12 20:15:08">2025-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/26464/" title="关于搭建本地知识库的可行性分析"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/709.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于搭建本地知识库的可行性分析"/></a><div class="content"><a class="title" href="/post/26464/" title="关于搭建本地知识库的可行性分析">关于搭建本地知识库的可行性分析</a><time datetime="2025-11-12T10:24:12.000Z" title="Created 2025-11-12 10:24:12">2025-11-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By Leonardo</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/scroll-disable-blur.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章🔍" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>